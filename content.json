{"meta":{"title":"WhiteTail's Blog","subtitle":"","description":"","author":"WhiteTail","url":"http://example.com","root":"/"},"pages":[{"title":"关于","date":"2023-02-03T11:37:30.151Z","updated":"2023-02-03T11:37:30.151Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"友情链接","date":"2023-02-03T11:19:24.219Z","updated":"2023-02-03T11:19:24.219Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-02-03T14:41:39.532Z","updated":"2023-02-03T11:19:24.220Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2023-02-03T11:19:24.218Z","updated":"2023-02-03T11:19:24.218Z","comments":false,"path":"/404.html","permalink":"http://example.com/404.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-02-03T11:19:24.219Z","updated":"2023-02-03T11:19:24.219Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-02-03T11:37:33.022Z","updated":"2023-02-03T11:19:24.219Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"书单","date":"2023-02-03T11:19:24.219Z","updated":"2023-02-03T11:19:24.219Z","comments":false,"path":"books/index.html","permalink":"http://example.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-02-03T12:27:35.586Z","updated":"2023-02-03T12:27:32.147Z","comments":true,"path":"categories/test.html","permalink":"http://example.com/categories/test.html","excerpt":"","text":""}],"posts":[{"title":"Games202-4 Real-time Global Illumination(in 3D)","slug":"Games202_04_Real-time Global Illumination","date":"2023-02-02T09:23:32.000Z","updated":"2023-02-03T14:12:51.017Z","comments":true,"path":"2023/02/02/Games202_04_Real-time Global Illumination/","link":"","permalink":"http://example.com/2023/02/02/Games202_04_Real-time%20Global%20Illumination/","excerpt":"","text":"Real-time Global Illumination(in 3D) a). Introduction In RTR, people seek simple and fast solutions to one bounce indirect illumination Primary LIght Source（真正的光源，太阳） Secondary Light Source(次级光源，Q点) 观察（要得到ppp点的间接光照我们需要做什么）： 得到Secondary light source（哪些点被光源照射到） 方法： Shadow Mapping 得到各个Secondary light source对 ppp点 Radiance的贡献 方法： 解渲染方程 以下是实时渲染中常用的在3D空间中（意为渲染效果不取决于相机位置/屏幕空间）的GI方法（主要针对one bounce indirect illumination）： Reflective Shadow Maps (RSM) Light Propagation Volumes (LPV) Voxel Global Illumination (VXGI) b). Reflective Shadow Maps (RSM) 得到Secondary light source（哪些点被光源照射到） Shadow map中每一个Texel都是一个作为Secondary light sourc的面片（Surface patch） Shadow map做阴影中是光源视角的DepthDepthDepth，和相机视角的比较；这里是光源视角的DepthDepthDepth和 点ppp 视角比较 得到各个Secondary light source对 ppp点 Radiance的贡献 但是，对于不同的 点ppp 次级光源入射方向是不一定的。即，即使观察角度固定，同一个Shadow map中的Surface patch，对不同的 ppp 贡献不同； 假设： 次级光源均为Diffuse（观察角度固定，同一个次级光源对不同 点ppp 的贡献相同） Therefore, outgoing radiance is uniform toward all directions b.1). 得到各个Secondary light source对 ppp点 Radiance的贡献 Lo(p,ωo)=∫ΩpatchLi(p,ωi)V(p,ωi)fr(p,ωi,ωo)cos⁡θi dωi=∫ApatchLi(q→p)V(p,ωi)fr(p,q→p,ωo)cos⁡θpcos⁡θq∥q−p∥2 dA\\begin{aligned} L_{o}\\left(\\mathrm{p}, \\omega_{o}\\right) &amp; =\\int_{\\Omega_{\\mathrm{patch}}} L_{i}\\left(\\mathrm{p}, \\omega_{i}\\right) V\\left(\\mathrm{p}, \\omega_{i}\\right) f_{r}\\left(\\mathrm{p}, \\omega_{i}, \\omega_{o}\\right) \\cos \\theta_{i} \\mathrm{~d} \\omega_{i} \\\\ &amp; =\\int_{A_{\\mathrm{patch}}} L_{i}(\\mathrm{q} \\rightarrow \\mathrm{p}) V\\left(\\mathrm{p}, \\omega_{i}\\right) f_{r}\\left(\\mathrm{p}, \\mathrm{q} \\rightarrow \\mathrm{p}, \\omega_{o}\\right) \\frac{\\cos \\theta_{p} \\cos \\theta_{q}}{\\|q-p\\|^{2}} \\mathrm{~d} A \\end{aligned} Lo​(p,ωo​)​=∫Ωpatch​​Li​(p,ωi​)V(p,ωi​)fr​(p,ωi​,ωo​)cosθi​ dωi​=∫Apatch​​Li​(q→p)V(p,ωi​)fr​(p,q→p,ωo​)∥q−p∥2cosθp​cosθq​​ dA​ 对于每个diffuse reflective patch(点qqq) 点qqq 的BRDF: frq=ρ/πf_{rq} = \\rho/\\pifrq​=ρ/π Li(q→p)=frq⋅ΦdAL_i(q\\rightarrow p) = f_{rq} \\cdot \\frac{\\Phi}{d A}Li​(q→p)=frq​⋅dAΦ​ ( Φ\\PhiΦ 是光源的辐射通量，将该式带入渲染方程，dA{d A}dA 被消除) Eq(x,n)=Φqmax{0,⟨nq∣x−xq⟩}max{0,⟨n∣xq−x⟩}∣∣x−xq∣∣4.E_{q}(x,n)=\\Phi_{q}\\frac{\\mathrm{max}\\{0,\\langle n_{q}|x-x_{q}\\rangle\\}\\mathrm{max}\\{0,\\langle n|x_{q}-x\\rangle\\}}{||x-x_{q}||^{4}}. Eq​(x,n)=Φq​∣∣x−xq​∣∣4max{0,⟨nq​∣x−xq​⟩}max{0,⟨n∣xq​−x⟩}​. ∣∣x−xq∣∣4{||x-x_{q}||^{4}}∣∣x−xq​∣∣4 是因为分子上x−xqx-x_{q}x−xq​是未归一化的向量； Φp\\Phi_pΦp​ 为 frq⋅Φf_{rq} \\cdot {\\Phi}frq​⋅Φ 将Ep(x,n)E_p(x,n)Ep​(x,n) 乘上 点ppp 的BRDF即可得出LoL_oLo​ VVV：Visibility项就不算了 Not all pixels in the RSM can contribute Visibility (难处理，不管了) Orientation（方向，Reflector的反射方向只在法向半球上，法向半球的方向覆盖不到的Shading Point自然不受该Reflector的影响） Distance（只有和Shading Point近的Reflector才做贡献） 假设： 世界坐标下，两点接近 →\\rightarrow→ Shadow Map（世界空间转换到光源空间）中距离比较近，且深度相差不大； 进一步加速（类似于Step 1 and 3 in PCSS），在shading point转换到Shadow Map后对应点(s,t)(s,t)(s,t) 的一定范围内，做随机采样 b.2). 光源视角下储存的信息（Shadow Map） 深度 世界坐标 法线 辐射通量（flux） etc. b.3). Pros And Cons Pros: 好写（类似于Shadow Map） Cons: 计算量随光源（Primary Light Source）数量增多线性增加 Visibility无法处理 很多假设：diffuse reflectors, depth as distance, etc. 只能处理次级光源为Diffuse 质量依赖于采样率 c). Light Propagation Volumes(LPV) CryEngine3 里用到了，在孤岛危机里应用 快而且质量好 同样也只能处理次级光源为Diffuse Key idea: 光线直线传播中，Radiance大小不变； Key solution: 通过3D网格**(体素，Voxel)**，传播Secondary Light Source/dirctly illminated surfaces的Radiance到其他地方； Steps: 生成场景中被直接光照照射到的Radiance point(即Secondary light source)； 将Radiance point注入到体素中； Radiance在体素中传播； 传播稳定后（一般迭代4、5次），通过体素中储存的Radiance进行Shading； c.1). 做法 Step 1: Generation 找到Secondary light source 使用Reflective Shadow Maps (RSM)； Step 2: Injection(注入) 预先划分好3D网格（体素）； 对于每一个体素，找到其内部的Secondary light source； 将他们出射的Radiance大小和方向看做是球面函数，投影到2阶（4个）的球谐函数上； Step 3: Propagation(传播) 对于每一个Voxel，都会传播到相邻的6个面（3D，前后左右上下，不会斜向传播），也会接收6个面的Radiance； 接收6个面的Radiance并相加后，再次使用SH表示； 重复上述步骤，直至传播接近稳定（一般整体迭代4-5次） Step4: Rendering 对于每一个着色点，找到他们所处的Voxel； 使用该Voxel中存储的Radiance**（from all direction, 是一个SH表达的球面函数）**，进行Shading； 因为存储的是球面函数形式的Radiance，所以既可以做Diffuse也可以做Gloosy 造成的问题： 由于同一个Voxel中Radiance相同，对于薄的几何体可能造成Light leaking d). Voxel Global Illumination (VXGI) 与RSM两点主要的不同 将被光源直接照射的像素变为带有层级的体素（hierarchical voxels）（即Secondary light source不再看成surface patch，而是hierarchical voxels） 光线传播方式： 从摄像机开始传播，进行锥形传播（Cone tracing，比如光线在Gloosy表面弹射，出射方向为一个锥形），计算锥体相交的Voxel对该点的Radiance贡献； d.1). 做法 Pass 1: from the light 储存每个点的入射Radiance，并储存到对应的Voxel中； Voxel中存储Incident lighting和normal的分布，以便支持Gloosy等材质； 存储Lobe分布的基础：Cone Trace 根据这两个分布，即可得出 出射Radiance 的分布情况； Pass 2: from the camera 对于Gloosy的表面，追踪1个朝向反射方向的圆锥； 根据圆锥的（grow）大小，查询相应层级； 对于Diffuse，追踪多个Cones","categories":[{"name":"Games202","slug":"Games202","permalink":"http://example.com/categories/Games202/"}],"tags":[]},{"title":"Games202-3 Real-time Environment Mapping","slug":"Games202_03_Real-time Environment Mapping","date":"2023-02-01T08:42:10.000Z","updated":"2023-02-03T13:25:38.753Z","comments":true,"path":"2023/02/01/Games202_03_Real-time Environment Mapping/","link":"","permalink":"http://example.com/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/","excerpt":"","text":"Mesh Distance Fields，Real Shading in Unreal Engine 4 a). Shading from Environment Lighting(IBL) 通过环境贴图着色的方式，又被命名为 Image-Based Lighting (IBL) a.1). How 对于IBL，可以看做是上半球（可以联想下UE中的HDRI）的光照和BRDF的积分； Observation： 对于Glossy，其BRDF支持集很小（Lobe范围小）； 对于Diffuse，其BRDF非常平滑； 联想到上节课渲染方程不等式成立的条件（拆出乘积积分的那个） 这里ΩG\\Omega_{G}ΩG​ 指积分域上，g(x)g(x)g(x)有值的区域。 如g(x)g(x)g(x) 为BRDF，ΩG\\Omega_{G}ΩG​ 即为原点向Lobe各点出发，与积分半球相交的区域集合 We can safely take the lighting term out! 我们把渲染方程分为了两部分积分，分别是： 在Ωfr\\Omega_{fr}Ωfr​(即Lobe对应的半球区域)，对光照Radiance积分 在半球内对BRDF积分； a.2). Lighting（对Radiance积分） Lighting： ∫ΩfrLi(p,ωi)dωi∫Ωfr dωi\\frac{\\int_{\\Omega_{f_{r}}} L_{i}\\left(p, \\omega_{i}\\right) \\mathrm{d} \\omega_{i}}{\\int_{\\Omega_{f_{r}}} \\mathrm{~d} \\omega_{i}} ∫Ωfr​​​ dωi​∫Ωfr​​​Li​(p,ωi​)dωi​​ 即在Ωfr\\Omega_{fr}Ωfr​(即Lobe对应的半球区域)，对光照Radiance积分，再归一化（normalize，分母用于归一化）； 类比于PCF，就是对Environment Map做滤波； 滤波方法：Mipmap 在Shading中，需要获得Lighting项的值，只需要求得Environment Map对应Mipmap层，Lobe中点(镜面反射方向)方向的结果 和百人计划图形2.5中，做Relief Mapping时在Unity用到的texCUBElod()，对Mipmap采样联系上了； 1fixed3 Reflection = ACESToneMapping(texCUBElod(_CubeMap, float4(worldRef, (255-_Gloss)*8/255)).rgb, 1) * SpecularTint * _EnvIntensity; a.3). 对BRDF积分（Split Sum） ∫Ω+fr(p,wi,wo)cosθidωi\\int_{\\Omega^+}f_r(p,w_i,w_o)cos\\theta_i d\\omega_i ∫Ω+​fr​(p,wi​,wo​)cosθi​dωi​ 假设使用微表面理论的BRDF 做法： 预计算考虑进所有变量（roughness、color等）的可能值的积分； 但是，维度过高，存储成本过高，因此需要降维； 降维过程： 对应微表面BRDF，只考虑Fresnel term(F(i,h)F(i,h)F(i,h))和distribution of normals(D(h)D(h)D(h)) Fresnel term采用the Schlick’s approximation 至此，积分降维为三维 R0R_0R0​ ：零度菲涅尔值 α\\alphaα ：可表示为roughness，α\\alphaα 越大，越粗糙； θ(θh)\\theta(\\theta_h)θ(θh​) ：在实时渲染中，我们认为出射角、入射角以及入射角/出射角与半程向量的夹角，这三者是相同性质的（不是说值近似相等，而是指作为积分的元素效果相同） 在对BRDF的积分式中，通过Schlick’s approximation，将R0R_0R0​拆出，即写成下列式子 积分现在被降维为二维（R0R_0R0​被拆出，frf_rfr​中的菲涅尔项被分母抵消） α\\alphaα θ\\thetaθ 至此，我们对积分的两项分别进行预计算，储存在表格或者图片中（R、G通道分别两项积分结果）通过LUT查询即可 而R0R_0R0​ 则可通过BaseColor（Metallic Workflow）、Specular（Specular Workflow）贴图或软件内置（一般默认为4%）即可获得；（看百人计划美术 2.7 Metallic与Speculer流程） 名字由来： Split sum 假设使用Lambert的BRDF ∫Ω+fr(p,wi,wo)cosθidωi\\int_{\\Omega^+}f_r(p,w_i,w_o)cos\\theta_i d\\omega_i ∫Ω+​fr​(p,wi​,wo​)cosθi​dωi​ fr=1πf_r = {1\\over \\pi}fr​=π1​ ∫Ω+cosθidωi=π\\int_{\\Omega^+}cos\\theta_i d\\omega_i = \\pi∫Ω+​cosθi​dωi​=π （看Games101 Lecture 17-18 Materials二重积分） 所以正好BRDF积分为1 b). Shadow from Environment Light 在实时渲染中，没有完美的解决方案； 难以用实时渲染方程（那个不等式）来近似： Support大，为整个半球 带有Gloosy项，不够smooth 工业界方法： 只计算最亮的灯光（如UE中HDRI带一个Direction Light） Related research Imperfect shadow maps Light cuts RTRT (Real-Time Ray Tracing, might be the ultimate solution) Precomputed radiance transfer(PRT) c). Spherical Harmonics(SH, 球面谐波函数) c.1). 前置知识 Fourier Transform 这里是偶函数，所以 sinsinsin 项系数都为0 Convolution Theorem 时域卷积等于频域乘积 A general understanding ![A general understanding_Basic](A general understanding_Basic.png) product intergral: 相乘后积分，对应离散的情况就是相乘后相加。如： nnn维向量a=(x1,x2,...,xn)\\bold{a} = (x_1, x_2,...,x_n)a=(x1​,x2​,...,xn​) 和 b=(y1,y2,...,yn)\\bold{b} = (y_1, y_2,...,y_n)b=(y1​,y2​,...,yn​) 进行product intergral，即点乘 a⋅b=x1y1+x2y2+...+xnyn\\bold{a} \\cdot \\bold{b} = x_1y_1+x_2y_2+...+x_ny_na⋅b=x1​y1​+x2​y2​+...+xn​yn​ 我们认为，函数相乘后积分（product intergral），就是滤波（卷积） 积分结果的频率，取决于频率最低的项（f(x),g(x)f(x),g(x)f(x),g(x)） Basis Functions（基函数） cic_ici​ 为系数 如傅里叶变换中，各项就为正交基； 或者多项式和泰勒展开等 c.2). 简介 What？ 球谐函数 是一系列 二维球面函数的正交基函数 球谐函数具有正交、归一、完备性 如 f(ω)=∑ici⋅Bi(ω)f(\\omega)=\\sum_{i} c_{i} \\cdot B_{i}(\\omega) f(ω)=i∑​ci​⋅Bi​(ω) f(ω)f(\\omega)f(ω) 为球面函数，ω\\omegaω 为向量 cic_ici​ 为系数 Bi(ω)B_{i}(\\omega)Bi​(ω) 则为球谐函数 说明： 每一行（l=nl=nl=n），频率相同 对于l=nl=nl=n行（第nnn阶），函数数量为2l+12l+12l+1 每一阶各SH都有编号，即mmm 从−l-l−l 到 lll； How？ 每一阶的SH函数，由勒让德多项式求得； 如何求得cic_ici​ 投影（Projection） 类似于傅里叶展开中，函数和各个正交基相乘求系数 c.3). 性质 正交性； 投影性； 旋转方便（旋转f(x)f(x)f(x)，相当于旋转基函数B(i)B(i)B(i)） SH中，旋转后的基函数，可通过同阶的基函数线性组合得到； d). Shading from Environment Lighting(SH, Diffuse项) d.1). 简介 如果不通过IBL方式，计算shading，**那可以通过SH展开Li(p,ωi)L_i(p,\\omega_i)Li​(p,ωi​) ，即展开Environment Map（**Environment Map可以写成二维函数） d.2). 分析Diffuse项的BRDF AlA_lAl​ 就是基函数的系数； 由图可见，通过SH分析Diffuse项的BRDF后，可得出结论 当l≥3l\\geq3l≥3 (即第四阶开始)，其 AlA_lAl​ 接近0，说明Diffuse项的BRDF频率低，由SH前三阶表示即可； 积分结果的频率，取决于频率最低的项（f(x),g(x)f(x),g(x)f(x),g(x)） Diffuse BRDF acts like a low-pass filter 因此，对于Environment Map的展开，只需要SH前三阶即可 d.3). SH展开Environment Map 通过求得各球谐函数的结果后，再通过结果逆变换得到Shading结果 通过ShadingPoint法线，再经过一系列计算（？）得到shading e). Precomputed Radiance Transfer 对于渲染方程，如果我们把它每一项都进行Brute-force（蛮力）计算 LiL_iLi​ : 二维，方位角ω\\omegaω和俯仰角θ\\thetaθ V(i)V(i)V(i) : 二维，方位角和俯仰角 ρ(i,o)\\rho(\\mathbf{i}, \\mathbf{o})ρ(i,o) : 四维，入射角和出射角的方位角和俯仰角 存储压力过于大； e.1). PRT 前提： 假设场景中除了Lighting，其他都不变； 将RE分为两项， Lighting变化； light transport不变； $V(i): $ 二维，ω,θ\\omega,\\thetaω,θ，可烘焙为图像，如CubeMap（场景摆放固定） $\\rho(\\mathbf{i}, \\mathbf{o}): $ BRDF Diffuse Case: 常数 Gloosy Case: 四维，ωi,θi,ωo,θo\\omega_{i},\\theta_i, \\omega_o,\\theta_oωi​,θi​,ωo​,θo​，入射和出射的方位角和俯仰角（相机固定，入射角固定） e.2). Diffuse Case 此处（图形学中，大部分情况都是），积分和求和位置可变； 经过预计算后，求得Shading结果只需要在SH空间中，对向量进行点乘即可； e.2.1). 计算 注意： 此处两次求和复杂度仍然是O(n)O(n)O(n)，因为SH基函数具有正交性； Runtime is independent of transport complexity 计算Light Transport简易理解： 积分形式和渲染方程相似，Bi(i)B_i(\\bold{i})Bi​(i) 类似于Li(i)L_i(\\bold{i})Li​(i) ，可看成是将球谐函数作为光照进行Shading得到Light Transport结果 e.3). Glossy Case 此时，BRDF是关于入射和出射的方位角和俯仰角的四维函数； 做法： 对 o\\bold{o}o 也进行SH展开；（对于Gloosy不止展开到第三阶） light coefficient与Diffuse Case相同，为SH空间的一维向量； transport matrix则是关于 o\\bold{o}o 和 i\\bold{i}i 四维函数（入射和出射的方位角和俯仰角），为SH空间的二维矩阵； reflected radiance coefficient则是关于 o\\bold{o}o 的二维函数（出射角的方位角和俯仰角），通过SH逆变换，即可得出相应视角（ o\\bold{o}o ）下的Gloosy radiance； 具体怎么变换的？待实现 e.4). 总结和限制 f). Wavelet(小波) 定义在二维平面上的一系列基函数 A non-linear approximation: 二维函数经过小波变换后，大部分系数接近0，这时可采用只记录系数大于一定值的项来近似原函数； 对于Environment Map，小波变换无法变换球面函数，因此展开为Cubemap后进行小波变换； 每一个矩形经过小波变换后，把高频信息放在右上、右下、左下子块，剩下的低频信息放在左上，继续做小波变换； **其他应用：**JPG格式图片压缩， 使用类似与小波变换的DCT（Discrete cosine transform，离散余弦变换）、JPEG2000 效果对比： 缺点： 旋转不方便（不同于SH基函数的旋转简易型，小波旋转需要从Wavelet展开，旋转后再做小波变换）","categories":[{"name":"Games202","slug":"Games202","permalink":"http://example.com/categories/Games202/"}],"tags":[]},{"title":"Games202-2 Real-Time Shadow","slug":"Games202_02_Real-Time Shadow","date":"2023-02-01T08:23:10.000Z","updated":"2023-02-03T13:25:30.901Z","comments":true,"path":"2023/02/01/Games202_02_Real-Time Shadow/","link":"","permalink":"http://example.com/2023/02/01/Games202_02_Real-Time%20Shadow/","excerpt":"","text":"a). Shadow Mapping A 2-Pass Algorithm Light pass: Generate the SM(Shadow Map) Camera pass: uses the SM An image-space algorithm Pro(优点): no knowledge of scene’s geometry is required Con(缺点): causing self occlusion(自遮挡) and aliasing(走样) issues Pass 1: Render from Light 输出一张光源视角的深度图（Depth Buffer） Pass 2: Render from Eye(Camera) 将光源视角对应的深度转换到View Space, 与Camera视角的深度进行深度比较； 如Depthcam&gt;DepthlightDepth_{cam} &gt; Depth_{light}Depthcam​&gt;Depthlight​ ，那说明该点在阴影中（相机可见，光源不可见） 如Depthcam&lt;DepthlightDepth_{cam} &lt; Depth_{light}Depthcam​&lt;Depthlight​ ，那说明该点在不在阴影中（相机可见，光源可见） 用于比较的深度值： 经过透视投影中的Squeez矩阵后（具体看Games101 Math笔记），z会被推向远平面 Mpersp → ortho =(n0000n0000n+f−nf0010)M_{\\text {persp } \\rightarrow \\text { ortho }}=\\left(\\begin{array}{cccc} n &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; n &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; n+f &amp; -nf \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\end{array}\\right)Mpersp → ortho ​=⎝⎜⎜⎜⎛​n000​0n00​00n+f1​00−nf0​⎠⎟⎟⎟⎞​ 用于比较的DepthDepthDepth 可以是经过MVP中的深度值（即Depth Buffer中的深度值）； 也可以是该点在同一空间（如模型空间）中，该点到相机/光源的线性距离； a.1). Issues in Shadow Mapping a.1.1). Self occlusion(自遮挡) Self occlusion： 阴影自遮挡，造成阴影毛刺的现象； 原因： 如上图， Shadow Map分辨率有限，一个像素内记录的深度值相同。如图中红色和橙色斜线表示Shadow Map中深度相同的位置（DepthA=DepthA′Depth_A = Depth_{A&#x27;}DepthA​=DepthA′​）； 当计算平面中BBB点是否在阴影中时，Depthlight=z1=DepthADepth_{light} = z1 = Depth_ADepthlight​=z1=DepthA​，而相机视角下的点BBB转换到光源视角下对应的深度为 z2z2z2 ，即Depthcam=z2=DepthBDepth_{cam} = z2 = Depth_BDepthcam​=z2=DepthB​ 因此，Depthcam&gt;DepthlightDepth_{cam} &gt; Depth_{light}Depthcam​&gt;Depthlight​ ，说明该点在阴影中，因此造成Self occlusion 解决方法： 引入Bias； 认为对于BBB点，如Depthcam&gt;DepthlightDepth_{cam} &gt; Depth_{light}Depthcam​&gt;Depthlight​，但DepthlightDepth_{light}Depthlight​ 处于橙色中，那该点仍然不在阴影中； 即： Depthcam&gt;Depthlight+biasDepth_{cam} &gt; Depth_{light}+biasDepthcam​&gt;Depthlight​+bias，才使得该点在阴影中； Depthcam&lt;Depthlight+biasDepth_{cam} &lt; Depth_{light}+biasDepthcam​&lt;Depthlight​+bias，该点不在阴影中； 易得，当光源方向垂直于平面时，所需的Bias最小，因此可引入光源与平面法线的夹角 cosαcos\\alphacosα ，来调整Bias大小； 引入bias会造成的问题：Detached shadow(不接触阴影，Peter Panning) a.1.2). Detached shadow ![Detached shadow](Detached shadow.png) 解决方法： Second-depth shadow mapping 工业界实际没什么人用，只是学术界提出的解决方案 a.1.3). Aliasing b). Math b.1). Approximation in RTR RTR中常用的不等式； ![Approximation in RTR](Approximation in RTR.png) 该不等式“准确”的条件： Support（支撑集，积分的范围）足够小时； g(x)g(x)g(x) 足够光滑（指频率低，起伏小） b.2). 渲染方程的不等式 V(p,ωi)V(p,\\omega_i)V(p,ωi​)为Visibility，阴影因子； 单独拆出Visibility，即先做shading，后做Visibility，最后相乘 b.3). in Shadow Mapping 什么情况下，Shadow Mapping（先着色，后计算阴影）是准确的； Small support 在计算阴影中，支撑集小，意味着光源小； 因此，对于点光源和方向光源，做Shadow Mapping硬阴影结果是准确的； Smooth integrand 对于不等式处理后的渲染方程，g(x)g(x)g(x) 代表光照。 当**g(x)g(x)g(x) 足够光滑（指频率低，起伏小）**，不等式为准确的； LiL_iLi​ 光滑，对应光源为面光源； BRDF，即frf_rfr​ 光滑，对应Diffuse项； 即对于光源为面光源的Diffuse项，不等式处理后的渲染方程是准确的； c). PCSS(Percentage-Closer Soft Shadow) c.1). PCF(Percentage Closer Filtering) PCF用于抗锯齿，而不用于软阴影（用于软阴影的叫PCSS，两者实质是一个东西，但应用不同叫法不同） 在生成Shadow Map后，阴影比较时（即对阴影比较的结果），进行Filtering 面光源生成Shadow Map：以面光源的中心点(放置相机)生成shadow map 做法： 不止对着色点与其在Shadow Map中的对应点进行深度比较，而是着色点深度与其在Shadow Map中对应点及其周围点深度进行比较，最后对各个Visibility的结果取平均值（或加权平均） eg1. PPP点在Cam视角下深度为DepthpDepth_pDepthp​，转换到光源视角下深度为Depthp′Depth_{p&#x27;}Depthp′​，Depthp′Depth_{p&#x27;}Depthp′​ 与其在Shadow Map中对应点周围3x3（Filter size）像素进行比较，得到结果1,0,11,0,11,1,0\\begin{array}{l} 1,0,1 \\\\ 1,0,1 \\\\ 1,1,0 \\end{array} 1,0,11,0,11,1,0​ 取平均得到Visibility为 0.667 Filter size Small -&gt; sharper Large -&gt; softer 为选取合适的Filter size，产生了PCSS c.2). PCSS(Percentage-Closer Soft Shadow) c.2.1). 什么是PCSS？ 关键： 自适应Filter size 观察可得： 钢笔（Blocker）与接收平面（Receiver）的距离越小（笔尖），阴影越硬 钢笔（Blocker）与接收平面（Receiver）的距离越大（笔尖），阴影越软 即阴影的软硬程度，一部分取决于Blocker和Receiver的距离 阴影的软硬取决于 wLightw_{Light}wLight​ （光源的宽度） dBlockerd_{Blocker}dBlocker​ 与 dBtoRd_{BtoR}dBtoR​ 的比值； Blocker定义： Shading point变换到Light视角，对应深度为DepthsceneDepth_{scene}Depthscene​ 。查询区域内，深度值z&lt;Depthscenez &lt; Depth_{scene}z&lt;Depthscene​ 的texel即为Blocker； dBlockerd_{Blocker}dBlocker​ 为 Average blocker distance Average blocker distance： Shadow Map一定范围内的Blocker的深度平均值 类似eg1 eg1. PPP点在Cam视角下深度为DepthpDepth_pDepthp​，转换到光源视角下深度为Depthp′Depth_{p&#x27;}Depthp′​，Depthp′Depth_{p&#x27;}Depthp′​ 与其在Shadow Map中对应点周围3x3（Filter size）像素进行比较，得到结果 1,0,11,0,11,1,0\\begin{array}{l} 1,0,1 \\\\ 1,0,1 \\\\ 1,1,0 \\end{array} 1,0,11,0,11,1,0​ 取平均得到Visibility为 0.667 其中，Visibility为0的点，即 处于阴影中，Depthcam&gt;Depthlight+biasDepth_{cam} &gt; Depth_{light}+biasDepthcam​&gt;Depthlight​+bias 的点即为Blocker，对Blocker在Shadow Map中的深度值取平均值，即得到Average blocker distance c.2.2). 做法 首先将shading point点xxx投应到shadow map上,找到其对应的像素点PPP。PCSS算法的实现流程如下： 第一步：Blocker search，即获取某个区域的平均遮挡物深度（在点p附近取一个范围(这个范围是自己定义或动态计算的),将范围内各像素的最小深度与x的实际深度比较,从而判断哪些像素是遮挡物，把所有遮挡物的深度记下来取个平均值作为blocker distance。） 第二步：Penumbra estimation，使用平均遮挡物深度计算滤波核尺寸（用取得的遮挡物深度距离来算在PCF中filtering的范围。） wPenumbra =(dReceiver −dBlocker )⋅wLight /dBlocker w_{\\text {Penumbra }}=\\left(d_{\\text {Receiver }}-d_{\\text {Blocker }}\\right) \\cdot w_{\\text {Light }} / d_{\\text {Blocker }} wPenumbra ​=(dReceiver ​−dBlocker ​)⋅wLight ​/dBlocker ​ 第三步：Percentage Closer Filtering，对应该滤波核尺寸应用PCF算法。 如何动态计算Blocker search的**“某个范围”** Light越远，Region越小；Light越近，Region越大；（好像和图不太对应，如非要对应，就类似与Shadow Map位置不变，Light距离变大/小） 那么PCSS中那些步骤会导致速度变慢？ 第一步：Blocker search，需要多次采样查询深度信息并比较，计算Blocker的平均深度dBlockerd_{Blocker}dBlocker​ 第三步：PCF，阴影越软→滤波核尺寸越大→采样查询次数变多→速度变慢 由此可见，主要是多次采样并比较的方法使得速度变慢； 加速方法： 随机采样，后降噪； 如果觉得区域过大不想对每一个texels都进行比较,就可以通过随机采样其中的texels，而不是全部采样，会得到一个近似的结果,近似的结果就可能会导致出现噪声。工业的处理的方式就是先稀疏采样得到一个有噪声的visibility的图,接着再在图像空间进行降噪。 Variance Soft Shadow Mapping(VSSM) c.2.3). Math V(x)=∑q∈N(p)w(p,q)⋅χ+[DSM(q)−Dscene (x)]V(x)=\\sum_{q \\in \\mathcal{N}(p)} w(p, q) \\cdot \\chi^{+}\\left[D_{\\mathrm{SM}}(q)-D_{\\text {scene }}(x)\\right] V(x)=q∈N(p)∑​w(p,q)⋅χ+[DSM​(q)−Dscene ​(x)] 其中χ+\\chi^{+}χ+ 类似于step()step()step() 函数 DSM(q)−Dscene (x)≥0D_{\\mathrm{SM}}(q)-D_{\\text {scene }}(x) \\geq 0DSM​(q)−Dscene ​(x)≥0， 即DepthShadowMap≥DepthcamDepth_{ShadowMap} \\geq Depth_{cam}DepthShadowMap​≥Depthcam​，χ+[DSM(q)−Dscene (x)]=1\\chi^{+}\\left[D_{\\mathrm{SM}}(q)-D_{\\text {scene }}(x)\\right] = 1χ+[DSM​(q)−Dscene ​(x)]=1 DSM(q)−Dscene (x)&lt;0D_{\\mathrm{SM}}(q)-D_{\\text {scene }}(x) &lt; 0DSM​(q)−Dscene ​(x)&lt;0， 即DepthShadowMap&lt;DepthcamDepth_{ShadowMap} &lt; Depth_{cam}DepthShadowMap​&lt;Depthcam​，χ+[DSM(q)−Dscene (x)]=0\\chi^{+}\\left[D_{\\mathrm{SM}}(q)-D_{\\text {scene }}(x)\\right] = 0χ+[DSM​(q)−Dscene ​(x)]=0 d). Variance Soft Shadow Mapping(VSSM) **vs PCSS: ** Fast blocker search(step 1) and filtering(step 3) 关键思想： 只用知道有多少（百分比）的 texels 在着色点前面； d.1). Solve step3(PCF) 通过正态分布（Normal distribution），求得着色点的深度在采样点中大概的排位，即可得到近似的结果； 需要定义一个正态分布，需要得知其均值（mean）和方差（variance） Mean: Hardware MIPMAPing (快，但不一定准确); Summed Area Tables (SAT, 积分表); Variance: Var(X)=E(X2)−E2(X)Var(X) = E(X^2)-E^2(X)Var(X)=E(X2)−E2(X) ，方差等于平方的均值（均方值）减去均值的平方； 只需要在Depth Buffer的空余通道中多存储一个depth2depth^2depth2； 通过求正态分布P(x&gt;Depthcam)(Depthcam为着色点转换到光源视角的深度)P(x&gt;Depth_{cam}) (Depth_{cam}为着色点转换到光源视角的深度)P(x&gt;Depthcam​)(Depthcam​为着色点转换到光源视角的深度) 的面积，即求CDF（累积分布函数 ）即可求得Visibility CDF(x) 求解： 查表； 切比雪夫不等式； 切比雪夫不等式（并不需要知道具体的分布情况，而是通过不等式直接得出，如使用切比雪夫就不用正态分布，只需要求得均值和方差即可，但是也需要分布情况较为简单） 通过近似值约等出Visibility的结果，即红色面积； （准确的条件：）t≥meant\\geq meant≥mean （但一般不管这个，就理解成约等就行） 至此解决了Step3 d.2). Solve step1 Shading point转换到光源下， 关键式： N1Nzunocc +N2Nzocc=zAvg \\frac{N_{1}}{N} z_{\\text {unocc }}+\\frac{N_{2}}{N} z_{o c c}=z_{\\text {Avg }} NN1​​zunocc ​+NN2​​zocc​=zAvg ​ N1N=P(x&gt;t)\\frac{N_{1}}{N} = P(x&gt;t)NN1​​=P(x&gt;t) ，通过切比雪夫不等式求出； N2N=1−P(x&gt;t)\\frac{N_{2}}{N} = 1-P(x&gt;t)NN2​​=1−P(x&gt;t) zAvgz_{Avg}zAvg​：SM中，采样范围深度均值 zunoccz_{unocc}zunocc​：近似等于ttt 最终，由关键式得出$ z_{o c c}$ d.3). Summed Area Tables (SAT, 积分表) SAT为数据结构，使用前缀和算法 2D的SAT：每一个点记录左上角区域的和； 先计算一行的一维SAT； 再对计算后的SAT进行列方向的累加，求出二维的SAT； 求蓝色区域和只需要查询四次SAT即可； SAT的并行性： 由于先进行行方向SAT计算，后进行列方向SAT计算，具有一定的并行性； d.4). 缺陷 由于使用了切比雪夫不等式或正态分布，隐含了Shadow Map中对应范围的深度分布要较为简单或接近正态分布 如上右图，分布主要集中在三个值，过于离散，造成VSSM不准确； Light leaking（漏光） e). Moment Shadow Mapping(MSM) VSSM不够准确，需要用更高的**矩（Moment）**来描述PCF（Use higher order moments to represent a distribution） 矩（Moments）： Quite a few variations on the definition We use the simplest: x,x2,x3,x4,...x,x^2,x^3,x^4,...x,x2,x3,x4,... VSSM中，我们用到了二阶矩（depth2depth^2depth2） 有点类似于展开（比如泰勒展开）； f). Distance Field Soft Shadow(SDF, 有向距离场) f.1). Distance functions 定义： 对于空间中任意一点，其值为到物体的最近距离。并且可定义其在内部符号（Signed）为负，在外符号为正，即为有向距离场（Signed Distance Functions, SDF）; An Example: Blending (linear interp.) a moving boundary 背后理论： 最优传输（Optimal Transport） SDF性质： 对于刚体，SDF不需要实时计算； nnn个刚体运动，对于一个点PPP ，就有SDF1(P),SDF2(P)......SDFn(P)SDF_1(P), SDF_2(P)......SDF_n(P)SDF1​(P),SDF2​(P)......SDFn​(P)，那该点最后的SDF值即为min(SDF1(P),SDF2(P)......SDFn(P))min(SDF_1(P), SDF_2(P)......SDF_n(P))min(SDF1​(P),SDF2​(P)......SDFn​(P)) 对于形变的物体，SDF需要实时计算； 用途： Ray marching 软阴影 WARNING：不要看到图形就认为SDF是存储一张图形，SDF是三维存储，对于空间中每一个点都有其SDF值 f.1.1). Ray marching 作用：Ray marching(sphere tracing)用来在SDF中射线与物体求交 关键思想： SDF中一点的值，即是该点与周围物体不相交的“安全距离”。如对于点PPP，在周围半径为SDF(P)SDF(P)SDF(P) 的距离内，不与物体相交； 因此，以图为例，求SDF中射线与物体相交只需要依次步进SDF(P)SDF(P)SDF(P) , SDF(A)SDF(A)SDF(A) , SDF(P)SDF(P)SDF(P)，只需要终点的SDF(Last)SDF(Last)SDF(Last) 小于一定值，即该点为交点（或一定次数步进后仍没交点，说明该点无交点） f.1.2). Soft Shadow 作用： 使用SDF来近似表现遮挡百分比（Visibility） 关键思想： SDF中一点的值，即是该点实现不被某一物体遮挡“安全角度” 如着色点PPP看向面光源ABABAB，通过得到射向面光源中点的Ray marching来得到&quot;安全角度&quot;。通过安全角度在总角度中的占比，来近似Visibility Smaller “safe” angle &lt;-&gt; less visibility 安全角度： 缺点： 在shader中涉及反三角函数，开销大； 因此用min⁡{k⋅SDF⁡(p)∣p−o∣,1.0}\\min \\left\\{\\frac{k \\cdot \\operatorname{SDF}(p)}{|p-o|}, 1.0\\right\\} min{∣p−o∣k⋅SDF(p)​,1.0} 来替代，并用 kkk 控制阴影的软硬程度； f.2). Pros and Cons Pros 快（使用角度，不考虑生成） 高质量 Cons 需要预计算 需要额外存储（不仅仅是图形，而是需要三维空间存储） 对于形变物体需要大量实时计算 …","categories":[{"name":"Games202","slug":"Games202","permalink":"http://example.com/categories/Games202/"}],"tags":[]},{"title":"Games202-1 Recap of CG Basics","slug":"Games202_01_Recap of CG Basics","date":"2023-02-01T08:15:10.000Z","updated":"2023-02-03T13:25:22.008Z","comments":true,"path":"2023/02/01/Games202_01_Recap of CG Basics/","link":"","permalink":"http://example.com/2023/02/01/Games202_01_Recap%20of%20CG%20Basics/","excerpt":"","text":"a). Graphics Pipeline b). OpenGL A. Place objects/models Model specification(模型信息) Model transformation B. Set up an easel(画架) View transformation Create /use a framebuffer C. Attach a canvas to the easel 指定Pass到framebuffer，就和Unity中FS的SV_TARGET一样。 E. you can also paint multiple pictures using the same easel 一个Rendering Pass，使用一个framebuffer，渲染一个或多个texture（shading, depth, etc.）作为输出 即一个framebuffer可以绑定多个纹理（MRT） **Multiple Render Target（MRT）**是一种指可以使绘制程序在单帧中同时渲染多个Render Target D. Paint to the canvas This is when vertex / fragment shaders will be used For each vertex in parallel OpenGL calls user-specified vertex shader: Transform vertex (ModelView, Projection), other ops For each primitive, OpenGL rasterizes Generates a fragment for each pixel the fragment covers For each fragment in parallel OpenGL calls user-specified fragment shader: Shading and lighting calculations OpenGL handles z-buffer depth test unless overwritten Summary: in each pass Specify objects, camera, MVP, etc. Specify framebuffer and input/output textures Specify vertex / fragment shaders (When you have everything specified on the GPU) Render c). Shading Language(GLSL) c.1). Initializing Create shader(Vertex and Fragment) Compile shader Attach shader to program Link program Use program ![Shader Initialization Code](Shader Initialization Code.png) c.2). Phong Shader in Assignment 0 Vertex Shader attribute: 顶点附带的属性，FS中不会出现 uniform: 全局变量，由CPU直接传递给GPU varying: 需要插值的变量 highp: 高精度 gl_Position: 类似于Unity的SV_Position，裁剪空间中的顶点位置； Fragment Shader","categories":[{"name":"Games202","slug":"Games202","permalink":"http://example.com/categories/Games202/"}],"tags":[]},{"title":"Games101_19_20 Cameras Lenses and Light Fileds","slug":"Games101_19_20_Cameras_Lenses_LightFileds","date":"2022-10-03T10:25:10.000Z","updated":"2023-02-03T13:41:37.635Z","comments":true,"path":"2022/10/03/Games101_19_20_Cameras_Lenses_LightFileds/","link":"","permalink":"http://example.com/2022/10/03/Games101_19_20_Cameras_Lenses_LightFileds/","excerpt":"","text":"Lecture19 讲相机的，老本行笔记直接看别人的吧； http://t.csdn.cn/4gODC b). Light Field / Lumingraph(光场) 两者看到的光线信息完全相同，那人眼中的世界就完全相同； b.1). The Plenoptic Function(全光函数) 现实世界可以用一个七维的全光函数进行描述，记录了任意时间，不同位置的不同方向接收光的波长 参数： θ\\thetaθ ：方位角 ϕ\\phiϕ：俯仰角 λ\\lambdaλ：波长 ttt：时间 VX，VY,VZV_X，V_Y,V_ZVX​，VY​,VZ​：位置 b.2). Light Field 光场则可以认为是记录了任何一个点所接收的任何一个方向的irradiance。 可用四维函数表示，二维描述位置，二维描述方向 光线可由两个点定义，因此这四维可改写成s,t,u,v。即两个平面上的位置； 由此得出，描述一个物体的光场，只需要记录其包围盒上四维的全光函数即可 从uv平面看向st平面，得到的是这个物体从各个方向看的相应的图像； 而从st看向uv，则得到的是这个物体在这个方向的irradiance的集合（不是合起来，而是类似二维数组的集合）即radiance st到uv 记录不同方向的光线radiance（注意和拜耳阵列的区分，这里三色只是代表不同方向） b.3). Light Field Camera 支持先拍照，后期动态调焦、光圈等 Lecture20","categories":[{"name":"Games101","slug":"Games101","permalink":"http://example.com/categories/Games101/"}],"tags":[]},{"title":"Games101_17_18 Materials","slug":"Games101_17_18_Materials","date":"2022-10-03T10:20:10.000Z","updated":"2023-02-03T13:41:45.995Z","comments":true,"path":"2022/10/03/Games101_17_18_Materials/","link":"","permalink":"http://example.com/2022/10/03/Games101_17_18_Materials/","excerpt":"","text":"Lecture 17 Materials and Appearances Material == BRDF a). Diffuse / Lambertian Material 对于此类材质，当假定各方向9入射的光线radiance相同，反射的光同样是Uniform的。因为能量守恒（假定不发光，不吸收），使得进入的 Irradiance入 和出去的 ***Irradiance出 ***相同； 二重积分 b). Glossy material c). Ideal reflective / refractive material(BSDF) 计算镜面反射方向 几何 方位角 c.1). Specular Refraction ![Specular Refraction](Specular Refraction.png) 现象：色散、Caustic等 Snell’s Law ![Snell Law](Snell Law.png) 可推出只有当光密到光疏介质时，才有可能发生折射；（nint&gt;1{n_i\\over n_t}&gt;1nt​ni​​&gt;1） ![Snell Law_02](Snell Law_02.png) 折射属于BT(Transmit)DF; BTDF + BRDF = BSDF c.2). Fresnel Reflection(菲涅尔) 反应了特定方向的入射光的反射和折射的比例； 左图是绝缘体的菲涅尔项，右图是导体（金属）的菲涅尔项 d). Microfacet Material(微表面材质) 关键： 微表面的**法线分布** d.1). Microfacet BRDF 菲涅尔项； Shadowing-masking term 考虑微表面之间的遮挡和阴影； 当光线几乎平行与表面入射时(Grazing angle)，微表面之间遮挡变多 Disterbution of normals e). Isotropic / Anisotropic Materials (BRDFs) Key: directionality of underlying surface e.1). Anisotropic BRDFs 如尼龙、天鹅绒等 f). Properties of BRDFs(BRDF的性质) 非负性 fr(ωi→ωr)≥0f_{r}\\left(\\omega_{i} \\rightarrow \\omega_{r}\\right) \\geq 0 fr​(ωi​→ωr​)≥0 线性性质 如 高光、漫反射、环境光等的BRDF分开计算最后再求和，和用整体的BRDF和整体的光线一起计算结果相等 可逆性 能量守恒 各向同性时，BRDF可转为三维(两个俯仰角，及方位角之差) Lecture 18 Advanced Topics in Rendering a). Advanced Light Transport a.1). 分类 ![Advanced Light Transport_00](Advanced Light Transport_00.png) Unbiased（无偏）： 无论采样多少次，其数学期望和正确的值相同； 否则，则为biased（有偏） 在某种情况下（如采样数增大），其数学期望逐渐向正确的值收敛，则称为consistent（一致的） a.2). Bidirectional Path Tracing(BDPT) 当使用PT，摄影机出发的光线的第一次Bounce大部分是Diffuse时，其不容易得到光线强的方向的贡献，此时BDPT效率更高（语言待优化） a.3). Metropolis Light Transport(MLT) 通过马尔科夫链 在已有样本周围形成新样本，其得到的PDF的形状与被积函数 f(x)f(x)f(x) 形状一致（此时）方差最小； **优点：**适合复杂、困难的光线传播 如：图一和图二SDS(Specular-Diffuse-Specular) **缺点：**难以估计何时收敛，不知道采样到什么程度才可以没噪声，造成Dirty； a.4). Photon Mapping(光子映射) 做法之一： 光源发射光子，弹射数次后最终停留在Diffuse表面 摄影机发射光子，弹射数次后最终停留在Diffuse表面 局部密度估值（光子密度越大，该点越亮）； 可使用KD-Tree等加速结构 biased会导致模糊 a.5). Vertex Connection Merging(VCM) 使用BDPT后，对于临近的端点使用Photon Mapping 电影常用 a.6). Instant Radiosity(实时辐射度) 出现亮点原因： 计算直接光照时，换元成了dA，而此处换元依赖于，面积A和立体角w的计算，其中分母是距离的平方，如果距离很接近，那么就会除以一个极小值，使得结果变过大 b). Advanced Appearance Modeling b.1). 分类 ![Advanced Appearance Modeling](Advanced Appearance Modeling.png) b.2). Non-surface models b.2.1). Participation media 光在传播过程中，有穿过一个Participation medium，那么它会被吸收、散射 Rendering b.2.2). Hair/Fur Appearance Kajiya_Kay_Model Marschner Model ![Marschner Model](Marschner Model.png) 认为毛发表面类似玻璃柱，其中分为Cuticle（表皮）、Cortex（皮质，吸收光） ![Marschner Model01](Marschner Model01.png) 光经过毛发被分为3项，R、TT、TRT Double Cylinder Model 考虑了髓质（Medulla，散射光线） 光经过毛发被分为5项，R、TT、TRT、TTs、TRTs b.2.3). Granular Material（颗粒材质） ![Granular Material](Granular Material.png) b.3). Surface models b.3.1). Translucent(半透明) Material **概念：**Translucent实际上和半透明有一定区分，它还涉及到吸收、散射（SSS）等现象。Translucent只是表示光从表面一个地方进入，再从表面一个地方射出（如玉石、人的皮肤、水母等）； Subsurface Scattering BSSRDF： 对BRDF的延伸，一点出射方向的贡献不止有该点，还有周围点的贡献（多了对面积的积分） Dipole Approximation（模拟次表面散射的一种方法） 材质下加入一个光源，材质上也加入一个虚拟光源 ![Dipole Approximation](Dipole Approximation.png) b.3.2). Cloth Rendering BRDF 分块，每一块都是Participating Media b.3.3). Detailed Appearance: Motivation ![Detailed Appearance](Detailed Appearance.png) ![Detailed Appearance_Dn](Detailed Appearance_Dn.png) D(h)D(h)D(h) 过于简单，无法模拟细节 ![Detailed Appearance_Dn02](Detailed Appearance_Dn02.png) Result ![Detailed Appearance_Result](Detailed Appearance_Result.png) ![Detailed Appearance_p_NDFs](Detailed Appearance_p_NDFs.png) b.4). Procedural Appearance ![Procedural Appearance](Procedural Appearance.png)","categories":[{"name":"Games101","slug":"Games101","permalink":"http://example.com/categories/Games101/"}],"tags":[]},{"title":"Games101_21_22 Animation","slug":"Games101_21_22_Animation","date":"2022-10-03T10:20:10.000Z","updated":"2023-02-03T13:42:54.858Z","comments":true,"path":"2022/10/03/Games101_21_22_Animation/","link":"","permalink":"http://example.com/2022/10/03/Games101_21_22_Animation/","excerpt":"","text":"Lecture 21 Animation a). History b). Keyframe c). Physical Simualtion c.1). Mass Spring System Idealized spring 但永远不会停止，因此加入摩擦力 中间项为相对速度在向量ababab方向的投影，因为（处于原长状态时）如果a点不动，b点绕a点做圆周运动，那fb=0f_b=0fb​=0； 但是无法表现剪切力（如对角线拉布，布基本形状不变）、弯曲力（out-of-plane，抗拒被像纸一样完全折叠为两个三角形）等 加入两条对角线，以及skip connection 红色较弱，仅其辅助作用；蓝色较强，其主要作用； **其他方式：**FEM (Finite Element Method, 有限元) Instead of Springs，考虑力传导 c.2). Particle System 粒子系统不仅可描述微小粒子，还可以描述一些群落； d). Forward Kinematics(FK) 关节（Joint）分类： e). Inverse Kinematics(IK) 解决多个解的方法：梯度下降 f). Rigging Blend shapes: 混合控制点或骨骼位置 ![Blend Shapes](Blend Shapes.png) g). Motion Capture / Facial Motion Capture Lecture 22 a). Single Particle Simulation Velocity vector field: 给定位置，可以得出改点速度。和磁场、电场类似； Oridinary Differential Equation(ODE, 常微分方程) ![Oridinary Differential Equation](Oridinary Differential Equation.png) 已知解得 t 时刻，粒子的位置和速度，需求得下一时刻的粒子位置； 方法1：显式欧拉法（Explicit Euler method），用差分代替微分，但会引起误差，且稳定性差； a.1). Euler’s Method ![Euler’s Method](Euler’s Method.png) 缺点： 存在误差，可通过减小步长（Δt\\Delta tΔt）来减少误差； ![Euler’s Method_Errors01](Euler’s Method_Errors01.png) 稳定性差，如速度场为同心圆时，不管步长多小都会逐渐偏移（diverge） ![Euler’s Method_Errors02](Euler’s Method_Errors02.png) a.2). Combating Instability ![Combating Instability](Combating Instability.png) a.2.1). Midpoint Method ![Midpoint Method](Midpoint Method.png) 计算下一时刻位置后取中点，得到中点速度，在计算下一时刻位置时，使用中点速度 ![Midpoint Method02](Midpoint Method02.png) a.2.2). Adaptive Step Size a.2.3). Implicit Euler Method ![Implicit Euler Method](Implicit Euler Method.png) 使用下一时刻的速度和加速度，并求解 、 龙格库塔 a.2.4). Position-Based / Verlet Integration 非基于物理 时间快 b). Rigid Body Simulation 与单粒子类似 c). Fluid Simulation c.1). A Simple Position-Based Method c.2). Eulerian vs. Lagrangian ![Eulerian vs. Lagrangian](Eulerian vs. Lagrangian.png) 拉格朗日（质点法）：考虑单个粒子的运动 欧拉（网格法）：考虑不同位置的网格 Material Point Method (MPM ，混合上两种方法)","categories":[{"name":"Games101","slug":"Games101","permalink":"http://example.com/categories/Games101/"}],"tags":[]},{"title":"Games101-13-16 RayTracing","slug":"Games101_13_16_RayTracing","date":"2022-10-03T10:15:10.000Z","updated":"2023-02-03T13:51:07.619Z","comments":true,"path":"2022/10/03/Games101_13_16_RayTracing/","link":"","permalink":"http://example.com/2022/10/03/Games101_13_16_RayTracing/","excerpt":"","text":"Lecture 13 Ray Tracing a). vs. Rasterization 光栅化难以表现**全局（global）**效果，如 （软）阴影（Soft shadows） 光线反弹超过一次（Glossy reflection） Indirect illumination（间接光照） Rasterization is fast, but quality is relatively low； b.). Basic Ray-Tracing Algorithm 光追中光线的性质： 光是沿直线传播的； 光相交时，并不产生干扰； 光从光源出发，传播到眼睛（由于光路可逆，也可是光线从眼睛出发，传播到光源） b.1). Ray Casting 做法： Generate an image by casting one ray per pixel;（生成从眼睛出发的光线） Check for shadows by sending a ray to the light;（检查光线投射点是否可传播到光源） 光线由眼睛出发，可不再使用深度缓存； 投射点到光源发射Shadow Ray，查看该点是否在阴影里（是否对光源可见）； c). Whitted-Style Ray Tracing(Recursive, 递归) 过程： 生成眼睛到像素a的光线（Primary ray），打到第一个与光线相交的点； 形成反射（镜面反射）和折射的光线（Secondary rays，之后的都是Secondary rays）； 对每条光线与object的交点做到光源的光线（Shadow rays）； 将所有Shadow rays未被阻挡的光线的着色结果相加，即为像素a的着色结果； c.1). Ray-Surface Intersection（求交点） c.1.1). 与球形相交： **推广：**与隐式表面相交 c.1.2). 与三角形求交： **几何上：**判断内外； 空间内任意一点为起点做一光线，若该光线与object（封闭）交点数为奇数，则该点在object内；若交点数为奇数，则该点在object外；（缠绕数的奇-偶原则） 计算过程： 即 r(t)=o+td,0≤t&lt;∞r(t)=o+td,0\\leq t &lt; \\inftyr(t)=o+td,0≤t&lt;∞ 和 (p−p′)⋅N=0(p-p&#x27;)·N=0(p−p′)⋅N=0 联立求 ttt； 之后求得点P是否在三角形内； Möller Trumbore Algorithm 按传统求解，求出 ttt 后，还需要判断 P 点是否在三角形内，较为繁琐，因此提出Möller Trumbore Algorithm 射线r(t)=O+tDr(t)=O+tDr(t)=O+tD ，与由重心坐标表示的三角形上的点 PPP 求解（三个式子，三个未知量，根据克拉默必定有解）； 求得交点后，可通过重心坐标得知该点是否在三角形外； c.2). Acclerating Ray-Surface Intersection **原因：**当需要求得光线最近的交点时，需要遍历场景所有三角面，速度慢，需要加速； c.2.1). Axis-Aligned Bounding Box(AABB，轴对齐包围盒) Bounding Volumes 思想：当物体不与包围体积相交时，更不可能和物体相交； Bounding Box（AABB for example）： **理解：**盒子是3对对立的面的交集； Axis-Aligned Bounding Box(AABB) AABB包围盒的面总在xy/xz/yz平面； 光线与AABB求交： 2D情况下（3D同理） 思想： 光线进入Box：只有当光线进入所有的对立面； 光线出Box：只要光线出射一个对立面； 对于3D的Box，tenter=max{tmin},texit=min{tmax}t_{enter}=max\\{t_{min}\\},t_{exit}=min\\{t_{max}\\}tenter​=max{tmin​},texit​=min{tmax​}； 如果 tenter&lt;texitt_{enter}&lt;t_{exit}tenter​&lt;texit​，则光线经过Box； 对于 tentert_{enter}tenter​ 和 texitt_{exit}texit​ 正负情况的考虑： texit&lt;0t_{exit}&lt;0texit​&lt;0：不相交（Box在光线后边） texit&lt;0t_{exit}&lt;0texit​&lt;0 and tenter&lt;0t_{enter}&lt;0tenter​&lt;0：光线起点在盒子里，一定相交 当且仅当 tenter&lt;texit&amp;&amp;texit≥0t_{enter}&lt;t_{exit}\\quad\\&amp;\\&amp;\\quad t_{exit}\\geq0tenter​&lt;texit​&amp;&amp;texit​≥0，光线与AABB相交； 为什么使用AABB：求交方便； Lecture 14&amp;15 Ray Tracing(Acceleration &amp; Radiometry; Light Transport &amp; Global Illumination) a). Uniform Spatial Partitions（统一空间分区） Heuristic: #cells = C * #objs C ≈ 27 in 3D 缺陷： 格子大小相同，浪费空间； 对于空间分布不均匀的场景容易造成“Teapot in a stadium” problem，浪费性能； b). Spatial Partition 常见的空间划分的类型： Oct-Tree（3维中是八叉树，2维中是四叉树；2n2^n2n叉树，n=维度） 受维度影响； KD-Tree； 每次只划分一次，如果是三维则按x，y，z方向循环划分； BSP-Tree b.1). KD-Tree **预处理：**对空间进行划分，对于子空间每次只划分一次（1、2、3划分省略）； 树节点（Internal node）的数据结构： **划分轴：**x-, y- , or z-axis; 划分位置：分割平面沿轴的坐标；（？） 子节点； 不存储object； 叶子节点数据结构： object的列表 过程： 光线和叶子节点1（为方便把111暂看作叶子节点，尽管个节点应该继续划分，2,32,32,3同理）相交，判断光线和111中储存的object是否相交（无相加，继续）； … 光线和叶子节点3相交，判断光线和111中储存的object是否相交，相交，记录thitt_{hit}thit​； 缺点： 预处理的过程中，物体（三角形）和网格求交难； 如三角形和Box求交，有可能是一个小Box穿过三角形（被三角形“包裹”） 同一个Object可能储存在多个叶子节点中； c). Bounding Volume Hierarchy (BVH) **特征：**先将object分为两组，再重新计算包围盒，使得同一个obejct只会在一个叶子节点中出现；（但会造成Bounding Box空间的冗余） 过程： 找到包围盒； 递归地将物体的集分为两个子集； 重新计算子集的包围盒； 满足条件时停止； 储存objects到对应的叶子节点； 划分子节点： 选择一个维度去划分； Heuristic #1: 选择最长的轴去划分； Heuristic #2: 选择中间的object的位置去划分；（快速选择算法） BVHs的数据结构： 非叶子节点： Bounding box Children: pointer to child nodes 叶子节点： Bounding box List of objects Nodes represent subset of primitives in scene BVH Traversal: 空间划分和物体划分: d). Radiometry d.1). Radiant Energy and Flux(Power) Radiant Energy(辐射能量): Definition: Radiant energy is the energy of electromagnetic radiation. It is measured in units of joules, and denoted by the symbol: Q[J=Joule]Q[J=Joule] Q[J=Joule] Flux(辐射通量): Definition: Radiant flux (power) is the energy emitted, reflected, transmitted or received, per unit time. Φ≡dQ dt[ W=Watt][lm⁡=lumen]\\Phi \\equiv \\frac{\\mathrm{d} Q}{\\mathrm{~d} t}[\\mathrm{~W}=\\mathrm{Watt}][\\operatorname{lm}=\\text {lumen}] Φ≡ dtdQ​[ W=Watt][lm=lumen] Important Light Measurements of Interest d.2). Radiant Intensity(辐射强度) 定义：单位立体角上，产生的、反射的、接收的辐射通量。符号：I；单位：瓦特/sr、lm/sr、candela、cd。 立体角(solid angle)是有方向的，所以辐射强度是一个方向有关的属性 d.2.1). Solid angle 角度（2D）： 弧长除以半径； θ=lr\\theta={l\\over r}θ=rl​ **立体角：**立体角面积除以半径的平方 Ω=Ar2\\Omega=\\frac{A}{r^{2}}Ω=r2A​ 球体的立体角为4π4\\pi4π d.2.2). 计算过程 立体角微分： 二重积分计算，总的立体角 = 球面上无数个单位立体角的加和，即∫∫sinθdθdφ 积分限也比较好理解：θ：0 → π，一个半圆弧， φ：0 → 2π，用半圆转一整圈得到球面 通常把ω当做方向向量来理解，这样比较好描述intensity 如果点光源向三维空间中均匀的辐射出能量，怎么描述强度？ I = Φ / 4π Φ：点光源单位时间内，向三维空间中辐射出的能量 4π：整个三维空间的总立体角 其比值就是单位立体角上的辐射通量 d.2.3). Irradiance(辐照度) **定义：**每单位面积（与光线垂直，Lambert’s Cosine Law）的能量 Lambert’s Cosine Law e.g. 太阳高度角造成四季变化 随半径变大，Irradiacne变小，而radiant intensity不变； d.2.4). Radiance(辐亮度) 介绍： Radiance是和光线有关的量； 渲染就是在计算radiance； 单位：The radiance(luminance) is the power emitted. reflected, transmitted or receivedd by a surface, per unit solid angle, per projected unit area. 理解： Radiance定义：power per unit solid angle, per projected unit area. Irradiance: power per projected unit area Intensity: power per solid angle So: Radiance: Irradiance per solid angle ​ - Incident Radiance Radiance: Intensity per projected unit area ​ - Exiting Radiance **Incident Radiance: **The irradiance per unit solid angle arriving at the surface 即 ω\\omegaω 方向的光线对于 dAdAdA 的贡献； **Exiting Radiance: **The intensity per unit projected area leaving the surface 即面积光 dAdAdA ，对 ω\\omegaω 出射方向的贡献； Irradiance vs. Radiance Irradiance和Radiance的区别在于方向性； 图中，dAdAdA 的辐照度 E(p)E(p)E(p) 为各方向（半圆）对 dAdAdA 的贡献。dAdAdA 的Radiance Li(p,w)L_i(p,w)Li​(p,w) 为入射方向 dωd\\omegadω 对 dAdAdA 的贡献； 即，Irradiance E(p)E(p)E(p) 是 radiance Li(p,w)L_i(p,w)Li​(p,w) 对于各个立体角的积分，Li(p,ω)L_i(p,\\omega)Li​(p,ω) 是 E(p)E(p)E(p) 方向 ω\\omegaω 的积分； c). BRDF(Bidirectional Reflectance Distribution Function) Ver Games101 **过程：**光线照射到一点（ppp），该点吸收能量，再辐射出去； 定义： 分母：ωi{\\omega}_iωi​ 方向入射的radiance Li(x,ωi)L_i(x,{\\omega}_i)Li​(x,ωi​)，被一点吸收后，辐射往各个方向的Irradiance Ei(ωi)E_i({\\omega}_i)Ei​(ωi​)； 分子：Ei(ωi)E_i({\\omega}_i)Ei​(ωi​)，对 ωr{\\omega}_rωr​ 方向radiance的贡献 Lr(x,ωr)L_r(x,{\\omega}_r)Lr​(x,ωr​) Ver self: **定义：**BRDF（双向反射分布函数, bidirectional reflective distribution function）， 是指当一束光从某个方向( l⃗\\vec ll )照射到某个点(ppp)上时，在某个方向上( v⃗\\vec vv )的出射辐射通量占总的入射辐射通量的比例 基于物理着色：BRDF - Maple的文章 - 知乎 关于brdf的两件小事 - Dua的文章 - 知乎 可以理解对于某一微小（对立体角）出射光线ωi，某一微小入射光线ωj对其radiance的贡献； 也可以理解成某一微小入射光线ωj，弹射到某一方向的微小立体角ωi的光线强度的比值； 由于为了方便测量，不定义为radiance相除（即如果按照我们一开始对入射方向 微分的方式定义brdf，那么科学家们只需要使用一个极小的光源从 方向入射到点p，就可以测得brdf的值。但是如果定义为radiance相除，就很难输入一个填充立体角刚好等于1的光源。)正常单位为： 1sr{1\\over{sr}} sr1​ d). Rendering equation d.1). 简介 The Reflection Equation fr(p,wi,wr)f_r(p,w_i,w_r)fr​(p,wi​,wr​) 为该点的BRDF 问题： incoming radiance 不止来源于光源，也来源于其他反射（递归）； 未考虑自发光情况（加入自发光项，变为渲染方程） The Rendering Equation 加入了自发光项 Le(p,ωo)L_e(p,{\\omega}_o)Le​(p,ωo​) 考虑多次反射 **注意：该方程假定所有方向都是朝外**的； H2H^2H2 和 Ω\\OmegaΩ 表示半球的积分域； d.2). 理解 Reflection Equation: 反射的Radiance是各个方向光源对出射方向Radiance贡献的积分； 未考虑光线多次弹射 Rendering Equation: 考虑多次弹射，即其他物体反射的光线也会对出射方向 ωr{\\omega}_rωr​ 的Radiance做出贡献； 对于渲染方程，只有 Lr(x,ωr)L_r(x,{\\omega}_r)Lr​(x,ωr​) 和 Lr(x′,−ωi)L_r(x&#x27;,-{\\omega}_i)Lr​(x′,−ωi​) 是未知的； 简化渲染方程： Rendering Equation as Integral Equation Linear Operator Equation EEE 环境中自发光对应向量，LLL Radiance对应的向量； KKK 反射算子（矩阵） 对于Rendering Equation的线性形式，我们可以用以下式子逼近（类似泰勒展开）： Rendering Equation的线性形式对于光追的启示： EEE 为自发光，KEKEKE 为 直接光照（即弹射一次），K2EK^2EK2E 为间接光照（弹射两次） 全局光照（Global illumination, GI）：直接光照+间接光照 基础的光栅化只做了自发光和直接光照，即 EEE 和 KEKEKE 对比 上方玻璃灯：两次弹射时，光线从摄影机出发不能从玻璃罩中射出，因此其为黑色。而四次弹射时，光线从摄影机出发可以从玻璃罩中射出； 当bounce数目增大时，亮度会趋于一个值，而不会无限增大； e). Probability Lecture 16 Ray Tracing 4 (Monte Carlo Path Tracing) a). Monte Carlo Integration 使用原因：一些函数过于复杂，因此对于特定积分域，不求不定积分，只求其积分的结果。（一种数值方法） **过程：**对函数的随机样本进行平均来估计函数的数值； 除以 p(xi)p(x_i)p(xi​) 是一种加权，因为对于积分域上样本的采样可能是不均匀随机采样 均匀采样的情况： Some notes： 采样越多，方差越小 如在xxx上积分，要采样xxx b). Paht Tracing b.1). vs Whitted-Style Ray Tracing Whitted-Style Ray Tracing 遇到光滑物体会只会 反射/折射（择一进行） 无法表现Glossy reflection 遇到漫反射物体停止弹射 没有Color Blooding(eg.direct illumination)，考虑不到漫反射物体之间的光线传播 But the rendering equation is correct Lo(p,ωo)=Le(p,ωo)+∫Ω+Li(p,ωi)fr(p,ωi,ωo)(n⋅ωi)dωiL_{o}\\left(p, \\omega_{o}\\right)=L_{e}\\left(p, \\omega_{o}\\right)+\\int_{\\Omega^{+}} L_{i}\\left(p, \\omega_{i}\\right) f_{r}\\left(p, \\omega_{i}, \\omega_{o}\\right)\\left(n \\cdot \\omega_{i}\\right) \\mathrm{d} \\omega_{i} Lo​(p,ωo​)=Le​(p,ωo​)+∫Ω+​Li​(p,ωi​)fr​(p,ωi​,ωo​)(n⋅ωi​)dωi​ 需要做的： 解决半球域的定积分 蒙特卡洛积分 递归 b.2). A Simple Monte Carlo Solution(Direct illumination) 渲染一个Pixel（Point），当前 之考虑直接光照 当 ωi\\omega_iωi​ 与light相交时，计算该方向的radiance；与Box相交时，则该方向的radiance=0； P-Code b.3). Global illumination(加入递归) b.3.1). GI and problems P-Code Problem1: Explosion of #rays as #bounces go up 解决方法： N=1（N=1即Path Tracing，Distributed Ray Tracing if N != 1） N=1会造成较多的Noise，因此采用Subpixel，即每个像素内多次采样（Samples per pixel, SPP） Problem2: 递归不会停止 现实世界中，光线的弹射次数是无限的 简单地，减少弹射次数 == 减少能量； 解决方法： Russian Roulette(RR, 俄罗斯轮盘赌) b.3.2). Russian Roulette(RR, 俄罗斯轮盘赌) 先前一点的着色结果是 LoL_oLo​，引入RR后 With probability PPP, shoot a ray and return the shading result divided by P: Lo / P With probability 1−P1-P1−P, don’t shoot a ray and you’ll get 0 由此可得出数学期望 E=P⋅(Lop)+(1−P)⋅0=LoE=P \\cdot\\left(\\frac{L_{o}}{p}\\right)+(1-P) \\cdot 0=L_{o}E=P⋅(pLo​​)+(1−P)⋅0=Lo​ b.3.3). 优化 计算直接光照时，如对点P向各个方向均匀采样，当光源小时，直接光照的贡献会小，造成较多的噪声； 解决方法： 换元，使渲染方程对光源面积 AAA 进行积分，pdf = 1/A dω=dAcos⁡θ′∥x′−x∥2(Note:θ′,notθ)d \\omega=\\frac{d A \\cos \\theta^{\\prime}}{\\left\\|x^{\\prime}-x\\right\\|^{2}} (Note: \\theta^{\\prime} , not \\theta ) dω=∥x′−x∥2dAcosθ′​(Note:θ′,notθ) 立体角可以看前面辐射度量学的部分 过程：（直接光照，间接光照分开计算） light source (direct, no need to have RR) other reflectors (indirect, ues RR) P-Code（未考虑遮挡） 遮挡 附上上学期做的光追（借鉴smallpt）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531/*** 采用Monte Carlo Path Tracing* 漫反射采用的是Lambert* 定义了三角面片和球体，其中三角面片可多片合成一个对象，* 与三角面片求交则使用克拉默法则，而基于此做条件上的修改就可构建平行四边形，因此将平行四边形也归入三角面片* 用平行四边形代替两个三角面片在适用且数量较多的情况下可显著提高运算效率* 球体求交运算量小于三角面片，因此墙壁通过大半径的球体构建** 由于想要表现出计算过程，许多数学运算未化简，运算效率不高* 由于未使用BVH等方式约束，三角面片较为影响性能* 目前场景除墙面外中有两个球体（镜面反射以及玻璃），以及一个立方体，通过6个三角面片（平行四边形）构成** 由于为了提高运算效率，本程序中使用的蒙特卡洛采样方向约束在朝向其他对象的方向（射线在必定与其他对象相交的范围内随机），* 但三角面片的约束范围较复杂，因此不支持将三角面片定义为光源** 虽会增加噪声，为了运算效率，除了最大迭代次数，还引入经处理可使radiance的数学期望与原值相同的Russian Roulette，开始RR的次数为最大迭代次数除以2* * 由于运算量大，采样默认设置为1，如想提高运行效率可删除掉三角面片* * 绘制通过glut* 程序输出为ppm格式图片**/#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;gl/glut.h&gt;#define DEPTH_MAX 10 //最大迭代次数#define WIDTH 512#define HIGHT 385double M_PI = 3.1415926535;double erand48(unsigned short xsubi[3]) &#123; return (double)rand() / (double)RAND_MAX;&#125;struct Vec &#123; double x, y, z; Vec(double _x = 0, double _y = 0, double _z = 0) &#123; x = _x; y = _y; z = _z; &#125;; Vec operator+(const Vec&amp; b) const &#123; return Vec(x + b.x, y + b.y, z + b.z); &#125;; //加 Vec operator-(const Vec&amp; b) const &#123; return Vec(x - b.x, y - b.y, z - b.z); &#125; //减 Vec operator*(double b) const &#123; return Vec(x * b, y * b, z * b); &#125;; //数乘 Vec mult(const Vec&amp; b) const &#123; return Vec(x * b.x, y * b.y, z * b.z); &#125; //数乘 Vec&amp; norm() &#123; return *this = *this * (1 / sqrt(x * x + y * y + z * z)); &#125; //单位向量 double dot(const Vec&amp; b) const &#123; return x * b.x + y * b.y + z * b.z; &#125; //点乘 Vec cross(const Vec&amp; b) const &#123; return Vec(y * b.z - z * b.y, z * b.x - x * b.z, x * b.y - y * b.x); &#125; //叉乘&#125;;struct Ray &#123; Vec o, d; Ray(Vec _o, Vec _d) : o(_o), d(_d) &#123;&#125;;&#125;;enum Refl_t &#123; //反射类型 DIFF, SPEC, REFR&#125;;struct MeshTriangle &#123; // 三角面片 const Vec* verts; // 顶点 const int* vertsIndex; //顶点排序 const int numTris; // 三角形数量 Vec* vertices; Vec e, c; // emission, color Refl_t refl; int isTriangle; //顶点， 顶点列表（决定构建顺序以及法线正负）， 三角面片数量， emission, color， 材质， 是否是三角形（或平行四边形） MeshTriangle(const Vec* _verts, const int* _vertsIndex, const int _numTris, Vec _e, Vec _c, Refl_t _refl, int _isTriangle = 1) : verts(_verts), vertsIndex(_vertsIndex), numTris(_numTris), e(_e), c(_c), refl(_refl), isTriangle(_isTriangle) &#123; vertices = new Vec[3 * numTris]; for (int i = 0; i &lt; numTris; i++) &#123; for (int n = 0; n &lt; 3; n++) &#123; vertices[3 * i + n] = verts[vertsIndex[3 * i + n]]; &#125; &#125; &#125; void move(int x, int y, int z) &#123; // 方便调试 for (int i = 0; i &lt; 3 * numTris; i++) &#123; vertices[i] = vertices[i] + Vec(x, y, z); &#125; &#125; double intersect(const Ray&amp; r, Vec&amp; n) const &#123; // n返回法线 double tnear = 1e20; double tnear_out; //std::cout &lt;&lt; numTris &lt;&lt; std::endl; // Vec temp_normal; double temp = 1e20; bool flag = false; for (int i = 0; i &lt; numTris; i++) &#123; Vec&amp; v0 = vertices[3 * i]; Vec&amp; v1 = vertices[3 * i + 1]; Vec&amp; v2 = vertices[3 * i + 2]; /*std::cout &lt;&lt; &quot;x:&quot; &lt;&lt; v0.x &lt;&lt; &quot;y:&quot; &lt;&lt; v0.y &lt;&lt; &quot;, z:&quot; &lt;&lt; v0.z &lt;&lt; std::endl; std::cout &lt;&lt; &quot;x:&quot; &lt;&lt; v1.x &lt;&lt; &quot;y:&quot; &lt;&lt; v1.y &lt;&lt; &quot;, z:&quot; &lt;&lt; v1.z &lt;&lt; std::endl; std::cout &lt;&lt; &quot;x:&quot; &lt;&lt; v2.x &lt;&lt; &quot;y:&quot; &lt;&lt; v2.y &lt;&lt; &quot;, z:&quot; &lt;&lt; v2.z &lt;&lt; std::endl;*/ Vec E1 = v1 - v0; Vec E2 = v2 - v0; n = E1.cross(E2).norm(); //三角形法线 Vec S = r.o - v0; Vec S1 = (r.d).cross(E2); Vec S2 = S.cross(E1); //tnear为时间 沿着三角形方向 t的为正 //u,v 为重心坐标前的参数 都得为非负的还得小于1 double S1E1 = S1.dot(E1); tnear = 1.0f / S1E1 * S2.dot(E2); double u = 1.0f / S1E1 * S1.dot(S); double v = 1.0f / S1E1 * S2.dot(r.d); double k = 1 - u - v; bool judge; if (isTriangle) &#123; judge = tnear &gt; 0 &amp;&amp; v &gt;= 0 &amp;&amp; v &lt;= 1 &amp;&amp; u &gt;= 0 &amp;&amp; u &lt;= 1 &amp;&amp; k &gt;= 0; &#125; else &#123; judge = tnear &gt; 0 &amp;&amp; v &gt;= 0 &amp;&amp; v &lt;= 1 &amp;&amp; u &gt;= 0 &amp;&amp; u &lt;= 1; &#125; if (judge) &#123; //不加k &gt;= 0 可构建平行四边形 if (!flag) &#123; tnear_out = tnear; temp_normal = n; flag = true; &#125; if (tnear &lt; tnear_out) &#123; tnear_out = tnear; temp_normal = n; &#125; &#125; &#125; if (flag) &#123; n = temp_normal; //std::cout &lt;&lt; tnear_out &lt;&lt; std::endl; return (tnear_out &lt; 1e20 &amp;&amp; tnear_out &gt; 0) ? tnear_out : 0; &#125; else &#123; return 0; &#125; &#125; ~MeshTriangle() &#123; delete[] vertices; &#125;&#125;;struct Sphere &#123; double rad; // radius Vec p, e, c; // position, emission, color Refl_t refl; Sphere(double _rad, Vec _p, Vec _e, Vec _c, Refl_t _refl) : rad(_rad), p(_p), e(_e), c(_c), refl(_refl) &#123;&#125; double intersect(const Ray&amp; r) const &#123; Vec op = p - r.o; double t, eps = 1e-4; double b_12 = op.dot(r.d); // -b / 2 double det_14 = b_12 * b_12 - op.dot(op) + rad * rad; // det / 4 double det_14_sqrt = sqrt(det_14); return (t = b_12 - det_14_sqrt) &gt; eps ? t : ((t = b_12 + det_14_sqrt) &gt; eps ? t : 0); //if (det_14 &lt; 0) &#123; // return 0; //&#125; //else &#123; // t = b_12 - det_14_sqrt; // if (t &gt; eps) return t; //考虑到浮点数的缺陷 // t = b_12 + det_14_sqrt; // if (t &gt; eps) return t; // return 0; //交点为反向延长线，不考虑 //&#125; &#125;&#125;;Sphere spheres[] = &#123;//Scene: radius, position, emission, color, material Sphere(1e5, Vec(1e5 + 1,40.8,81.6), Vec(),Vec(.75,.25,.25),DIFF),//Left Sphere(1e5, Vec(-1e5 + 99,40.8,81.6),Vec(),Vec(.25,.25,.75),DIFF),//Rght Sphere(1e5, Vec(50,40.8, 1e5), Vec(),Vec(.75,.75,.75),DIFF),//Back Sphere(1e5, Vec(50,40.8,-1e5 + 170), Vec(),Vec(.25,.25,.25), DIFF),//Frnt Sphere(1e5, Vec(50, 1e5, 81.6), Vec(),Vec(.75,.75,.75),DIFF),//Botm Sphere(1e5, Vec(50,-1e5 + 81.6,81.6),Vec(),Vec(.75,.75,.75),DIFF),//Top Sphere(12,Vec(27,12.5,47), Vec(),Vec(1,1,1) * .999, SPEC),//Mirr Sphere(16.5,Vec(73,16.5,78), Vec(),Vec(1,1,1) * .999, REFR),//Glas Sphere(1.5, Vec(50,81.6 - 16.5,81.6),Vec(4,4,4) * 100, Vec(), DIFF) //Lite&#125;;Vec verts[8] = &#123; //vertices Vec(26, 0, 95), Vec(41, 0, 90), Vec(31, 0, 110), Vec(46, 0, 105), Vec(26, 40, 95), Vec(41, 40, 90), Vec(31, 40, 110), Vec(46, 40, 105),&#125;;int vertsIndex[18] = &#123; 0, 4, 1, // 顺序影响法线方向 1, 5, 3, 3, 7, 2, 2, 6, 0, 6, 7, 4, 2, 0, 3,&#125;;//int vertsIndex[36] = &#123; 0, 4, 1, // 顺序影响法线方向// 1, 4, 5,// 1, 5, 7,// 1, 7, 3,// 3, 7, 6,// 3, 6, 2,// 2, 6, 0,// 0, 6, 4,// 6, 7, 4,// 7, 5, 4,// 2, 0, 3,// 3, 0, 1,// &#125;;MeshTriangle meshTriangles[] = &#123; MeshTriangle(verts, vertsIndex, 6, Vec(), Vec(.25, .75, .25), DIFF, 0),&#125;; //vertices, vertsIndex, numTris, emission, color, materialint numSphere = sizeof(spheres) / sizeof(Sphere);int numMeshTriangle = sizeof(meshTriangles) / sizeof(MeshTriangle);inline double clamp01(double x) &#123; //截断到01 return x &lt; 0 ? 0 : (x &gt; 1 ? 1 : x);&#125;inline double gamma(double x, float n = 2.2) &#123; return pow(clamp01(x), 1 / n);&#125;inline int toInt255(double x) &#123; //gamma取2.2, 四舍五入 return int(gamma(x) * 255 + .5);&#125;inline void UpdateProgress(float progress) //进度提醒&#123; int barWidth = 70; std::cout &lt;&lt; &quot;[&quot;; int pos = barWidth * progress; for (int i = 0; i &lt; barWidth; ++i) &#123; if (i &lt; pos) std::cout &lt;&lt; &quot;=&quot;; else if (i == pos) std::cout &lt;&lt; &quot;&gt;&quot;; else std::cout &lt;&lt; &quot; &quot;; &#125; //三位小数 std::cout &lt;&lt; &quot;] &quot; &lt;&lt; std::setiosflags(std::ios::fixed) &lt;&lt; std::setiosflags(std::ios::right) &lt;&lt; std::setprecision(3) &lt;&lt; float(progress * 100.0) &lt;&lt; &quot; %\\r&quot;; std::cout.flush();&#125;inline bool intersect(const Ray&amp; r, double&amp; t, int&amp; id, Vec&amp; normal) &#123; //t最短的相交, n 返回法线 double n = sizeof(spheres) / sizeof(Sphere) + numMeshTriangle; double d; double inf = t = 1e20; for (int i = 0; i &lt; n; i++) &#123; //std::cout &lt;&lt; i &lt;&lt; std::endl; // if (i &lt; numSphere) &#123; if ((d = spheres[i].intersect(r)) &amp;&amp; d &lt; t) &#123; // 注意：不自交（真坑啊。。。） t = d; id = i; &#125; &#125; else &#123; d = meshTriangles[i - numSphere].intersect(r, normal); if (d &amp;&amp; d &lt; t) &#123; //std::cout &lt;&lt; d &lt;&lt; std::endl; t = d; id = i; &#125; &#125; &#125; return t &lt; inf;&#125;//Xi:随机种子 E：whether to include emissive colorVec radiance(const Ray&amp; r, int depth, unsigned short* Xi, int E = 1) &#123; double t; //与交点距离 int id = 0; Vec temp_n; if (!intersect(r, t, id, temp_n)) &#123; //id &gt;= numSphere说明是三角面片 return Vec(); //miss &#125; //std::cout &lt;&lt; id &lt;&lt; std::endl; // Vec x = r.o + r.d * t;// Ray hit point Vec n; //normal(射线经过obj内部后,n为负数) Vec f; Refl_t obj_refl; Vec obj_e; if (id &lt; numSphere) &#123; const Sphere&amp; obj = spheres[id]; n = (x - obj.p).norm(); f = obj.c; obj_refl = obj.refl; obj_e = obj.e; &#125; else &#123; //std::cout &lt;&lt; id &lt;&lt; std::endl; //if (x.x == 36) std::cout &lt;&lt; &quot;x:&quot; &lt;&lt; x.x &lt;&lt; &quot;y:&quot; &lt;&lt; x.y &lt;&lt; &quot;, z:&quot; &lt;&lt; x.z &lt;&lt; std::endl; const MeshTriangle&amp; obj = meshTriangles[id - numSphere]; n = temp_n.norm(); f = obj.c; obj_refl = obj.refl; obj_e = obj.e; &#125; if (depth &gt; DEPTH_MAX) &#123; return Vec(); &#125; //Vec n = (x - obj.p).norm(); // sphere normal(射线经过obj内部后,n为负数) Vec n_real = n.dot(r.d) &lt; 0 ? n : n * -1; //sphere normal //std::cout &lt;&lt; &quot;x:&quot; &lt;&lt; f.x &lt;&lt; &quot;y:&quot; &lt;&lt; f.y &lt;&lt; &quot;, z:&quot; &lt;&lt; f.z &lt;&lt; std::endl; // //用rgb最大值作为Russian Roulette不终止的概率p //RR适用因为p * Li * (1/p) + 0 * (1-p) = Li，即数学期望等于Li double p = f.x &gt; f.y &amp;&amp; f.x &gt; f.z ? f.x : f.y &gt; f.z ? f.y : f.z; if (++depth &gt; int(DEPTH_MAX / 2) || !p) if (erand48(Xi) &lt; p) f = f * (1.0 / p); else return obj_e * E; //std::cout &lt;&lt; &quot;miss&quot; &lt;&lt; std::endl; if (obj_refl == DIFF) &#123; //std::cout &lt;&lt; &quot;DIFF&quot; &lt;&lt; std::endl; // //采用Lambert，出射方向任意，以极坐标的方式构建随机弹射光线方向 double r1 = 2 * M_PI * erand48(Xi); double r2 = erand48(Xi); double r2_sqrt = sqrt(r2); //标准正交系 Vec w = n_real; Vec u = ((fabs(w.x) &gt; 0.1 ? Vec(0, 1) : Vec(1)).cross(w)).norm(); Vec v = w.cross(u); Vec d = (u * cos(r1) * r2_sqrt + v * sin(r1) * r2_sqrt + w * sqrt(1 - r2)).norm(); //Ray direction, 即path tracing， N=1的那条射线 Vec e; for (int i = 0; i &lt; numSphere; i++) &#123; const Sphere&amp; s = spheres[i]; if ((s.e.x &lt;= 0 &amp;&amp; s.e.y &lt;= 0 &amp;&amp; s.e.z &lt;= 0) || i &gt;= numSphere) continue; //skip no radiance Vec sw = s.p - x, su = ((fabs(sw.x) &gt; 0.1 ? Vec(0, 1) : Vec(1)).cross(sw)).norm(), sv = sw.cross(su); //x发出射向id=i的范围内随机方向的采样射线 double cos_a_max = sqrt(1 - s.rad * s.rad / (x - s.p).dot(x - s.p)); double eps1 = erand48(Xi), eps2 = erand48(Xi); //double cos_a = 1 - eps1*(1. - cos_a_max); double cos_a = 1 - eps1 + eps1 * cos_a_max; double sin_a = sqrt(1 - cos_a * cos_a); double phi = 2 * M_PI * eps2; Vec l = su * cos(phi) * sin_a + sv * sin(phi) * sin_a + sw * cos_a; l.norm(); // Note: // 根据Monte Carlo Integration得到相应形式的渲染方程(反射率方程) // Lo(p,wo) = (1/N)*∑(i~n) &#123;(Li(p,wi)*fr(p,wi,wo)*(n*wi)) / pdf&#125; // Lo:入射radiance, p:单位半球球心, wo:入射方向（微小立体角） // N:取样数（光线数）, Li wi略 // fr:BRDF, n:法线方向 // pdf: 分布函数 // 由于采用的是path tracing N取1, Lo(p,wo) = (Li(p,wi)*fr(p,wi,wo)*(n*wi)) / pdf // 当采用Lambert漫反射的BRDF可推导出为1/pi // 对半球均匀采样时，pdf=1/单位半圆面积，但射线的方向是在于法线的夹角最大是a_max, 采样的区域被限定 // 球形对角度A(法线方向与某一点的夹角)积分， 得S = ſ 2 * pi * r*r sinA dA = abs(2 * pi * r * r * cosA), r=1 // 易得pdf = 1 / 球部分表面积 = 1 / (2 * pi * r * r(1-cos_a_max)) = 1 / (2 * pi * (1-cos_a_max)) // Lo(p,wo) = (Li(p,wi)*fr(p,wi,wo)*(n*wi)) / pdf = Li(p,wi) * (1 / pi) * cos_a * (2 * pi * (1 - cos_a_max)) Vec temp1; if (intersect(Ray(x, l), t, id, temp1) &amp;&amp; id == i) &#123; double omega = 2 * M_PI * (1 - cos_a_max); e = e + f.mult(s.e * l.dot(n_real) * omega) * (1 / M_PI); //std::cout &lt;&lt; e.x &lt;&lt; std::endl; &#125; &#125; //std::cout &lt;&lt; f.x &lt;&lt; std::endl; return obj_e * E + e + f.mult(radiance(Ray(x, d), depth, Xi, 0)); //TEST:E暂时设置为0 &#125; else if (obj_refl == SPEC) &#123; //std::cout &lt;&lt; &quot;SPEC&quot; &lt;&lt; std::endl; // return obj_e + f.mult(radiance(Ray(x, r.d - n * 2 * n.dot(r.d)), depth, Xi)); &#125; else if (obj_refl == REFR) &#123; //std::cout &lt;&lt; &quot;REFR&quot; &lt;&lt; std::endl; Ray reflRay(x, r.d - n * 2 * n.dot(r.d)); bool into = n.dot(n_real) &gt; 0; double nc = 1;//真空 double nt = 1.5;//玻璃 double nnt = into ? nc / nt : nt / nc; double ddn = r.d.dot(n_real); double cos2_t = 1 - nnt * nnt * (1 - ddn * ddn); //2是平方 if (cos2_t &lt; 0) &#123; //没有折射，发生全反射 return obj_e + f.mult(radiance(reflRay, depth, Xi)); &#125; Vec tdir = (r.d * nnt - n * ((into ? 1 : -1) * (ddn * nnt + sqrt(cos2_t)))).norm(); //考虑到计算量，采用近似算法 double a = nt - nc, b = nt + nc, R0 = a * a / (b * b), c = 1 - (into ? -ddn : tdir.dot(n)); double Re = R0 + (1 - R0) * c * c * c * c * c, Tr = 1 - Re, P = 0.25 + 0.5 * Re, RP = Re / P, TP = Tr / (1 - P); if (depth &gt; 2) &#123; if (erand48(Xi) &lt; P) &#123; // RR return obj_e + f.mult(radiance(reflRay, depth, Xi) * RP); &#125; else &#123; return obj_e + f.mult(radiance(Ray(x, tdir), depth, Xi) * TP); &#125; &#125; else &#123; return obj_e + f.mult(radiance(reflRay, depth, Xi) * Re + radiance(Ray(x, tdir), depth, Xi) * Tr); &#125; &#125;&#125;Vec* c = new Vec[WIDTH * HIGHT]; //图像缓存void Initial(void)&#123; glClearColor(1.0f, 1.0f, 1.0f, 1.0f); glMatrixMode(GL_PROJECTION); int width = glutGet(GLUT_WINDOW_WIDTH); int height = glutGet(GLUT_WINDOW_HEIGHT); gluOrtho2D(0.0, width, 0.0, height);&#125;void myDisplay(void) &#123; glClear(GL_COLOR_BUFFER_BIT); glPointSize(1); for (int y = 0; y &lt; HIGHT; y++) &#123; for (int x = 0; x &lt; WIDTH; x++) &#123; int n = (HIGHT - y - 1) * WIDTH + x; glColor3f(gamma(c[n].x), gamma(c[n].y), gamma(c[n].z)); glBegin(GL_POINTS); glVertex2f(x, y); glEnd(); &#125; &#125; glFlush();&#125; int main(int argc, char* argv[]) &#123; int w = WIDTH, h = HIGHT; int samples = 1; //设置每subpixel采样数 //设置 camera Ray cam(Vec(50, 52, 295.6), Vec(0, -0.042612, -1).norm()); Vec cx = Vec(w * 0.5135 / h); //视场角 Vec cy = (cx.cross(cam.d)).norm() * 0.5135; Vec r; //摄影机射线 auto clock_start = clock();#pragma omp parallel for schedule(dynamic, 1) private(i) meshTriangles[0].move(15, 0, 0); for (int y = 0; y &lt; h; y++) &#123; UpdateProgress((float)y / HIGHT); unsigned short Xi[3] = &#123; 0, 0, y * y * y &#125;; //设置四个子像素 for (unsigned short x = 0; x &lt; w; x++) &#123; for (int sy = 0, i = (h - y - 1) * w + x; sy &lt; 2; sy++) &#123; for (int sx = 0; sx &lt; 2; sx++, r = Vec()) &#123; for (int s = 0; s &lt; samples; s++) &#123; double r1 = 2 * erand48(Xi); double dx = r1 &lt; 1 ? sqrt(r1) - 1 : 1 - sqrt(2 - r1); double r2 = 2 * erand48(Xi); //std::cout &lt;&lt; r1 &lt;&lt; &quot; &quot; &lt;&lt; r2 &lt;&lt; std::endl; double dy = r2 &lt; 1 ? sqrt(r2) - 1 : 1 - sqrt(2 - r2); Vec sample_direct = cx * (((dx + 0.5 + sx) / 2 + x) / w - 0.5) + cy * (((dy + 0.5 + sy) / 2 + y) / h - 0.5) + cam.d; //std::cout &lt;&lt; r.x &lt;&lt; std::endl; r = r + radiance(Ray(cam.o + sample_direct * 140, sample_direct.norm()), 0, Xi) * (1.0 / samples); //std::cout &lt;&lt; &quot;x:&quot; &lt;&lt; r.x &lt;&lt; &quot;y:&quot; &lt;&lt; r.y &lt;&lt; &quot;, z:&quot; &lt;&lt;r.z &lt;&lt; std::endl; // &#125; //std::cout &lt;&lt; c[i].x &lt;&lt; std::endl; // c[i] = c[i] + Vec(clamp01(r.x), clamp01(r.y), clamp01(r.z)) * 0.25; &#125; &#125; &#125; &#125; FILE* f = fopen(&quot;test.ppm&quot;, &quot;wb&quot;); fprintf(f, &quot;P3\\n%d %d\\n%d\\n&quot;, w, h, 255); for (int i = 0; i &lt; w * h; i++) &#123; fprintf(f, &quot;%d %d %d &quot;, toInt255(c[i].x), toInt255(c[i].y), toInt255(c[i].z)); &#125; fclose(f); glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE); glutInitWindowPosition(100, 100); glutInitWindowSize(w, h); glutCreateWindow(&quot;Path Tracing&quot;); Initial(); glutDisplayFunc(&amp;myDisplay); glutMainLoop(); return 0;&#125;","categories":[{"name":"Games101","slug":"Games101","permalink":"http://example.com/categories/Games101/"}],"tags":[]},{"title":"Games101_10_12 Geometry","slug":"Games101_10_12_Geometry","date":"2022-10-02T08:35:10.000Z","updated":"2023-02-03T13:34:33.512Z","comments":true,"path":"2022/10/02/Games101_10_12_Geometry/","link":"","permalink":"http://example.com/2022/10/02/Games101_10_12_Geometry/","excerpt":"","text":"Lecture 10/11: Geometry 1 2 不可能所有物体都用三角面表示，一些复杂的物体如毛发、水滴等用三角面表示开销极大； a). 几何的表示形式 隐式（Implicit） algebraic surface level sets distance functions … 显式（Explicit） point cloud polygon mesh subdivision, NURBS … b). 几何的隐式表示（Implict Representations of Geometry） 基于归类的点 点满足某种特定的关系，但不给你特定的点 e.g. Sphere: 所有三维中的点，满足 x2+y2+z2=1x^2+y^2+z^2=1x2+y2+z2=1； 通用情况：f(x,y,z)=0f(x,y,z)=0f(x,y,z)=0 缺点： 难以采样（Sampling Can Be Hard，难以得到式子表示的整体形状） 优点： 方便判断点是否在几何体内（Inside/Outside Tests Easy） b.1). Algebraic Surfaces（曲面代数） 难以表达复杂的形状； b.2). Constructive Solid Geometry（CSG, 体素构造表示形式） 对隐式几何体进行布尔运算； b.3). Distance Function（距离函数） 给出各个点到物体的最小距离 Blending Distance Function: **目的：**通过混合得到A、B运动的中间状态； 上半部分，blend之后中间1/3是灰的，而理想的结果是左边1/2是黑色，右边1/2是白色 下半部分，对SDF进行混合，再将blend后的结果恢复成shape（找到SDF等于0的情况的所有点），就可得到中间状态的物体； See https://iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm b.4). Level Set Methods（水平集） 封闭方程（DF）很难描述复杂的形状 **备选方案：**存储近似函数值的网格（Level Set Methods） 通过找到插值为0的位置确定表面； 提供对形状更明确的控制（如纹理）? 应用： Level Sets from Medical Data (CT, MRI, etc. 三维LSM) **物理模拟：**如水平集得到各点到液体边界的距离（距离函数混合水滴） See http://physbam.stanford.edu b.5). Fractals(分形) c). 几何的显式表示（“Explicit” Representations of Geometry） 简介： 直接给出所有的点 或者 通过参数映射（via parameter mapping） **参数映射：**给出uv，以及uv到三维空间的映射关系，遍历所有的uv就可找到三维空间所有的点； 采样简单 不方便判断点是否在几何体内（Inside/Outside Tests Hard） 隐式、显式各有优缺点，需要根据需求选择最优的表达方式 c.1). Point Cloud c.2). Polygon Mesh 常用的PolygonMesh文件，Wavefront Object File (.obj) v：顶点位置；vt：纹理位置；vn：normal；f：face，顶点索引/纹理索引/法线索引 c.3). Bézier Curve（贝塞尔曲线） 通过点p0p_0p0​ 、p1p_1p1​，且在这两点切线为t0t0t0、t1t1t1（切线前带系数，对于三次贝塞尔曲线系数为3） c.3.1). 计算贝塞尔曲线(德卡斯特里奥算法, De Casteljau’s Algorithm) 二次贝塞尔曲线 三次贝塞尔曲线（Cubic Bezier Curve） Anim： c.3.2). 代数形式 推出Bernstein polynomial（伯恩斯坦多项式）： Bin(t)=Cni⋅ti(1−t)n−iB_{i}^{n}(t)=C_n^i · t^{i}(1-t)^{n-i} Bin​(t)=Cni​⋅ti(1−t)n−i C.3.3). 性质 即（对于三次贝塞尔曲线）： b0b_0b0​ 是起点，b3b_3b3​是终点； 切线为b′(0)=3(b1−b0);b′(1)=3(b3−b2)\\mathbf{b}^{\\prime}(0)=3\\left(\\mathbf{b}_{1}-\\mathbf{b}_{0}\\right) ; \\quad \\mathbf{b}^{\\prime}(1)=3\\left(\\mathbf{b}_{3}-\\mathbf{b}_{2}\\right)b′(0)=3(b1​−b0​);b′(1)=3(b3​−b2​) （切线前带系数，对于三次贝塞尔曲线系数为3，通过求导可得） 仿射不变性（对于贝塞尔曲线做仿射变换，只需要对控制点进行变换） 凸包性质； c.3.4). Piecewise Bézier Curves（分段贝塞尔曲线） 使用原因：解决高阶贝塞尔曲线控制点过多的问题； 分段贝塞尔曲线，常是分段立方贝塞尔（Piecewise cubic Bézier），即每一个曲线存在4个控制点； c.3.4.1). 连续性 C0 连续（C表示Continuity），几何连续：an=b0a_n=b_0an​=b0​ ； 首尾相接，夹角任意； C1 连续，参数连续：an=b0=12(an−1+b1)a_n=b_0={1\\over2}(a_{n-1} + b_1)an​=b0​=21​(an−1​+b1​) ； 切线相等，即一阶导数连续； 3.5). Other types of splines(待深入) In this course We do not cover B-splines and NURBS We also do not cover operations on curves (e.g. increasing/decreasing orders, etc.) To learn more / deeper, you are welcome to refer to Prof. Shi-Min Hu’s course: https://www.bilibili.com/video/av66548502?from=search&amp;seid=65256805876131485 3.6). Bezier Surface Animation: Steven Wittens, Making Things with Maths, http://acko.net 3.6.1). Evaluating Bézier Surfaces Lecture 13 Geometry a). Subdivision 以下是几种常用的细分方法: a.1). Loop Subdivision(Loop是人名) 细分对象：三角面 首先，创造更多的三角面； 第二，改变他们的位置； 具体做法： 将每个三角形细分为四个； 根据权重分配新的顶点位置； 区分新/老顶点，做不同变换； 对于新顶点： Pnew=38(A+B)+18(C+D)P_{new} = {3\\over8}(A+B)+{1\\over8}(C+D)Pnew​=83​(A+B)+81​(C+D) 对于老顶点： n:n:n: 顶点的度（图论，与该顶点关联的边的数目，该处即为与该顶点连接的边的数量） u:u:u: 3/163/163/16（如果n=3n=3n=3），3/(8n)3/(8n)3/(8n) （其他情况） Pnew=(1−nu)original_position+u⋅neighbor_position_sumP_{new} = (1-nu)original\\_position + u·neighbor\\_position\\_sumPnew​=(1−nu)original_position+u⋅neighbor_position_sum Loop Subdivision Results： 缺点：Loop只能处理三角面； a.2). Catmull-Clark Subdivision 概念： 奇异点（Extraorinary vertex）：度不为4的点； 具体过程： 第一次细分： 每条边取中点，每个面也取其中一点； 第一次细分后，引入（n个，n=非四边形数目）奇异点，非四边形面消失。之后，奇异点不在增加，因此，之后细分只针对四边面； Catmull-Clark Vertex Update Rules (Quad Mesh) Face point: f=f=f=","categories":[{"name":"Games101","slug":"Games101","permalink":"http://example.com/categories/Games101/"}],"tags":[]},{"title":"Games101-7-9 Shading","slug":"Games101_07_09_Shading","date":"2022-10-02T08:25:10.000Z","updated":"2023-02-03T13:33:23.828Z","comments":true,"path":"2022/10/02/Games101_07_09_Shading/","link":"","permalink":"http://example.com/2022/10/02/Games101_07_09_Shading/","excerpt":"","text":"Lecture 07/08 Shading(Illumination, Shading and Graphics Pipeline) a). Definition b). A Simple Shading Model(Blinn-Phong Reflectance Model) b.1). Fundamental Blinn-Phong是一个经验模型，并不是严格基于物理的； 进入视线内的光照一般有以下构成： 高光（Specualr） 漫反射（Diffuse） 环境光（Ambient） 自发光（Emissive） **Shading is Local: **Compute light reflected toward camera at a specific shading point No shadows will be generated! (shading ≠ shadow) 阴影会由另外的Shadow Caster来着色； b.2). Diffuse Reflection Blinn-Phong中，漫反射的光均匀散射到各个方向； Lambert’s cosine law：接收到的能量与 l⋅nl·nl⋅n 成正比例 Light Falloff 漫反射最终的着色： b.3). Specular Term(Blinn-Phong) Intensity depends on view direction 采用半程向量简化计算。采用半程向量hhh与nnn点乘的是Blinn-Phong模型，而采用镜面反射方向rrr和视线方向vvv点乘的是Phong模型； **指数ppp的作用：**Increasing p narrows the reflection lobe 效果总览： b.4). Ambient Term c). Shading Frequencies c.1). Flat shading c.2). Gouraud shading c.3). Phong shading c.4). 对比 不一定Phong着色就比Flat优秀。在极高面数的一些情况下，Flat Shading性能开销比Phong Shading小，且呈现效果相差无几； c.5). 定义顶点/像素法线 顶点法线为相邻三角形的加权平均（权重与三角面的面积有关，当然也可简单平均，但效果较加权平均差）； 逐像素的法线通过对顶点法线进行重心插值（Barycentric interpolation）后归一化（normalize）得到； d). Graphics(Real-time Rendering) Pipeline 这段可看冯的入门精要作为简单的补充 MVP矩阵相关的发生在顶点阶段； 光栅化； Shading可在Vertex Processing阶段，也可在Fragment Processing阶段； Texture mapping Shader： 优秀Shader（到时候好好学习一下） Inigo Quilez, https://youtu.be/XuSnLbB1j6E Lecture 08/09 Shading(Texture Mapping) 可见 百人计划-图形1.3-纹理的秘密 作为补充； a). Interpolation Across Triangles: Barycentric Coordinates 重心插值的作用：通过顶点特定的值（normal、Color、Depth、Texture coordinates…），得到三角形内部**片元（像素）**上平滑过渡的值； 数学基础： 共面需满足的条件： α+β+γ=1α+β+γ=1α+β+γ=1，如需要点在三角形内，还需满足α&gt;0,β&gt;0,γ&gt;0α&gt;0,β&gt;0,γ&gt;0α&gt;0,β&gt;0,γ&gt;0 重心坐标求法： 由以上易得，重心坐标(x,y)=13A+13B+13C\\begin{aligned}(x, y) &amp;=\\frac{1}{3} A+\\frac{1}{3}B+\\frac{1}{3} C\\end{aligned}(x,y)​=31​A+31​B+31​C​ 通用计算公式： Final： **注意：**重心并没有投影不变性，因此进行插值需要在三维空间中进行，而不是在屏幕的二维投影上； b). Texture Magnification(需要放大纹理的情况) 对应情况：纹理过小（如距离物体近，而贴图小） 插值方式： Nearest Bilinear Bicubic b.1). Bilinear Interpolation c). Texture Magnification(需要缩小纹理的情况) 对应情况：纹理过大（如距离物体远，而贴图大） 解决思路： 增大采样率（超采样） 高质量，但性能开销大； 减小贴图频率（Mipmap） c.1). Mipmap c.1). 如何确定Mipmap的level（参考百人计划）： c.2). Mipmap之间的过渡 Visualization of Mipmap Level(D rounded to nearest integer level)： Trilinear Interpolation **作法：**对相邻两层的Mipmap做Bilinear Interpolation，根据所得的level，对相邻两层进过插值的结果再进行一次插值；（e.g. D=1.6，则对一层和二层分别进行双线性插值后，再进行lerp(1.6−1,n1,n2)lerp(1.6-1, n_1, n_2)lerp(1.6−1,n1​,n2​)） Final： d). Applications of Textures d.1). Environment Map 简介： 对于环境光源，我们认为它来自与无限远处，即没有深度意义，不同位置的同一方向受到的环境光源相同（当然，暂不考虑遮挡） Spherical Environment Map： **Problem：**不是均匀的描述，在极点会存在较大的扭曲； CubeMap： d.2). Bump Mapping 凹凸贴图（视差贴图/法线贴图）计算法线过程： 思路（一维情况，in flatland）： 原始法线 n(p)=(0,1)n(p)=(0,1)n(p)=(0,1) 在 p 点的导数 dp=c⋅[h(p+1)−h(p)]dp=c·[h(p+1)-h(p)]dp=c⋅[h(p+1)−h(p)] （ccc 是常数，用于缩放导数，改变其影响程度），得出切线 计算法线（垂直于切线） n(p)=(−dp,1).normalized()n(p)=(-dp,1).normalized()n(p)=(−dp,1).normalized()； 思路（in 3D）： 原始法线 n(p)=(0,0,1)n(p)=(0,0,1)n(p)=(0,0,1)； 纹理上的点对 uuu 方向和 vvv 方向求偏导，得出切线 dp/du=c1⋅[h(u+1)−h(u)]dp/du=c1·[h(u+1)-h(u)]dp/du=c1⋅[h(u+1)−h(u)] dp/dv=c2⋅[h(v+1)−h(v)]dp/dv=c2·[h(v+1)-h(v)]dp/dv=c2⋅[h(v+1)−h(v)] 计算法线（垂直于切线） n(p)=(−dp/du,−dp/dv,1).normalized()n(p)=(-dp/du,-dp/dv,1).normalized()n(p)=(−dp/du,−dp/dv,1).normalized()； 以上计算均在切线空间、局部空间计算（具体看冯-入门精要） Displacement mapping（置换/高度贴图）: 需要足够多的三角面（DX中的Dynamic Tessellation，动态曲面细分） 真正地移动了顶点 d.3). 3D Procedural Noise + Solid Modeling Perlin noise d.4). Provide Precomputed Shading 使用Baking的AO等（也可记录其他信息，如SP中的ID、Position、Curvature等）； d.5). 3D Textures and Volume Rendering 体渲染","categories":[{"name":"Games101","slug":"Games101","permalink":"http://example.com/categories/Games101/"}],"tags":[]},{"title":"Games101-5-6 Rasterization","slug":"Games101_05_06_Rasterization","date":"2022-10-02T08:20:10.000Z","updated":"2023-02-03T13:32:25.629Z","comments":true,"path":"2022/10/02/Games101_05_06_Rasterization/","link":"","permalink":"http://example.com/2022/10/02/Games101_05_06_Rasterization/","excerpt":"","text":"Lecture 05 Rasterization(Triangles) a). Perspective Projection 如何定义一个frustum： 近平面宽度、高度（得到宽高比） FOV(Field of View) b). Viewport transformation 经过MVP后，模型空间中点变换到标准立方体（canonical cube, x,y,z[-1, 1]）中。之后就需要进行视口变换（Viewport transformation） 定义屏幕空间 OpenGL屏幕空间坐标原点为左下（上图），DX坐标原点为左上 像素位置该像素（方块）左下角的坐标，如左下角像素坐标为(0,0)(0, 0)(0,0)，但像素中心为(0.5,0.5)(0.5, 0.5)(0.5,0.5) Viewport transformation c). Rasterization Frame Buffer: Memory for a Raster Display 显存中的一块区域 补充：Render texture（详情见Other/Note） 以下以Unity为例： 渲染过程中，贴图最开始在CPU内存，这时的贴图被称为client-side的texture，最后被送到GPU，这时叫server-side的texture； Render texture是将FrameBufferObject连接到一个server-side的texture； 注意：FrameBufferObject不一定只有一个，也不一定连接屏幕； 详情：http://t.csdn.cn/3JHqA Triangles - Fundamental Shape Primitives 无法分割为其他多边形 保证是一个平面 容易区分内部和外部 内部插值方便 Fundament： What Pixel Values Approximate a Triangle? Sampling（采样）：逐像素中心采样，判断像素是否在三角形内 for (int x = 0; x &lt; xmax; ++x) output[x] = f(x); **判断(x,y)(x,y)(x,y)是否在三角形内：**做三次叉乘，看正负符号是否相同，相同则在三角形内； Edge Cases：要么不做处理，要么特殊处理（OpenGL，DX里规定落于左边和上边算三角形中的点，而落于右边和下边的不算**“Top-Left Rule”**） 光栅化加速 光栅化中，对每一个像素都判断是否在三角形中性能浪费过大。因此，加入**Bounding Box（包围盒）**来限定需要进行判断的区域 Incremental Triangle Traversal（找到三角形中每一行最左和最右的像素，但实际上没那么容易，是用于细长并旋转的三角形） Lecture 6: Rasterization 2(Antialiasing and Z-Buffering) a). Sampling Artifacts(Errors / Mistakes / Inaccuracies) in Computer Graphics 由于采样造成的“Artifacts“ 锯齿（ Jaggies）——空间上采样 摩尔纹（Moire）——欠采样图像 车轮错觉（Wagon wheel effect）——时间上采样 …… **造成错误的原因：信号频率高，而采样频率低（可联系奈奎斯特定理：**当采样频率大于信号中最高频率的2倍时(fs&gt;2f)，采样之后的数字信号完整地保留了原始信号中的信息） b). Antialiasing Idea:Blurring (Pre-Filtering) Before Sampling 抗锯齿的思路就是在采样前”模糊“； **注意：**先模糊，后采样。对应频域上先低通滤波（或其他操作，如卷积、超采样，FSAA那种图像层面的抗锯齿暂不考虑），后采样（**卷积定理：**时域信号与冲激信号相乘，等于两者对应的频域信号卷积。反之，也成立）； c). Frequency Domain c.1). Fundamental 傅里叶变换 **卷积定理：**时域中乘积等于频域上卷积，反之也成立。（时域信号与冲激信号相乘，等于两者对应的频域信号卷积。反之，也成立。） Aliases: 在给定的采样率下，无法区分两个不同频率 c.2). Filtering: Getting rid of certain frequency contents K空间：反应图像进过二维傅里叶变换后的结果，越靠中间，频率越小； 出现十字星的原因：把图像看成类似Wrap Mode的Repeat，即重复的图像。使得其四个方向的高频内容增加，形成十字星； Filter（滤波器）： High-pass filter![High_pass filter](High_pass filter.png) Low-pass filter Filter Out Low and High Frequencies c.3). Convolution Filtering = Convolution (= Averaging) 注意：只是在这里相等，而滤波和卷积概念上不相同； 对信号进行滤波，就是用卷积核和信号做卷积； Point-wise local averaging in a “sliding window” **卷积定理：**在空域（时域）做卷积，等于在频域做乘积；反之亦然。 因此，对图像滤波有两种处理方法； **Option 1: **在空域上与滤波器（卷积核）做卷积； **Option 2: ** 将图像和滤波器（卷积核）转换到频域（傅里叶变换）； 两者在频域相乘； 将得到的结果重新变换到空域（逆傅里叶变换）； Box Filter 箱式滤波类似于低通滤波 更大的卷积核意味着更低的频率 c.4). Sampling = Repeating Frequency Contents 锯齿=混叠 d). Antialiasing 解决锯齿的选择： 提高采样率 增大冲激信号在频域的距离； 更高分辨率的显示器； 缺点：成本高，且需要很高的分辨率 抗锯齿 让信号在采样（重复，Repeat）前变“窄”，即在采样前过滤掉高频部分 Antialiasing = Limiting, then repeating Solution: Convolve f(x,y) by a 1-pixel box-blur Recall: convolving = filtering = averaging Then sample at every pixel’s center 通过计算像素平均值来抗锯齿 e). SSAA(Super Sampling Antialiasing) 通过将一个像素分割成NxN个像素来进行采样和shading，最后将每个像素点内部所细分的采样点的颜色值全部加起来再求均值，作为该像素点的抗锯齿之后的颜色值 f). MSAA(Multi-Sampling Antialiasing) MSAA是对SSAA的改进。SSAA的计算量大，一个像素中会有多个点进行shading，而MSAA只是计算究竟有几个采样点会被三角形cover，计算颜色的时候只会利用像素中心坐标进行一次shading。 如图中大点所在的像素块，三角形只覆盖了其中的三个点（左下，右上，右下），则该像素的颜色为75%Colororigin75\\%Color_{origin}75%Colororigin​，之后，再对像素中心进行采样 **注意：**MSAA只是近似Blur，而没提高采样率。要注意和SSAA以及高分辨率的区分 **在实际中，**子像素的划分并不是均匀划分为NxN，而是通过其他更有效的方法，而且有些样本还会得到复用； SSAA中每个像素点有4个子采样点，每个三角形对每个像素点的4个子采样点各着色1次（共4次），再把计算结果根据深度和覆盖信息保存到对应的子采样点，最后对4个采样点取均值作为最终的像素颜色； MSAA中每个像素点有4个子采样点，每个三角形对每个像素点只在中心点着色1次，再把计算结果根据深度和覆盖信息保存到对应的子采样点，最后对4个采样点取均值作为最终的像素颜色； g). Other AA FXAA(Fast Approximate AA) 图像层面上进行处理，是一个后期处理，先得到有锯齿的图像，再通过图像匹配找到有锯齿的边界，之后，替换为没有锯齿的边界； TAA(Temporal AA) 可以联系UE_NOTE 将空域采样点，均匀分布到时域上； h). Z-buffer h.0). Painter’s Algorithm 画家算法： 对三角形进行排序，先画远的，再画近的； 不能解决相互遮挡问题，因此采用Z-buffer h.1). Z-buffer Idea： 储存**每个采样（像素）**中最小的深度值； 储存深度值到缓存区（buffer）中； 为了简单起见，我们看作z是正数(smaller z -&gt; closer, larger z -&gt; further)； 深度缓存步骤： 初始化深度缓存，将其中每个值初始化为∞ 遍历每个三角形面上的每一个像素点[x,y]，如果该像素点的深度值z，小于Z-buffer[x,y]中的值，则更新zbuffer[x,y]值为该点深度值z，并同时更新该像素点[x,y]的颜色为该三角形面上的该点的颜色。 伪代码： 时间复杂度O(n)O(n)O(n)。Z-buffer并没有进行排序，只是求得最小（深度）值，因此时间复杂度为线性； 三角形的绘制顺序并不影响最终结果（不考虑不透明等情况）；","categories":[{"name":"Games101","slug":"Games101","permalink":"http://example.com/categories/Games101/"}],"tags":[]},{"title":"Games101-2-4 Math","slug":"Games101_02_04_Math","date":"2022-10-02T08:15:10.000Z","updated":"2023-02-03T14:43:35.125Z","comments":true,"path":"2022/10/02/Games101_02_04_Math/","link":"","permalink":"http://example.com/2022/10/02/Games101_02_04_Math/","excerpt":"","text":"Lecture 02 Review of Linear Algebra a). Cross Product 判断相对的左右、前后、内外 **判断左右：**如$ \\vec{a} \\cdot \\vec{b} &gt; 0$那 b⃗\\vec{b}b 就在 a⃗\\vec{a}a 的左侧（按图中的右手坐标系） 判断内外：判断 AB⃗\\vec{AB}AB 和 AP⃗\\vec{AP}AP 的关系，可判断PPP 点的在 AB⃗\\vec{AB}AB 的左侧，同理可判断PPP 在 BC⃗\\vec{BC}BC 和 CA⃗\\vec{CA}CA 的左侧，即均在向量同侧。由此，可判断PPP 点的在 ABCABCABC 的内部 b). Orthonormal Coordinate Frames(正交直角坐标系) Lecture 03 Transformation a). 2D Transformation Scale Matrix Reflection Matrix Shear Matrix(切变矩阵) Rotation matrix(默认原点(0, 0), CCW/逆时针旋转) b). Homogeneous coordinates(齐次坐标) To solve: 平移不是线性变换，无法用2*2矩阵表示（2D） 为什么点和向量的其次项不同？ 向量具有平移不变性，齐次项为0可使其不受txt_xtx​、tyt_yty​的影响 考虑向量与点、向量/点之间的运算 point + point得到两点的中点 所有的仿射变换（Affine Transformation）都可以用齐次坐标系表示 复杂变换，如 c). 3D Transformation 三维空间中使用齐次坐标的变换 (x′y′z′1)=(abctxdeftyghitz0001)⋅(xyz1)\\left(\\begin{array}{l} x^{\\prime} \\\\ y^{\\prime} \\\\ z^{\\prime} \\\\ 1 \\end{array}\\right)=\\left(\\begin{array}{lllc} a &amp; b &amp; c &amp; t_{x} \\\\ d &amp; e &amp; f &amp; t_{y} \\\\ g &amp; h &amp; i &amp; t_{z} \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{array}\\right) \\cdot\\left(\\begin{array}{l} x \\\\ y \\\\ z \\\\ 1 \\end{array}\\right) ⎝⎜⎜⎜⎛​x′y′z′1​⎠⎟⎟⎟⎞​=⎝⎜⎜⎜⎛​adg0​beh0​cfi0​tx​ty​tz​1​⎠⎟⎟⎟⎞​⋅⎝⎜⎜⎜⎛​xyz1​⎠⎟⎟⎟⎞​ (x′y′z′1)=(100tx010ty001tz0001)⋅(abc0def0ghi00001)⋅(xyz1)\\left(\\begin{array}{l} x^{\\prime} \\\\ y^{\\prime} \\\\ z^{\\prime} \\\\ 1 \\end{array}\\right)=\\left(\\begin{array}{lllc} 1 &amp; 0 &amp; 0 &amp; t_{x} \\\\ 0 &amp; 1 &amp; 0 &amp; t_{y} \\\\ 0 &amp; 0 &amp; 1 &amp; t_{z} \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{array}\\right) \\cdot\\left(\\begin{array}{lllc} a &amp; b &amp; c &amp; 0 \\\\ d &amp; e &amp; f &amp; 0 \\\\ g &amp; h &amp; i &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{array}\\right) \\cdot\\left(\\begin{array}{l} x \\\\ y \\\\ z \\\\ 1 \\end{array}\\right) ⎝⎜⎜⎜⎛​x′y′z′1​⎠⎟⎟⎟⎞​=⎝⎜⎜⎜⎛​1000​0100​0010​tx​ty​tz​1​⎠⎟⎟⎟⎞​⋅⎝⎜⎜⎜⎛​adg0​beh0​cfi0​0001​⎠⎟⎟⎟⎞​⋅⎝⎜⎜⎜⎛​xyz1​⎠⎟⎟⎟⎞​ 上述矩阵先线性变换再平移，相当于： (x′y′z′1)=(100tx010ty001tz0001)⋅(abc0def0ghi00001)⋅(xyz1)\\left(\\begin{array}{l}x^{\\prime} \\\\y^{\\prime} \\\\z^{\\prime} \\\\1\\end{array}\\right)=\\left(\\begin{array}{lllc}1 &amp; 0 &amp; 0 &amp; t_{x} \\\\0 &amp; 1 &amp; 0 &amp; t_{y} \\\\0 &amp; 0 &amp; 1 &amp; t_{z} \\\\0 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right) \\cdot\\left(\\begin{array}{lllc}a &amp; b &amp; c &amp; 0 \\\\d &amp; e &amp; f &amp; 0 \\\\g &amp; h &amp; i &amp; 0 \\\\0 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right) \\cdot\\left(\\begin{array}{l}x \\\\y \\\\z \\\\1\\end{array}\\right) ⎝⎜⎜⎜⎛​x′y′z′1​⎠⎟⎟⎟⎞​=⎝⎜⎜⎜⎛​1000​0100​0010​tx​ty​tz​1​⎠⎟⎟⎟⎞​⋅⎝⎜⎜⎜⎛​adg0​beh0​cfi0​0001​⎠⎟⎟⎟⎞​⋅⎝⎜⎜⎜⎛​xyz1​⎠⎟⎟⎟⎞​ 补充知识：正交矩阵 Lecture 04 Transformation Cont. a). 3D变换 a.1) Scale、Translation a.2) 3D Rotations 旋转矩阵： 注意绕y轴旋转和其他的区别（y=cross(z,x)y=cross(z, x)y=cross(z,x)） 三轴旋转可以表示3D空间的所有旋转变换，例如飞机（Roll、Pitch、Yaw） 罗德里格旋转公式（表示绕任意经过原点轴的任意旋转） 默认旋转轴经过原点 (0−nznynz0−nx−nynx0)\\left(\\begin{array}{ccc} 0 &amp; -n_{z} &amp; n_{y} \\\\ n_{z} &amp; 0 &amp; -n_{x} \\\\ -n_{y} &amp; n_{x} &amp; 0 \\end{array}\\right)⎝⎛​0nz​−ny​​−nz​0nx​​ny​−nx​0​⎠⎞​是叉乘向量的矩阵形式 四元数多是为了旋转之间的插值用的 四元数待课后补充 b). Viewing Transformation **概念：**Viewing Transformation（观测矩阵）相当于MVP中的VP View/Camera transformation Projection transformation Orthographic projection Perspective projection b.1) View Transformaiton Difine the camera: View Space: 相机位于原点，上是YYY，看向−Z-Z−Z 看成所有相机不动，全是其他物体动 MviewM_{view}Mview​： in math: 直接应用矩阵空间变换 b.2) Projection transformation 这里的投影变换中对xyzw都乘了z，因此最后需要齐次除法（透视除法），转换到NDC(Normalized Device Coordinates) b.2.1 Orthographic Projection 简易理解：![Orthographic Projection](Orthographic Projection.png) 注意[−1,1][-1, 1][−1,1] 图形学中的做法：![Orthographic Projection In general](Orthographic Projection In general.png) 通过平移将立方体中心化 缩放成标准立方体（“canonical” cube） 这里采用右手坐标系，缺点是f&lt;nf&lt;nf&lt;n，远的z值小于近的z值 矩阵形式： Mortho =[2r−l00002t−b00002n−f00001][100−r+l2010−t+b2001−n+f20001]M_{\\text {ortho }}=\\left[\\begin{array}{cccc} \\frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; \\frac{2}{t-b} &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; \\frac{2}{n-f} &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{array}\\right]\\left[\\begin{array}{cccc} 1 &amp; 0 &amp; 0 &amp; -\\frac{r+l}{2} \\\\ 0 &amp; 1 &amp; 0 &amp; -\\frac{t+b}{2} \\\\ 0 &amp; 0 &amp; 1 &amp; -\\frac{n+f}{2} \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{array}\\right] Mortho ​=⎣⎢⎢⎢⎡​r−l2​000​0t−b2​00​00n−f2​0​0001​⎦⎥⎥⎥⎤​⎣⎢⎢⎢⎡​1000​0100​0010​−2r+l​−2t+b​−2n+f​1​⎦⎥⎥⎥⎤​ Caveat: （使用右手坐标系）看向 −Z-Z−Z 使得f&lt;nf&lt;nf&lt;n，远的z值小于近的z值 这也是为什么OpenGL使用左手坐标系（但也会造成其他问题） b.2.2 Perspective Projection 前置知识： How to do perspective projection 挤压（squish） Mpersp → ortho =(n0000n00????0010)M_{\\text {persp } \\rightarrow \\text { ortho }}=\\left(\\begin{array}{cccc} n &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; n &amp; 0 &amp; 0 \\\\ ? &amp; ? &amp; ? &amp; ? \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\end{array}\\right)Mpersp → ortho ​=⎝⎜⎜⎜⎛​n0?0​0n?0​00?1​00?0​⎠⎟⎟⎟⎞​ 不知道经过挤压后zzz的变化（即第三行乘以(xyn1)\\left(\\begin{array}{l} x \\\\ y \\\\ n \\\\ 1 \\end{array}\\right)⎝⎜⎜⎜⎛​xyn1​⎠⎟⎟⎟⎞​未知），但知道： 在近平面的点不会变化 在远平面的中点不会变化 z=nz=nz=n时，(xyn1)⇒(xyn1)==(nxnnyn2n)\\left(\\begin{array}{l} x \\\\ y \\\\ n \\\\ 1 \\end{array}\\right) \\Rightarrow\\left(\\begin{array}{l} x \\\\ y \\\\ n \\\\ 1 \\end{array}\\right)==\\left(\\begin{array}{c} n x^{n} \\\\ n y \\\\ n^{2} \\\\ n \\end{array}\\right)⎝⎜⎜⎜⎛​xyn1​⎠⎟⎟⎟⎞​⇒⎝⎜⎜⎜⎛​xyn1​⎠⎟⎟⎟⎞​==⎝⎜⎜⎜⎛​nxnnyn2n​⎠⎟⎟⎟⎞​ 易得(00AB)(xyn1)=n2\\left(\\begin{array}{llll} 0 &amp; 0 &amp; A &amp; B \\end{array}\\right)\\left(\\begin{array}{l} x \\\\ y \\\\ n \\\\ 1 \\end{array}\\right)=n^{2}(0​0​A​B​)⎝⎜⎜⎜⎛​xyn1​⎠⎟⎟⎟⎞​=n2 An+B=n2An+B=n^2An+B=n2 z=fz=fz=f时，对于远平面中点，(00f1)⇒(00f1)==(00f2f)\\left(\\begin{array}{l} 0 \\\\ 0 \\\\ f \\\\ 1 \\end{array}\\right) \\Rightarrow\\left(\\begin{array}{l} 0 \\\\ 0 \\\\ f \\\\ 1 \\end{array}\\right)==\\left(\\begin{array}{c} 0 \\\\ 0 \\\\ f^{2} \\\\ f \\end{array}\\right)⎝⎜⎜⎜⎛​00f1​⎠⎟⎟⎟⎞​⇒⎝⎜⎜⎜⎛​00f1​⎠⎟⎟⎟⎞​==⎝⎜⎜⎜⎛​00f2f​⎠⎟⎟⎟⎞​ 易得(00AB)(00f1)=f2\\left(\\begin{array}{llll} 0 &amp; 0 &amp; A &amp; B \\end{array}\\right)\\left(\\begin{array}{l} 0 \\\\ 0 \\\\ f \\\\ 1 \\end{array}\\right)=f^{2}(0​0​A​B​)⎝⎜⎜⎜⎛​00f1​⎠⎟⎟⎟⎞​=f2 Af+B=f2Af+B=f^2Af+B=f2 得A=n+fA=n+fA=n+f，B=−nfB=-nfB=−nf Mpersp → ortho =(n0000n0000n+f−nf0010)M_{\\text {persp } \\rightarrow \\text { ortho }}=\\left(\\begin{array}{cccc} n &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; n &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; n+f &amp; -nf \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\end{array}\\right)Mpersp → ortho ​=⎝⎜⎜⎜⎛​n000​0n00​00n+f1​00−nf0​⎠⎟⎟⎟⎞​ 之后进行平行投影的变换，得 Mper =[2nr−l0l+rl−r002nt−bb+tb−t000f+nn−f2fnf−n0010]\\mathbf{M}_{\\text {per }}=\\left[\\begin{array}{cccc} \\frac{2 n}{r-l} &amp; 0 &amp; \\frac{l+r}{l-r} &amp; 0 \\\\ 0 &amp; \\frac{2 n}{t-b} &amp; \\frac{b+t}{b-t} &amp; 0 \\\\ 0 &amp; 0 &amp; \\frac{f+n}{n-f} &amp; \\frac{2 f n}{f-n} \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\end{array}\\right]Mper ​=⎣⎢⎢⎢⎡​r−l2n​000​0t−b2n​00​l−rl+r​b−tb+t​n−ff+n​1​00f−n2fn​0​⎦⎥⎥⎥⎤​ 【补充】 作业1中用到的绕任意轴旋转： 步骤： 将旋转轴平移至原点 将旋转轴旋转至YOZ平面 将旋转轴旋转至于Z轴重合 绕Z轴旋转θ度 执行步骤3的逆过程 执行步骤2的逆过程 执行步骤1的逆过程 如果旋转轴是过原点的，那么第一步和最后一步的平移操作可以省略，也就是把中间五个矩阵连乘起来，再转置一下，得到下面的绕任意轴旋转的矩阵 [a2+(1−a2)cos⁡θab(1−cos⁡θ)+csin⁡θac(1−cos⁡θ)−bsin⁡θ0ab(1−cos⁡θ)−csin⁡θb2+(1−b2)cos⁡θbc(1−cos⁡θ)+asin⁡θ0ac(1−cos⁡θ)+bsin⁡θbc(1−cos⁡θ)−asin⁡θc2+(1−c2)cos⁡θ00001]\\left[\\begin{array}{cccc} a^{2}+\\left(1-a^{2}\\right) \\cos \\theta &amp; a b(1-\\cos \\theta)+\\operatorname{csin} \\theta &amp; a c(1-\\cos \\theta)-b \\sin \\theta &amp; 0 \\\\ a b(1-\\cos \\theta)-c \\sin \\theta &amp; b^{2}+\\left(1-b^{2}\\right) \\cos \\theta &amp; b c(1-\\cos \\theta)+a \\sin \\theta &amp; 0 \\\\ a c(1-\\cos \\theta)+b \\sin \\theta &amp; b c(1-\\cos \\theta)-a \\sin \\theta &amp; c^{2}+\\left(1-c^{2}\\right) \\cos \\theta &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{array}\\right] ⎣⎢⎢⎢⎡​a2+(1−a2)cosθab(1−cosθ)−csinθac(1−cosθ)+bsinθ0​ab(1−cosθ)+csinθb2+(1−b2)cosθbc(1−cosθ)−asinθ0​ac(1−cosθ)−bsinθbc(1−cosθ)+asinθc2+(1−c2)cosθ0​0001​⎦⎥⎥⎥⎤​","categories":[{"name":"Games101","slug":"Games101","permalink":"http://example.com/categories/Games101/"}],"tags":[]}],"categories":[{"name":"Games202","slug":"Games202","permalink":"http://example.com/categories/Games202/"},{"name":"Games101","slug":"Games101","permalink":"http://example.com/categories/Games101/"}],"tags":[]}