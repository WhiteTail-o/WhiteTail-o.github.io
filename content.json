{"meta":{"title":"WhiteTail's Blog","subtitle":"","description":"","author":"WhiteTail","url":"https://whitetail-o.github.io","root":"/"},"pages":[{"title":"关于","date":"2023-02-03T11:37:30.151Z","updated":"2023-02-03T11:37:30.151Z","comments":false,"path":"about/index.html","permalink":"https://whitetail-o.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"友情链接","date":"2023-02-03T17:19:06.751Z","updated":"2023-02-03T11:19:24.219Z","comments":true,"path":"links/index.html","permalink":"https://whitetail-o.github.io/links/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2023-02-03T11:19:24.218Z","updated":"2023-02-03T11:19:24.218Z","comments":false,"path":"/404.html","permalink":"https://whitetail-o.github.io/404.html","excerpt":"","text":""},{"title":"书单","date":"2023-02-03T11:19:24.219Z","updated":"2023-02-03T11:19:24.219Z","comments":false,"path":"books/index.html","permalink":"https://whitetail-o.github.io/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-02-03T11:19:24.219Z","updated":"2023-02-03T11:19:24.219Z","comments":false,"path":"repository/index.html","permalink":"https://whitetail-o.github.io/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-02-01T05:38:13.000Z","updated":"2023-02-03T20:17:53.299Z","comments":true,"path":"tags/index.html","permalink":"https://whitetail-o.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2023-02-01T05:38:13.000Z","updated":"2023-02-03T20:13:53.110Z","comments":true,"path":"categories/index.html","permalink":"https://whitetail-o.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Q&A","slug":"Q&A","date":"2023-02-12T13:02:18.760Z","updated":"2023-02-12T13:16:32.586Z","comments":true,"path":"2023/02/12/Q&A/","link":"","permalink":"https://whitetail-o.github.io/2023/02/12/Q&A/","excerpt":"","text":"零度菲涅尔值与AlbedoGames202-5 Real-time Physically-based Materials Q：在金属或高光工作流中，对于非导体材质（电介质）默认其零度菲涅尔值$R_0$ 为4%，那么按PBR来，他怎么会有颜色呢；还是说非导体的albedo就是$R_0$ ? 按作业中来好像albedo就是 $R_0$ ，后续还得深挖一下； A：对于最终用于BRDF中的$F_0(R_0)$，会根据Metallic在$R_0$和albedo之间Lerp。 1F0 = lerp(R0, albedo, metallic); 如果不做特殊处理，那对于Metallic为0的物体是不会有颜色的（如简单使用GGX等）。但一般会进行一些特殊处理（如Disney’s Principled BRDF），使得Metallic为0的物体仍有一定颜色； Jacobian（雅克比矩阵）Q：Jacobian 项，方向导数需要去了解更多","categories":[{"name":"Q&A","slug":"Q-A","permalink":"https://whitetail-o.github.io/categories/Q-A/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://whitetail-o.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"Q&A","slug":"Q-A","permalink":"https://whitetail-o.github.io/tags/Q-A/"}]},{"title":"Games202-7 A Glimpse of Industrial Solution","slug":"Games202_07_A Glimpse of Industrial Solution","date":"2023-02-10T13:42:10.000Z","updated":"2023-02-12T13:14:21.372Z","comments":true,"path":"2023/02/10/Games202_07_A Glimpse of Industrial Solution/","link":"","permalink":"https://whitetail-o.github.io/2023/02/10/Games202_07_A%20Glimpse%20of%20Industrial%20Solution/","excerpt":"a). Anti-Aliasinga.1). Temporal Anti-Aliasing (TAA) 复用先前帧的样本，假设画面不动，就可在单个像素内随时间规律移动感知点，进行（加权）平均； 为何规律移动感知点： 随机采样会引入高频噪声； 如画面移动，则和频域降噪相同，使用Motion vector找到对应像素，再规律移动感知点。同时也可引入Clamp和Detection的操作； a.2). MSAA vs. SSAASSAA： 相当于用更大分辨率渲染后降采样，做2倍的SSAA，相当于一个像素做4次shading； 质量最好，但是性能开销大； MSAA： 在一个像素内，同一个图元只着色一次；(如图，0、2、3为图元A，着色一次(左边的绿点)；1为图元B，着色一次；) 因此，MSAA会维护一张表，表中记录当前感知点记录的color(albedo?) 和 深度 在像素间复用样本； a.3). Image Based Anti-Aliasing Solution a.4). Note G-buffers一定不能做抗锯齿","text":"a). Anti-Aliasinga.1). Temporal Anti-Aliasing (TAA) 复用先前帧的样本，假设画面不动，就可在单个像素内随时间规律移动感知点，进行（加权）平均； 为何规律移动感知点： 随机采样会引入高频噪声； 如画面移动，则和频域降噪相同，使用Motion vector找到对应像素，再规律移动感知点。同时也可引入Clamp和Detection的操作； a.2). MSAA vs. SSAASSAA： 相当于用更大分辨率渲染后降采样，做2倍的SSAA，相当于一个像素做4次shading； 质量最好，但是性能开销大； MSAA： 在一个像素内，同一个图元只着色一次；(如图，0、2、3为图元A，着色一次(左边的绿点)；1为图元B，着色一次；) 因此，MSAA会维护一张表，表中记录当前感知点记录的color(albedo?) 和 深度 在像素间复用样本； a.3). Image Based Anti-Aliasing Solution a.4). Note G-buffers一定不能做抗锯齿 b). Temporal Super Resolution 通过深度学习告诉管线，如何使用历史帧的信息； c). Deferred Shading(详见百人计划图形3.4 延迟渲染管线)主要解决大量光照渲染和overdraw（传统渲染如果从后往前渲染，那所有fragment都会被shaded一次）的方案。 可以将延迟渲染(Deferred Rendering)理解为先将所有物体都先绘制到屏幕空间的缓冲（即G-buffer，Geometric Buffer，几何缓冲区）中，再逐光源对该缓冲进行着色的过程，从而避免了因计算被深度测试丢弃的片元的着色而产生的不必要的开销。也就是说延迟渲染基本思想是，先执行深度测试（应该也包括其他测试），再进行着色计算，将本来在物空间（三维空间）进行光照计算放到了像空间（二维空间）进行处理。 对应于正向渲染O(m*n)的 复杂度，经典的延迟渲染复杂度为O(n+m)。 c.1). 流程 可以将延迟渲染理解为两个Pass的过程： 几何处理阶段(Geometry Pass)。这个阶段中，我们获取对象的各种几何信息（Position、Normal、Albedo、Specular等），并将第二步所需的各种数据储存（也就是渲染）到多个G-buffer中； 由于有深度测试，所以最终写入G-buffer中的，都是离摄像机最近的片元的集合属性，这就意味着，在G-buffer中的片元必定要进行光照计算。 光照处理阶段(Lighting Pass)。在这个pass中，我们只需渲染出一个屏幕大小的二维矩形，使用第一步在G-buffer中存储的数据对此矩阵的每一个片段计算场景的光照；光照计算的过程还是和正向渲染以前一样，只是现在我们需要从对应的G-buffer而不是顶点着色器(和一些uniform变量)那里获取输入变量了。 c.2). 延迟渲染的优缺点 优点： Complexity: O(#fragment #light) -&gt; O(#vis. frag. #light) 只渲染可见的像素，节省计算量 用更少的shader 对后处理支持良好（例如深度信息：直接拿G-buffer中的就行。而前向渲染需要单独Pass再渲染一张深度图） 在大量光源的场景优势尤其明显； 缺点： 内存开销较大，且占用了大量的显存带宽； 需要传递G-Buffer； 有时需要用到G-Buffer的信息，如深度图做后处理，那将不会进行Clear； 只能用同一套Lighting Pass； 对透明物体的渲染存在问题。在这点上需要结合正向渲染进行渲染； 对多重采样抗锯齿（MultiSampling Anti-Aliasing, MSAA）等硬件抗锯齿的支持不友好，主要因为需开启MRT； MSAA是依赖于子像素，而Deffered shading处在光栅化之后（单个像素内值相等），传输数据是通过G-Buffer； 但可使用TAA 问FXAA、FSAA与MSAA有什么区别？效果和性能上哪个好？ - 文刀秋二的回答 - 知乎 https://catlikecoding.com/unity/tutorials/rendering/part-13/ d). Tiled Shading 基于Deferred Shading 并不是所有光源都会对Tile有贡献 Complexity: O(#vis. frag. #light) -&gt; O(#vis. frag. avg #light per tile) e). Clustered Shading(群组渲染) 在Tiled Shading的基础上再对Depth分段； Complexity: O(#vis. frag. avg #light per tile) -&gt; O(#vis. frag. avg #light per cluster) f). Level of Detail Solutions cascaded: 级联 生成时，不同Level之间有一定重叠，用于过渡时Lerp g). Global Illumination Solutions","categories":[{"name":"Games202","slug":"Games202","permalink":"https://whitetail-o.github.io/categories/Games202/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://whitetail-o.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"Games202","slug":"Games202","permalink":"https://whitetail-o.github.io/tags/Games202/"}]},{"title":"Games202-6 Real-time Ray-Tracing","slug":"Games202_06_Real-time Ray-Tracing","date":"2023-02-10T12:42:10.000Z","updated":"2023-02-12T13:14:18.809Z","comments":true,"path":"2023/02/10/Games202_06_Real-time Ray-Tracing/","link":"","permalink":"https://whitetail-o.github.io/2023/02/10/Games202_06_Real-time%20Ray-Tracing/","excerpt":"a). IntroductionReal-time Ray-Tracing vs. Ray-Tracing: Real-time Ray-Tracing == 1/few sample per pixel(SPP) Key technology: Denoising(降噪) 一个光路样本（1 SPP path tracing）： 第一步是Rasterization，而不是Ray的原因： 从摄影机发出经过各个像素的光线，即等同于进行一次光栅化，找到Primary hitpoint 传统的降噪方式不是效果不好，就是太慢或不靠谱 b). Temporal denoising(时域降噪) Key idea: 复用前面已经降噪过的一帧； 使用motion vector来找到先前的位置； 本质上是提高采样率； b.1). G-Buffer b.2). Back Projection Key idea：不同帧之间相同的点，意味着有着相同的世界位置（如不移动）或模型空间位置； How： 如果世界坐标 $s$ 存在于G-Buffer中，即可直接使用； 否则，$s = M^{-1}V^{-1}P^{-1}E^{-1}x$ （$E$ 为视口变换，即NDF到Viewport/Screen） 运动（Motion）情况已知，$s’ = T^{-1} s$，$s’$ 为运动前的位置，$T$ 为运动的矩阵 在 $i-1$ 帧，$s$ 对应的屏幕空间位置为 $x’=P’V’M’s’$","text":"a). IntroductionReal-time Ray-Tracing vs. Ray-Tracing: Real-time Ray-Tracing == 1/few sample per pixel(SPP) Key technology: Denoising(降噪) 一个光路样本（1 SPP path tracing）： 第一步是Rasterization，而不是Ray的原因： 从摄影机发出经过各个像素的光线，即等同于进行一次光栅化，找到Primary hitpoint 传统的降噪方式不是效果不好，就是太慢或不靠谱 b). Temporal denoising(时域降噪) Key idea: 复用前面已经降噪过的一帧； 使用motion vector来找到先前的位置； 本质上是提高采样率； b.1). G-Buffer b.2). Back Projection Key idea：不同帧之间相同的点，意味着有着相同的世界位置（如不移动）或模型空间位置； How： 如果世界坐标 $s$ 存在于G-Buffer中，即可直接使用； 否则，$s = M^{-1}V^{-1}P^{-1}E^{-1}x$ （$E$ 为视口变换，即NDF到Viewport/Screen） 运动（Motion）情况已知，$s’ = T^{-1} s$，$s’$ 为运动前的位置，$T$ 为运动的矩阵 在 $i-1$ 帧，$s$ 对应的屏幕空间位置为 $x’=P’V’M’s’$ b.3). issues Failure case 1: 切换场景 burn-in period(即需要一定时间积累降噪质量足够好的帧，如UE中的burn-in) Failure case 2: walking backwards in a hallway screen space issue（当前帧出现上一帧屏幕外的信息） Failure case 3: suddenly appearing background disocclusion（上一帧被遮挡的物体，当前帧未被遮挡） 可能造成拖尾（lagging） b.4). Adjustments to Temp. Failure \\bar{C}^{(i)}=\\alpha \\bar{C}^{(i)}+(1-\\alpha) C^{(i-1)} Clamping Clamp上一帧的信息，使其接近当前帧。即Clamp $C^{(i-1)}$ Detection(即不符合要求时，不使用Temp. denoising) Use e.g. object ID to detect temporal failure（ID通道） 调整$\\alpha$，上一帧不可靠时，调高$\\alpha$ Problem：重新引入更多噪声； 可能需要增强空域降噪； b.5). More Temporal Failure Detaching/lagging shadows(阴影拖尾) Temporal failure can also happen in shading 如反射滞后； c). Implementation(实现)eg. Gaussian filter 滤波核可以不归一化，但对于结果需要归一化； c.1). Bilateral filtering(双边滤波)观察： 高斯模糊会将边界模糊，但我们需要保留边界； 边界 = 颜色差异大 目的： 模糊同时保留边界； 当像素$j$ 和像素$i$ 颜色差异大时，$j$贡献变少（权重变小） 像素$a$ 位置为$(i,j)$，像素$b$ 位置为$(k,l)$； $I(i,j)$ 表示$(i,j)$位置的像素值； $\\sigma$ 控制对应项的作用范围，其值越大，对应项的局部影响范围就越大，分子变化影响越小 类似于两个不同形式的高斯核相乘（指数相加），即两个标准（距离，颜色），2 metrics 可以根据需求调整，如较为看重color dist. 对weight的影响，就可以将第二项的2 调为 1； c.2). Joint Bilateral filtering(联合双边滤波)观察： Gaussian filtering: 1 metric (distance) Bilateral filtering: 2 metrics (position dist. &amp; color dist.) 因此，我们可以考虑更多的标准（metric），丰富滤波核，进行滤波（Key idea） 定义：Joint Bilateral filtering是一系列考虑更多标准的滤波方法。 Note: c.2.1). Example c.2). Large Filters对于大的滤波核，性能开销会非常大(e.g. 64x64) Solution 1: Separate Passes 将NxN大小的2D高斯核，拆分为 1xN 和 Nx1 的1D高斯核。通过两个Pass进行滤波；（注意： 并不是所有滤波核都可拆分） 原因： w(i, j, k, l)=\\exp \\left(-\\frac{(i-k)^{2}+(j-l)^{2}}{2 \\sigma_{d}^{2}}\\right)2D高斯核的形式是可拆分的，如下： G_{2D}(x, y) = G_{1D}(x) \\cdot G_{1D}(y) 理论上，双边滤波/联合双边滤波是不可拆分的（实现上，只要滤波核不特别大，如超过32x32，就可采用拆分方法） Solution 2: Progressively Growing Sizes(逐步增加尺寸)介绍： 逐Pass增加filter (间隙的)size，类似空洞卷积。第一次间隙为0，第二次间隙为1…… 原因： 逐步增加尺寸： 逐步减小信号的最高频率； 增加采样间隙： 降低采样频率，频谱搬移距离逐渐减小； 逻辑： 减少信号高频部分，并增大采样间隙（频谱搬移，将信号左边界搬移到有边界），使得不会产生信号混叠； d). Outlier Removal(and temporal clamping)d.1). IntroductionOutlier: 场景中一些特别亮的噪声，即萤火虫噪声； 出现原因： 蒙特卡洛积分时，由于采样率不足，会出现特别亮和特别暗的点； 无法用滤波解决，滤波后仍会存在，甚至从一点变为亮的色块（blocky） 解决方法： Outlier removal(clamp) Outlier removal: 应用时间： 滤波之前（但会打破能量守恒，如不想打破就得提高采样率） d.2). 实现 $\\mu$: 均值 $\\sigma$: 标准差 即将各个点Clamp到一定范围内（如担心光源被clamp掉，可以先不Render光源。Outlier removal之后再加上光源） 之前提到的Temporal Clamping同理： 将上一帧Clamp向（经过空域降噪）这一帧 e). SVGF(Spatiotemporal Variance-Guided Filtering) 降噪效果好，但仍然有拖影、反射滞后等问题； 在Overblue和更多的noise之间，选择了Overblur e.1). SVGF — Joint Bilateral Filteringe.1.1). Depth A、B在同平面深度却差异很大，使得互相之间贡献少。因此，在分母中引入梯度$\\nabla z(p)$ ，该梯度为深度在对应点法线方向的变化率（注意：梯度为向量，其方向为法线方向；）。 当平面几乎垂直于屏幕时，$\\nabla z(p)$ 变大，使得深度差异对权重的影响变小； e.1.2). Normal 应使用几何法线，而不使用经过法线扰动的Normal e.1.3). Luminance(grayscale color value) 使用亮度值； Variance: Step1: 计算空域中7x7的方差； Step2: 通过motion vectors在时域上平均（类似时域降噪）； Step3: 对平均后的结果再在空域上3x3的范围内平均； 即，spatial filter —&gt; temporal filter —&gt; spatial filter f). RAE(Recurrent AutoEncoder) 一种结构，对Monte carlo路径追踪得到的结果进行reconstruction-对RTRT做滤波。 后期处理，把noise的图变clean。 使用G-buffers 神经网络会自动将temporal的结果累积起来 g). Comparison","categories":[{"name":"Games202","slug":"Games202","permalink":"https://whitetail-o.github.io/categories/Games202/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://whitetail-o.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"Ray-Tracing","slug":"Ray-Tracing","permalink":"https://whitetail-o.github.io/tags/Ray-Tracing/"},{"name":"Games202","slug":"Games202","permalink":"https://whitetail-o.github.io/tags/Games202/"},{"name":"Denoise","slug":"Denoise","permalink":"https://whitetail-o.github.io/tags/Denoise/"}]},{"title":"Games202-5 Real-time Physically-based Materials","slug":"Games202_05_Real-time Physically-based Materials","date":"2023-02-10T10:42:10.000Z","updated":"2023-02-12T13:17:58.918Z","comments":true,"path":"2023/02/10/Games202_05_Real-time Physically-based Materials/","link":"","permalink":"https://whitetail-o.github.io/2023/02/10/Games202_05_Real-time%20Physically-based%20Materials/","excerpt":"Q1：在金属或高光工作流中，对于非导体材质（电介质）默认其零度菲涅尔值$R_0$ 为4%，那么按PBR来，他怎么会有颜色呢；还是说非导体的albedo就是$R_0$ ? 按作业中来好像albedo就是 $R_0$ ，后续还得深挖一下； Q2：Jacobian 项，方向导数需要去了解更多 a). Introduction 尽管实时渲染中的PBR，不一定完全基于物理。如Disney principled BRDFs (artist friendly but still not PBR) b). Microfacet BRDF 菲涅尔项； Shadowing-masking term 考虑微表面之间的遮挡和阴影； 当光线几乎平行与表面入射时(Grazing angle)，微表面之间遮挡变多 Disterbution of normals(法线分布)","text":"Q1：在金属或高光工作流中，对于非导体材质（电介质）默认其零度菲涅尔值$R_0$ 为4%，那么按PBR来，他怎么会有颜色呢；还是说非导体的albedo就是$R_0$ ? 按作业中来好像albedo就是 $R_0$ ，后续还得深挖一下； Q2：Jacobian 项，方向导数需要去了解更多 a). Introduction 尽管实时渲染中的PBR，不一定完全基于物理。如Disney principled BRDFs (artist friendly but still not PBR) b). Microfacet BRDF 菲涅尔项； Shadowing-masking term 考虑微表面之间的遮挡和阴影； 当光线几乎平行与表面入射时(Grazing angle)，微表面之间遮挡变多 Disterbution of normals(法线分布) b.1). The Fresnel Term 本质上是考虑能量的吸收和反射（即考虑BRDF就会有因为颜色的合理的能量损失） b.2). Normal Distribution Function(NDF) NDF从简单（如Gloosy）变为复杂（如Diffuse），就类似于把微表面高度场拉大； 类型： Beckmann, GGX, etc. Detailed models [Yan 2014, 2016, 2018, …] b.2.1). Beckmann NDFBeckmann NDF: 和高斯函数相似 Project Solid angel上积分为1 定义在Slope space（坡度空间） 原因： 在Slope space（法线交点处切线平面）中Support无限大，任意位置对应的夹角不会超过90°，保证微表面不会朝下 D(h)=\\frac{e^{-\\frac{\\tan ^{2} \\theta_{h}}{\\alpha^{2}}}}{\\pi \\alpha^{2} \\cos ^{4} \\theta_{h}} $\\alpha$ ：Roughness的平方 $\\theta_{h}$ ：半角向量和（宏观）法线的夹角 b.2.2). GGX (or Trowbridge-Reitz, TR) Long tail: 使得光线过度更为自然，如高光过渡柔和 b.2.3). GGGX(GTR) b.3). Shadowing-Masking Term Why is it important? 如没$G$ 项，在grazing angle时，物体表面会发亮； b.3.1). The Smith shadowing-masking term 假设： Shadow和Masking无关，即 b.3.2). Issues(Missing energy) 原因：由于Shadowing-masking只考虑了一次弹射，对于多次弹射的能量直接舍去，造成能量损失； 做法： Accurate methods exist [Heitz et al. 2016] 主要用于离线渲染，对于RTR过慢； The Kulla-Conty Approximation Being occluded == next bounce happening 构造函数去补偿损失的能量； 求得的BRDF+原BRDF，即可； b.3.3). Kulla-Conty Approximation {L}_{o}(\\omega_{o})=\\int_{\\Omega^{+}}{L}_{i}(\\omega_{i})f_{r}(\\omega_{i},\\omega_{o})cos\\theta_i\\,\\mathrm{d}\\omega_{i} 通过对$\\mathrm{d}\\omega_{i}$ 换元（即立体角） 得到： 此处假设各处入射Radiance（$L_i$） 均匀为1，因此出射的Radiance也应均匀为1； 此处假设BRDF的菲涅尔项为1，即无颜色，能量不损失。后续再考虑颜色（？待验证） 该函数是关于出射角的俯仰角$\\theta_o$ 的函数（和方位角无关是因为假设为各项同性） Key idea: 通过积分可得需要补偿的能量为 $1 - E(\\mu_{o})$； 该函数是关于出射角的俯仰角$\\theta_o$ 的函数（和方位角无关是因为假设为各项同性） 考虑到对称性质（reciprocity），即入射方向和出射方向互换，Radiance不变，补偿项的BRDF形式为$c(1 - E(\\mu_{i}))(1 - E(\\mu_{o}))$，其中 $c$ 为常数； 补偿项的BRDF（带cos） - $c(1 - E(\\mu_{i}))(1 - E(\\mu_{o}))$ 常数 $c = \\frac{1}{\\pi(1-E_{avg})}, E_{avg}=2\\int_0^1E(\\mu)\\mu\\, \\mathrm{d}\\mu$ 补偿项即为： $c$ 推导：即让补偿项的BRDF$f_{ms}(\\mu_{o},\\mu_{i})$ 的积分结果为 $1 - E(\\mu_{o})$ 预计算 对于$E_{avg}=2\\int_0^1E(\\mu)\\mu\\, \\mathrm{d}\\mu$ ，只需要得知其Roughness就可求出对应的结果，储存在1D table中； NDF等使用的模型已知； 对于$E(\\mu)$ 得知其roughness(确定函数) 和 $\\mu$ (确定函数自变量)，即可求出对应结果，储存在2D table中； Result. 原BRDF+(uncolored)补偿项BRDF &#8617; Color(energy loss) 有颜色( vec3的$R_0$项 )，意味着能量被吸收，也是能量合理的损失； 之前我们做了，不损失能量，无颜色的情况。之后，我们需要计算由于颜色的能量损失； 定义平均菲涅尔 $F_{avg}$ ，表示能量参与弹射后，平均反射出多少；（剩下的被吸收） 之前定义了 $E_{avg}$ ，表示每次弹射后，平均有多少能量被看见（即不参与之后的弹射） $F_{avg}$ 、$E_{avg}$ 都是三维的向量； 由此可得， $(1-E_{avg})$ 表示上一次弹射后，被遮挡未出射的能量； 等比数列求和； 求得的color term直接乘上uncolored additional BRDF即可； Result with color. 原BRDF + colored补偿项BRDF(color term * uncolor补偿项BRDF) &#8617; c). Linearly Transformed Cosines(LTC, 线性变换余弦)c.1). Introduction作用： Solves the shading of microfacet models 主要用于GGX，当然其他NDF也适用； No shadows Under polygon shaped lighting(多边形光源)，解决多边形光源的光照积分问题； Key idea: 对于任意一个球面分布函数，一定可以通过一个线性变换矩阵将其变化到另外一个球面分布函数(对于任意2D(二维，出射方位角和俯仰角) BRDF lobe can be transformed to a cosine) 光源的形状也可以被变换，且积分结果相同； 变换后的积分有解析解； Ref: [1] Real-Time Polygonal-Light Shading with Linearly Transformed Cosines [2] Real-Time Polygonal-Light with LTC-zhihu [3] 物理光源：Linearly Transformed Cosines [4] Eric Heitz’s Research Page [5] Global Illumination_Linearly Transformed Cosines (LTC) [6] 图形学基础|基于LTC的面光源渲染 $J$ 是雅可比行列式，更进一步的可见Ref，后续论文复现后再进一步补充此处笔记； LTC介绍. 来源Ref[3] &#8617; LTC拟合BRDF. 来源Ref[6] &#8617; d). Disney’s Principled BRDFd.1). Introduction微表面BRDF的缺点 微表面模型不擅长表示真实（基于物理）的材质； 如：Diffuse的情况不好表示，多层材质也难以表示； 微表面模型“are not artist friendly” 如： 复折射率（complex index of refraction）,$n-ik$（详见PBR-White-Paper） 需求： Artist friendly，但一定程度上physically-based 设计原则： 应该使用直观的而不是物理的参数； 使用的参数尽可能少； 参数应该在0~1； 参数在必要时允许超出0~1的范围； 参数的所有组合的外观都应该是合理、稳定的； Disney’s Principled BRDF. A table showing the effects of individual parameters &#8617; sheen: 类似天鹅绒，材质表面有一层绒毛，使得其在grazing angle有雾化的效果 sheenTint: 绒毛的颜色 clearcoat: 类似清漆（当时做雨滴就用的是clearcoat） d.2). Pros and Cons 易于理解/控制 可表现大量材质； 实现复杂，基本是去拟合PBR材质； 不基于物理，但视觉上大部分是符合的； 参数空间巨大；","categories":[{"name":"Games202","slug":"Games202","permalink":"https://whitetail-o.github.io/categories/Games202/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://whitetail-o.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"Materials","slug":"Materials","permalink":"https://whitetail-o.github.io/tags/Materials/"},{"name":"Games202","slug":"Games202","permalink":"https://whitetail-o.github.io/tags/Games202/"},{"name":"PBR","slug":"PBR","permalink":"https://whitetail-o.github.io/tags/PBR/"}]},{"title":"Games202-5 Non-Photorealistic Rendering (NPR)","slug":"Games202_05_Non-Photorealistic Rendering (NPR)","date":"2023-02-10T09:42:10.000Z","updated":"2023-02-12T13:17:53.768Z","comments":true,"path":"2023/02/10/Games202_05_Non-Photorealistic Rendering (NPR)/","link":"","permalink":"https://whitetail-o.github.io/2023/02/10/Games202_05_Non-Photorealistic%20Rendering%20(NPR)/","excerpt":"a). Photorealistic vs. Non-PhotorealisticPhotorealistic Rendering Non-Photorealistic Rendering 描边 色块（量化Quantization 颜色） 风格化阴影 b). Outline Rendering 边界（B, 属于剪影的线，但只属于一个面） 折痕（C） 材质的边界（M） 轮廓（CS, 属于剪影的线，且有多个面共享）","text":"a). Photorealistic vs. Non-PhotorealisticPhotorealistic Rendering Non-Photorealistic Rendering 描边 色块（量化Quantization 颜色） 风格化阴影 b). Outline Rendering 边界（B, 属于剪影的线，但只属于一个面） 折痕（C） 材质的边界（M） 轮廓（CS, 属于剪影的线，且有多个面共享） shading 法线和摄影机夹角：即轮廓都是grazing angle Geometry Image Soble算子做卷积 综合多种信息，如法线和深度等 c). Color blockers d). Strokes Surface Stylization","categories":[{"name":"Games202","slug":"Games202","permalink":"https://whitetail-o.github.io/categories/Games202/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://whitetail-o.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"Materials","slug":"Materials","permalink":"https://whitetail-o.github.io/tags/Materials/"},{"name":"Games202","slug":"Games202","permalink":"https://whitetail-o.github.io/tags/Games202/"},{"name":"NPR","slug":"NPR","permalink":"https://whitetail-o.github.io/tags/NPR/"}]},{"title":"Games202-4 Real-time Global Illumination(Screen Space)","slug":"Games202_04_Real-time Global Illumination(Screen Space)","date":"2023-02-10T08:52:10.000Z","updated":"2023-02-12T13:16:48.370Z","comments":true,"path":"2023/02/10/Games202_04_Real-time Global Illumination(Screen Space)/","link":"","permalink":"https://whitetail-o.github.io/2023/02/10/Games202_04_Real-time%20Global%20Illumination(Screen%20Space)/","excerpt":"a). Screen Space Ambient Occlusion(SSAO)a.1). Introduction SSAO: 在屏幕空间中，对全局光照的近似； Key idea: 假设各方向间接光照的强度相同（类似于Phong模型中的Ambition light） 考虑不同着色点，有不同的Visibility 假设材质为diffuse 假设间接光照来自于比较远的地方。因此，橙色的光线，即一定范围内不被遮挡的光线会贡献间接光。（如假设间接光来自比较近的地方，则是红色射线方向贡献间接光） a.2). Theory 通过不等式，拆分渲染方程为： $k_A$ 项代表不同方向Visibility的（加权）平均 黄色框可用一个Constant color表示 假设了间接光 $L_i^{indir}$ 各方向强度相同，因此为常数； 假设了材质为Diffuse，因此BRDF为常数； $cos\\theta$ 半球积分为$\\pi$ 同样，因为黄色框，即$g(x)$为常数，其Support极小。因此，应用该不等式是精确的 A deeper understanding 1: A deeper understanding 2:（为什么Visibility项会有$cos\\theta$） 加上 $cos\\theta$ 的含义是把积分域从单位半球投影到单位圆上(Projected solid angle)； 为什么要这么做呢？","text":"a). Screen Space Ambient Occlusion(SSAO)a.1). Introduction SSAO: 在屏幕空间中，对全局光照的近似； Key idea: 假设各方向间接光照的强度相同（类似于Phong模型中的Ambition light） 考虑不同着色点，有不同的Visibility 假设材质为diffuse 假设间接光照来自于比较远的地方。因此，橙色的光线，即一定范围内不被遮挡的光线会贡献间接光。（如假设间接光来自比较近的地方，则是红色射线方向贡献间接光） a.2). Theory 通过不等式，拆分渲染方程为： $k_A$ 项代表不同方向Visibility的（加权）平均 黄色框可用一个Constant color表示 假设了间接光 $L_i^{indir}$ 各方向强度相同，因此为常数； 假设了材质为Diffuse，因此BRDF为常数； $cos\\theta$ 半球积分为$\\pi$ 同样，因为黄色框，即$g(x)$为常数，其Support极小。因此，应用该不等式是精确的 A deeper understanding 1: A deeper understanding 2:（为什么Visibility项会有$cos\\theta$） 加上 $cos\\theta$ 的含义是把积分域从单位半球投影到单位圆上(Projected solid angle)； 为什么要这么做呢？ a.2.1). Simpler understanding 那么，我们怎么算 $k_A$ 项（不同方向Visibility的（加权）平均）呢？这就是AO算法实现的，如SSAO； 在计算AO时，我们计算的Visibility是限制在一定半径内的一个半球的局部遮挡。如在封闭的区域，如室内，如不限制半径，那Visibility将会为0。因此需要限制半径。 a.3). 实现 屏幕空间环境光遮蔽，全称Screen Space Ambient Occlusion，一种用于计算机图形中实时实现近似环境光遮蔽效果的渲染技术。通过获取像素的深度缓冲、法线缓冲以及像素坐标来计算实现，来近似的表现物体在间接光下产生的阴影。 做法总览（详情见百人计划图形4.2 SSAO）： 在法向半球内随机采样，采样点 $p$ 的深度$Z_p$与 点$p$ 在屏幕空间中对应位置 点$p’$ 的Z-Buffer中的深度$Z_{p’Zbuffer}$比较。 如 $Z_p&gt;Z_{p’Zbuffer}$，说明该采样点被遮蔽（红点），Visibility为0； 如 $Z_p&lt;Z_{p’Zbuffer}$，说明该采样点可见（绿点），Visibility为1； Cons： 由于是通过屏幕空间像素坐标和Z-Buffer取近似场景，只模拟了离屏幕最近的表面，对于一些点（如箭头所指的红点）的Visibility会误判；（从着色点看向该点可以看到，但SSAO中却将该点视为被遮蔽） 没有$cos\\theta $ 项的加权，因此在物理上是不准确的； [^SSAO]: 经过滤波后的SSAO $$ k_&#123;A&#125;=\\frac&#123;\\int_&#123;\\Omega^&#123;+&#125;&#125; V\\left(\\mathrm&#123;p&#125;, \\omega_&#123;i&#125;\\right) \\cos \\theta_&#123;i&#125; \\mathrm&#123;~d&#125; \\omega_&#123;i&#125;&#125;&#123;\\pi&#125; $$ - 采用了$cos\\theta $ 项的加权的算法：Horizon based ambient occlusion(HBAO) 由于SSAO中未考虑深度比较时采样点深度和Z-Buffer深度的差值，造成相距比较远的物体之间也会存在AO (HBAO解决了) b). Screen Space Directional Occlusion(SSDO)b.1). Introduction An imporovement over SSAO; 考虑了更准确的间接光照（不再假设各方向的间接光照相同） Key idea: 考虑了更准确的间接光照 使用已知的间接光源信息 如RSM得到的Secondary Light Source 的flux等； 效果： 间接光照更为准确，出现了color blooding 做法：（与Path Tracing非常相似） 着色 $p$点 时，发射随机光线； 如未被遮挡（无交点）： 该点受直接光照影响（如Ambient Light）； 如被遮挡（有交点）： 该点受间接光照影响； b.2). 实现 与SSAO相比： SSAO为被遮挡的光线的方向为间接光照贡献方向，SSDO则是被遮挡的光线方向为间接光照贡献方向； （SSAO）假设间接光照来自于比较远的地方。因此，橙色（被红圈圈起来的）的光线，即一定范围内不被遮挡的光线会贡献间接光。（如假设间接光来自比较近的地方（SSDO），则是红色射线（被橙圈圈起来的）方向贡献间接光） 间接光照的计算则可采用RSM、或者LPV、VXGI等； 具体做法： 和SSAO类似，在着色点P周围，一定半径的法向半球内进行随机给出采样点（A、B、C、D……），并和Z-Buffer中的深度进行比较； 如$Z_{sample} &gt; Z_{sample\\, Z-buffer}$ ，说明该点（A、B、D）被遮挡，该点则会对点P贡献间接光； 判断： 贡献间接光的Patch的方向是否会能贡献到，如点A ，${Normal_A}\\cdot \\vec{AP} &lt; 0$ ，则该点不贡献间接光； Reflector的反射方向只在法向半球上，法向半球的方向覆盖不到的Shading Point自然不受该Reflector的影响 如$Z_{sample} &lt; Z_{sample\\, Z-buffer}$ ，说明该点（A、B、D）未被遮挡，该点则不会对点P贡献间接光，而是贡献直接光（Ambition Light）； 缺点： 如上图最右 b.3). Issues 只能计算小范围的AO； 是通过采样点深度和Z-buffer比较得出Visibility，而不是从P点出射光线计算交点，导致Visibility不精准； 屏幕空间的通病： 失去了屏幕中未被显示（如屏幕外）的表面的信息； 屏幕空间只能表现场景最表面(Depth最小)的一层“壳”； c). Screen Space Reflection(SSR)c.1). IntroductionWhat is SSR? Still, one way to introduce Global Illumination in RTR; 执行上为光线追踪； 光线追踪的求交并不要求3D图元，而是屏幕空间的一层“壳”（通过Z-Buffer还原的场景） Two fundamental tasks of SSR： 求交：任何光线和场景； 着色：交点对Shading point的贡献； 效果： 可实现Specular reflection和Gloosy reflection； 对于Specular只用追踪镜面反射方向即可； 对于Gloosy知道BRDF后需追踪入射方向的Lobe； c.2). 实现 Two fundamental tasks of SSR： 求交：任何光线和场景； 着色：交点对Shading point的贡献； c.2.1). Intersection（求交） 使用光线步进（Raymarch），那么如何确定步进的步长？ Hierarchical tracing 不想一层一层步进，而是允许时步长变大； Hierarchical tracing Step1: Generate Depth Mip-Map(使用最小池化，而不是平均) 取最小： 如2x2的像素中，取最小深度值作为下一层该位置的深度； 最小池化构造出类似与KD-tree的结构； 逻辑： 取最小后，如果光线不和父（更大的）节点相交，那就不会和子节点相交； P-Code 开始在Mip0层步进 没交点则进入下一层Mip（父节点）； 有交点则进入上一层Mip（子节点），并在交点对应位置的子节点继续求交； 直到找到Mip0层的交点，结束循环；（演示看PPT） c.2.2). Shading Shading过程和Path tracing相似； 假设： Reflectors(反射物)/ Secondary light source是Diffuse的 原因： 生成Shaded场景时，只知道屏幕空间下一个点的Radiance（即Shading Point到Camera的Radiance）。如假设Reflector为Diffuse，那么该点的$L_i$就为framebuffer中的颜色； c.2.3). 效果 可实现锐利或模糊的反射； Contact hardening（接触的地方反射较为锐利，类似PCSS） Specular elongation 类似雨天红绿灯反射垂直拉长的效果； 给定视角后，各项同性的法线分布，造成的反射Lobe为垂直方向椭圆的Lobe； 每个像素不同的Roughness和Normal c.3). Issues Edge Cutoff 缓解方法：根据反射长度进行Fade off d). Pros And Cons","categories":[{"name":"Games202","slug":"Games202","permalink":"https://whitetail-o.github.io/categories/Games202/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://whitetail-o.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"Games202","slug":"Games202","permalink":"https://whitetail-o.github.io/tags/Games202/"},{"name":"GI","slug":"GI","permalink":"https://whitetail-o.github.io/tags/GI/"}]},{"title":"Games202-4 Real-time Global Illumination(in 3D)","slug":"Games202_04_Real-time Global Illumination(in 3D)","date":"2023-02-10T08:42:10.000Z","updated":"2023-02-12T13:16:55.513Z","comments":true,"path":"2023/02/10/Games202_04_Real-time Global Illumination(in 3D)/","link":"","permalink":"https://whitetail-o.github.io/2023/02/10/Games202_04_Real-time%20Global%20Illumination(in%203D)/","excerpt":"a). Introduction In RTR, people seek simple and fast solutions to one bounce indirect illumination Primary LIght Source（真正的光源，太阳） Secondary Light Source(次级光源，Q点) 观察（要得到$p$点的间接光照我们需要做什么）： 得到Secondary light source（哪些点被光源照射到） 方法： Shadow Mapping 得到各个Secondary light source对 $p$点 Radiance的贡献 方法： 解渲染方程 以下是实时渲染中常用的在3D空间中（意为渲染效果不取决于相机位置/屏幕空间）的GI方法（主要针对one bounce indirect illumination）： Reflective Shadow Maps (RSM) Light Propagation Volumes (LPV) Voxel Global Illumination (VXGI) b). Reflective Shadow Maps (RSM) 得到Secondary light source（哪些点被光源照射到） Shadow map中每一个Texel都是一个作为Secondary light sourc的面片（Surface patch） Shadow map做阴影中是光源视角的$Depth$，和相机视角的比较；这里是光源视角的$Depth$和 点$p$ 视角比较 得到各个Secondary light source对 $p$点 Radiance的贡献 但是，对于不同的 点$p$ 次级光源入射方向是不一定的。即，即使观察角度固定，同一个Shadow map中的Surface patch，对不同的 $p$ 贡献不同； 假设： 次级光源均为Diffuse（观察角度固定，同一个次级光源对不同 点$p$ 的贡献相同） Therefore, outgoing radiance is uniform toward all directions b.1). 得到各个Secondary light source对 $p$点 Radiance的贡献 \\begin{aligned} L_{o}\\left(\\mathrm{p}, \\omega_{o}\\right) & =\\int_{\\Omega_{\\mathrm{patch}}} L_{i}\\left(\\mathrm{p}, \\omega_{i}\\right) V\\left(\\mathrm{p}, \\omega_{i}\\right) f_{r}\\left(\\mathrm{p}, \\omega_{i}, \\omega_{o}\\right) \\cos \\theta_{i} \\mathrm{~d} \\omega_{i} \\\\ & =\\int_{A_{\\mathrm{patch}}} L_{i}(\\mathrm{q} \\rightarrow \\mathrm{p}) V\\left(\\mathrm{p}, \\omega_{i}\\right) f_{r}\\left(\\mathrm{p}, \\mathrm{q} \\rightarrow \\mathrm{p}, \\omega_{o}\\right) \\frac{\\cos \\theta_{p} \\cos \\theta_{q}}{\\|q-p\\|^{2}} \\mathrm{~d} A \\end{aligned} 对于每个diffuse reflective patch(点$q$) 点$q$ 的BRDF: $f_{rq} = \\rho/\\pi$ $L_i(q\\rightarrow p) = f_{rq} \\cdot \\frac{\\Phi}{d A}$ ( $\\Phi$ 是光源的辐射通量，将该式带入渲染方程，${d A}$ 被消除) E_{q}(x,n)=\\Phi_{q}\\frac{\\mathrm{max}\\{0,\\langle n_{q}|x-x_{q}\\rangle\\}\\mathrm{max}\\{0,\\langle n|x_{q}-x\\rangle\\}}{||x-x_{q}||^{4}}. ${||x-x_{q}||^{4}}$ 是因为分子上$x-x_{q}$是未归一化的向量； $\\Phi_p$ 为 $f_{rq} \\cdot {\\Phi}$ 将$E_p(x,n)$ 乘上 点$p$ 的BRDF即可得出$L_o$ $V$：Visibility项就不算了 Not all pixels in the RSM can contribute Visibility (难处理，不管了) Orientation（方向，Reflector的反射方向只在法向半球上，法向半球的方向覆盖不到的Shading Point自然不受该Reflector的影响） Distance（只有和Shading Point近的Reflector才做贡献） 假设： 世界坐标下，两点接近 $\\rightarrow$ Shadow Map（世界空间转换到光源空间）中距离比较近，且深度相差不大； 进一步加速（类似于Step 1 and 3 in PCSS），在shading point转换到Shadow Map后对应点$(s,t)$ 的一定范围内，做随机采样 b.2). 光源视角下储存的信息（Shadow Map） 深度 世界坐标 法线 辐射通量（flux） etc. b.3). Pros And Cons Pros: 好写（类似于Shadow Map） Cons: 计算量随光源（Primary Light Source）数量增多线性增加 Visibility无法处理 很多假设：diffuse reflectors, depth as distance, etc. 只能处理次级光源为Diffuse 质量依赖于采样率","text":"a). Introduction In RTR, people seek simple and fast solutions to one bounce indirect illumination Primary LIght Source（真正的光源，太阳） Secondary Light Source(次级光源，Q点) 观察（要得到$p$点的间接光照我们需要做什么）： 得到Secondary light source（哪些点被光源照射到） 方法： Shadow Mapping 得到各个Secondary light source对 $p$点 Radiance的贡献 方法： 解渲染方程 以下是实时渲染中常用的在3D空间中（意为渲染效果不取决于相机位置/屏幕空间）的GI方法（主要针对one bounce indirect illumination）： Reflective Shadow Maps (RSM) Light Propagation Volumes (LPV) Voxel Global Illumination (VXGI) b). Reflective Shadow Maps (RSM) 得到Secondary light source（哪些点被光源照射到） Shadow map中每一个Texel都是一个作为Secondary light sourc的面片（Surface patch） Shadow map做阴影中是光源视角的$Depth$，和相机视角的比较；这里是光源视角的$Depth$和 点$p$ 视角比较 得到各个Secondary light source对 $p$点 Radiance的贡献 但是，对于不同的 点$p$ 次级光源入射方向是不一定的。即，即使观察角度固定，同一个Shadow map中的Surface patch，对不同的 $p$ 贡献不同； 假设： 次级光源均为Diffuse（观察角度固定，同一个次级光源对不同 点$p$ 的贡献相同） Therefore, outgoing radiance is uniform toward all directions b.1). 得到各个Secondary light source对 $p$点 Radiance的贡献 \\begin{aligned} L_{o}\\left(\\mathrm{p}, \\omega_{o}\\right) & =\\int_{\\Omega_{\\mathrm{patch}}} L_{i}\\left(\\mathrm{p}, \\omega_{i}\\right) V\\left(\\mathrm{p}, \\omega_{i}\\right) f_{r}\\left(\\mathrm{p}, \\omega_{i}, \\omega_{o}\\right) \\cos \\theta_{i} \\mathrm{~d} \\omega_{i} \\\\ & =\\int_{A_{\\mathrm{patch}}} L_{i}(\\mathrm{q} \\rightarrow \\mathrm{p}) V\\left(\\mathrm{p}, \\omega_{i}\\right) f_{r}\\left(\\mathrm{p}, \\mathrm{q} \\rightarrow \\mathrm{p}, \\omega_{o}\\right) \\frac{\\cos \\theta_{p} \\cos \\theta_{q}}{\\|q-p\\|^{2}} \\mathrm{~d} A \\end{aligned} 对于每个diffuse reflective patch(点$q$) 点$q$ 的BRDF: $f_{rq} = \\rho/\\pi$ $L_i(q\\rightarrow p) = f_{rq} \\cdot \\frac{\\Phi}{d A}$ ( $\\Phi$ 是光源的辐射通量，将该式带入渲染方程，${d A}$ 被消除) E_{q}(x,n)=\\Phi_{q}\\frac{\\mathrm{max}\\{0,\\langle n_{q}|x-x_{q}\\rangle\\}\\mathrm{max}\\{0,\\langle n|x_{q}-x\\rangle\\}}{||x-x_{q}||^{4}}. ${||x-x_{q}||^{4}}$ 是因为分子上$x-x_{q}$是未归一化的向量； $\\Phi_p$ 为 $f_{rq} \\cdot {\\Phi}$ 将$E_p(x,n)$ 乘上 点$p$ 的BRDF即可得出$L_o$ $V$：Visibility项就不算了 Not all pixels in the RSM can contribute Visibility (难处理，不管了) Orientation（方向，Reflector的反射方向只在法向半球上，法向半球的方向覆盖不到的Shading Point自然不受该Reflector的影响） Distance（只有和Shading Point近的Reflector才做贡献） 假设： 世界坐标下，两点接近 $\\rightarrow$ Shadow Map（世界空间转换到光源空间）中距离比较近，且深度相差不大； 进一步加速（类似于Step 1 and 3 in PCSS），在shading point转换到Shadow Map后对应点$(s,t)$ 的一定范围内，做随机采样 b.2). 光源视角下储存的信息（Shadow Map） 深度 世界坐标 法线 辐射通量（flux） etc. b.3). Pros And Cons Pros: 好写（类似于Shadow Map） Cons: 计算量随光源（Primary Light Source）数量增多线性增加 Visibility无法处理 很多假设：diffuse reflectors, depth as distance, etc. 只能处理次级光源为Diffuse 质量依赖于采样率 c). Light Propagation Volumes(LPV) CryEngine3 里用到了，在孤岛危机里应用 快而且质量好 同样也只能处理次级光源为Diffuse Key idea: 光线直线传播中，Radiance大小不变； Key solution: 通过3D网格(体素，Voxel)，传播Secondary Light Source/dirctly illminated surfaces的Radiance到其他地方； Steps: 生成场景中被直接光照照射到的Radiance point(即Secondary light source)； 将Radiance point注入到体素中； Radiance在体素中传播； 传播稳定后（一般迭代4、5次），通过体素中储存的Radiance进行Shading； c.1). 做法Step 1: Generation 找到Secondary light source 使用Reflective Shadow Maps (RSM)； Step 2: Injection(注入) 预先划分好3D网格（体素）； 对于每一个体素，找到其内部的Secondary light source； 将他们出射的Radiance大小和方向看做是球面函数，投影到2阶（4个）的球谐函数上； Step 3: Propagation(传播) 对于每一个Voxel，都会传播到相邻的6个面（3D，前后左右上下，不会斜向传播），也会接收6个面的Radiance； 接收6个面的Radiance并相加后，再次使用SH表示； 重复上述步骤，直至传播接近稳定（一般整体迭代4-5次） Step4: Rendering 对于每一个着色点，找到他们所处的Voxel； 使用该Voxel中存储的Radiance（from all direction, 是一个SH表达的球面函数），进行Shading； 因为存储的是球面函数形式的Radiance，所以既可以做Diffuse也可以做Gloosy 造成的问题： 由于同一个Voxel中Radiance相同，对于薄的几何体可能造成Light leaking d). Voxel Global Illumination (VXGI) 与RSM两点主要的不同 将被光源直接照射的像素变为带有层级的体素（hierarchical voxels）（即Secondary light source不再看成surface patch，而是hierarchical voxels） 光线传播方式： 从摄像机开始传播，进行锥形传播（Cone tracing，比如光线在Gloosy表面弹射，出射方向为一个锥形），计算锥体相交的Voxel对该点的Radiance贡献； d.1). 做法 Pass 1: from the light 储存每个点的入射Radiance，并储存到对应的Voxel中； Voxel中存储Incident lighting和normal的分布，以便支持Gloosy等材质； 存储Lobe分布的基础：Cone Trace 根据这两个分布，即可得出 出射Radiance 的分布情况； Pass 2: from the camera 对于Gloosy的表面，追踪1个朝向反射方向的圆锥； 根据圆锥的（grow）大小，查询相应层级； 对于Diffuse，追踪多个Cones","categories":[{"name":"Games202","slug":"Games202","permalink":"https://whitetail-o.github.io/categories/Games202/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://whitetail-o.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"Games202","slug":"Games202","permalink":"https://whitetail-o.github.io/tags/Games202/"},{"name":"GI","slug":"GI","permalink":"https://whitetail-o.github.io/tags/GI/"}]},{"title":"待做事项","slug":"Todo","date":"2023-02-08T10:23:22.443Z","updated":"2023-02-08T10:50:43.022Z","comments":true,"path":"2023/02/08/Todo/","link":"","permalink":"https://whitetail-o.github.io/2023/02/08/Todo/","excerpt":"","text":"LTC [ ] LTC解决实时渲染中，多边形光源光照积分问题 Ref: Real-Time Polygonal-Light Shading with Linearly Transformed Cosines Real-Time Polygonal-Light with LTC-zhihu 物理光源：Linearly Transformed Cosines Eric Heitz’s Research Page Global Illumination_Linearly Transformed Cosines (LTC) 图形学基础|基于LTC的面光源渲染","categories":[{"name":"Todo","slug":"Todo","permalink":"https://whitetail-o.github.io/categories/Todo/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://whitetail-o.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"Todo","slug":"Todo","permalink":"https://whitetail-o.github.io/tags/Todo/"},{"name":"论文复现","slug":"论文复现","permalink":"https://whitetail-o.github.io/tags/%E8%AE%BA%E6%96%87%E5%A4%8D%E7%8E%B0/"}]},{"title":"HPP_Art_2.7 Metallic与Speculer流程","slug":"HPP_Art_02.7_Metallic与Speculer流程","date":"2023-02-03T09:23:32.000Z","updated":"2023-02-04T06:49:27.828Z","comments":true,"path":"2023/02/03/HPP_Art_02.7_Metallic与Speculer流程/","link":"","permalink":"https://whitetail-o.github.io/2023/02/03/HPP_Art_02.7_Metallic%E4%B8%8ESpeculer%E6%B5%81%E7%A8%8B/","excerpt":"a). PBR模型基于物理的渲染模型，是当前主流游戏引擎使用的真实感3D渲染模型。 a.1). 两种工作流游戏资源中常见的贴图类型 PBR Guide PBR流程中，常用的有两种工作流程： 金属/粗糙度工作流(Metal/Roughness) 符合直觉，容易调参 更不容易打破能量守恒 高光（镜面反射）/光泽度（Specular/Glossiness）工作流 可自由调节$F_0$（零度菲涅尔反射）值 容易打破能量守恒 a.2). F0反射率值 大多数常用的电介质的F0范围从0.02-0.05（线性值）。对于导体，F0值 范围为0.5-1.0。因此表面的反射率由折射率决定，正如下面的方程式所示（Lagarde 2011）。 图1. 金属和非金属的$F_0$​值 &#8617; 图2. 电介质$F_0$值和金属反射率值 &#8617; 通用贴图：法线贴图、AO贴图、高度贴图等","text":"a). PBR模型基于物理的渲染模型，是当前主流游戏引擎使用的真实感3D渲染模型。 a.1). 两种工作流游戏资源中常见的贴图类型 PBR Guide PBR流程中，常用的有两种工作流程： 金属/粗糙度工作流(Metal/Roughness) 符合直觉，容易调参 更不容易打破能量守恒 高光（镜面反射）/光泽度（Specular/Glossiness）工作流 可自由调节$F_0$（零度菲涅尔反射）值 容易打破能量守恒 a.2). F0反射率值 大多数常用的电介质的F0范围从0.02-0.05（线性值）。对于导体，F0值 范围为0.5-1.0。因此表面的反射率由折射率决定，正如下面的方程式所示（Lagarde 2011）。 图1. 金属和非金属的$F_0$​值 &#8617; 图2. 电介质$F_0$值和金属反射率值 &#8617; 通用贴图：法线贴图、AO贴图、高度贴图等 b). Metal/Roughness工作流b.1). Base color(RGB-sRGB)储存数据： 非导体 的漫反射颜色/反照率颜色（Diffuse Reflected Color/Albedo） 金属导体 的镜面反射$F_0$值 非导体使用4%(0.04) 的$F_0$反射值（在一些软件中可以自定义） 混合材质（即非导体和金属导体混合材质，如锈蚀）则可以认为同时储存了两种数据 注意事项： 非导体（即电介质，非金属）： 暗色值，尽量不要低于30-50sRGB，严格控制下应不低于50sRGB。对于亮色值，贴图中不应高于240sRGB； 导体（金属）： 金属一般会有70-100%的镜面反射，映射到sRGB大概为180-255； 在SP中，可通过滤镜中的PBR检查；SD可通过PBR BaseColor/Metallic Validate节点验证是否在合适范围内； BaseColor中除了微观遮蔽信息（Micro-occlusion）以外，不应包含任何光照信息； b.2). Metallic(Grey-Linear)储存数据： 对应区域的金属度。0.0纯黑代表非金属，1.0纯白代表纯金属。 注意事项： 纯金属灰度范围在235-255 sRGB，其对应的反射率范围为70%-100%（180-255sRGB） 在Metallic贴图中，纯黑(0.0)代表了非金属，纯白(1.0)代表了金属，我们可以用过渡的灰阶来表示不同程度氧化和污垢； 对于金属，如Metallic低于235 sRGB，在BaseColor中反射率值应降低。（如一个地方锈蚀特别严重，Metallic低于235sRGB，那么需要降低BaseColor）； b.3). Roughness(Grey-Linear) Roughness中，纯黑（0.0）代表平滑表面，纯白（1.0）代表粗糙平面。 这改变了光的方向，但是光强度保持恒定不变。表面越粗糙，高光越散越暗。表面越光滑，高光反射集中，尽管反射的光的总量是一点的，表面也会更亮，光会更强。 c). Specular/Glossiness工作流c.1). Diffuse(RGB-sRGB)储存数据： 漫反射颜色（Albedo） 注意事项： Diffuse贴图表示的是漫反射颜色，Raw Metal没有漫反射，因此为纯黑（0.0）。如果发生氧化现象，金属区域就会有颜色； Diffuse中除了微观遮蔽信息（Micro-occlusion）以外，不应包含任何光照信息； 除了表示金属的纯黑（0.0）外，暗色值不应低于30sRGB，严格上说，不应该低于50sRGB； 亮色值不应该高于240sRGB； c.2). Specular(RGB-sRGB)储存数据： $F_0$（0度菲涅尔反射值） 注意事项： 镜面反射贴图包含$F_0$值； 普遍非导体的反射值为2-5%（线性），对应40-75 sRGB； 普通宝石的反射值范围在0.05-0.17（线性）； 普通液体的反射值范围在0.02-0.04（线性）； 而原始金属（Raw Metal）的反射值则可以高达70-100%的镜面反射，sRGB约为180-255； 如果你无法找到某个材质的折射率(IOR)，可以先假设F0为4%，也就是塑料的F0。 c.3). Glossiness(Grey-Linear)储存数据： 对应区域的光泽度。0.0纯黑代表粗糙，1.0纯白代表光滑。和金属工作流的Roughness为反相的关系； d). Metallic vs. Specular 边缘效应： 金属工作流导致金属和非金属的边缘出现白色边界 高光工作流导致金属和非金属边缘出现黑色伪影 原因： 纹理插值（放大），贴图分辨率和Texel密度直接影响边界伪影的可见度 解决方法： 尽可能使纹理的UV利用率高； Metallic/Roughness流程 Specular/Glossiness流程 优势 1. 在M/R工作流中，由于非导体（电介质）的FO都是规定好的所以设计师在对非导体FO赋值时不易出错。2. 纹理的缓存压力更小，因为金属贴图和粗糙度贴图都是灰度贴图。3. 目前来说是兼容性最广的工作流。 1. 边缘效应不会那么明显。2. 可以在镜面反射贴图中对非导体（电介质）材质的F0值自由调整。 劣势 1. 非导体（电介质）F0的值固定为4%，无法调整。然而，在大多是实现流程中都有控制器可以直接复写这个值，所以也不能算硬伤。2.白色边缘问题较明显，尤其在低分辨率的情况下问题突出。 1. 由于在S/G工作流的镜面反射贴图中，非导体（电介质）材质的℉0值是可以自由调整的，所以也会导致设计师容易输入错误的值。而这些错误的值被着色器误读后可能会打破能量守恒定律，从而造成不正确的渲染效果。2.由于新增了一张RGB通道的镜面反射贴图，所以对性能消耗会更大。3. S/G工作流有些名词和传统的工作流太相似，但是实质所对应的数据可能是不样的，因此会导致设计师容易误解或误操作。这种情况下就要求设计师有更好的PBR理论知识，例如了解非导体（电介质）的正确FO值，金属在漫反射色下表现为纯黑，以及在着色器没有自动校正情况下，能量守恒相关的基础知识。 e). Metallic和Specular流程的贴图转换（PS演示）金属工作流各贴图含义： 贴图 含义 Base color 漫反射颜色+镜面反射$F_0$ Metallic 材质区分，辅助解读Base color Roughness 表面状态参数 高光工作流各贴图含义： 贴图 含义 Diffuse 漫反射颜色 Specular 镜面反射$F_0$ Glossiness 表面状态参数（Roughness反相） e.1). Metallic流程 → Specular流程BaseColor + Metallic → Diffuse 方法： 去掉Base Color中金属和混合材质的$F_0$数据 实操： 打开BaseColor和Metallic，RGB模式 新建Diffuse图层，纯黑填充； 选择Metallic任一通道，得到带灰度的区域$a$； Diffuse图层新建区域 $a$ 的蒙版，底层为BaseColor； BaseColor + Metallic → Specular 方法： 去掉BaseColor中的漫反射数据，并加上非导体和混合材质的$F_0$ （默认0.04，56 sRGB，#383838） 实操： 打开BaseColor和Metallic，RGB模式 新建Specular图层，填充#383838（0.04对于22-Linear，对应56 sRGB，即#383838）； 反相Metallic，选择Metallic任一通道，得到带灰度的区域$b$； Specular图层新建区域 $b$的蒙版，底层为BaseColor； Roughness → Glossiness 方法： 反相 e.2). Specular流程 → Metallic流程Diffuse + Specular → BaseColor + Metallic 方法： 找出金属区域对应的数据，金属的特性是$F_0$在0.7-1.0之间，而非金属一般不超过0.04（宝石最高0.17），差异明显。 实操： Specular,菜单选择，色彩范围，选择阴影，灰度预览，调整参数。（也可以使用Diffuse图层)(效果不好的话可以将阴影换为取样颜色，选择纯黑，调整容差)shift+ctrl+i反选，创建蒙版。 alt+左键拖动蒙版到Diffuse图层，选择蒙版，ctrl+i反相。Base color完成 新建Metallicl图层，填充黑色，ctrl+左键点击Specular蒙版进行选区，填充白色。Metallic完成 Glossiness → Roughness 方法： 反相 Homework高光工作流转金属工作流 对比： 金属工作流转高光工作流 对比： 乍一看，经过两次转换（原资源为高光工作流，经过PS转为金属工作流后又转到高光工作流），表面上看起来区别不大，但其实已经有所变化，因此，需要在PS中多次尝试； 图3. 左侧为原Specular贴图，右侧为转换两次后的Specular贴图，可以看到已经丢失了许多细节； &#8617;","categories":[{"name":"百人计划","slug":"百人计划","permalink":"https://whitetail-o.github.io/categories/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://whitetail-o.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"百人计划","slug":"百人计划","permalink":"https://whitetail-o.github.io/tags/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/"},{"name":"美术","slug":"美术","permalink":"https://whitetail-o.github.io/tags/%E7%BE%8E%E6%9C%AF/"},{"name":"模型制作流程","slug":"模型制作流程","permalink":"https://whitetail-o.github.io/tags/%E6%A8%A1%E5%9E%8B%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/"}]},{"title":"HPP_Art_2.5 模型常见问题及规范","slug":"HPP_Art_02.5_模型常见问题及规范","date":"2023-02-03T07:23:32.000Z","updated":"2023-02-04T06:49:15.824Z","comments":true,"path":"2023/02/03/HPP_Art_02.5_模型常见问题及规范/","link":"","permalink":"https://whitetail-o.github.io/2023/02/03/HPP_Art_02.5_%E6%A8%A1%E5%9E%8B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%84%E8%8C%83/","excerpt":"a). 布线合理性 动画角度： 横平竖直，均匀清晰，结构线密度足够（动画线一般为三根）（动画线即关节线：脖子，肩膀，肘关节，腰，膝关节，踝关节），由于肘关节和膝关节一般是单向弯曲，所以在面数有限的情况下，也可以使用前三后二的布线 模型角度： 尽量把线使用在体现剪影上，单纯的在平面上加线是没有意义的，平面上的细节会在之后的制作中用法线来体现 注意事项1：多星点 多星点（度大于4的顶点）：如果是在中模阶段，减少使用多星点，因为会在细分时出现凸点的问题，如果要使用多星点，请通过布线技巧把它移动至平面处，不要让它出现在倒角边缘。 在模型上挖洞，且要保证都是四边面的情况下，是必然会出现五星点的，五星点不可避免，但可以优化。也有把五星点转换为假四边的方法（模型师把这种布线叫做假四边） 五星点同样会影响点法线。 如使用了面积权重，那可能会导致点法线发生偏移。 注意事项1：预连接对于”不在同一个平面“的四边形，不同软件的预连接是不同的。 所以如果四边形的四个点不在一个平面里时，请连接对角线，否则会出现如下图情况，这个同样会影响到之后的法线烘焙。","text":"a). 布线合理性 动画角度： 横平竖直，均匀清晰，结构线密度足够（动画线一般为三根）（动画线即关节线：脖子，肩膀，肘关节，腰，膝关节，踝关节），由于肘关节和膝关节一般是单向弯曲，所以在面数有限的情况下，也可以使用前三后二的布线 模型角度： 尽量把线使用在体现剪影上，单纯的在平面上加线是没有意义的，平面上的细节会在之后的制作中用法线来体现 注意事项1：多星点 多星点（度大于4的顶点）：如果是在中模阶段，减少使用多星点，因为会在细分时出现凸点的问题，如果要使用多星点，请通过布线技巧把它移动至平面处，不要让它出现在倒角边缘。 在模型上挖洞，且要保证都是四边面的情况下，是必然会出现五星点的，五星点不可避免，但可以优化。也有把五星点转换为假四边的方法（模型师把这种布线叫做假四边） 五星点同样会影响点法线。 如使用了面积权重，那可能会导致点法线发生偏移。 注意事项1：预连接对于”不在同一个平面“的四边形，不同软件的预连接是不同的。 所以如果四边形的四个点不在一个平面里时，请连接对角线，否则会出现如下图情况，这个同样会影响到之后的法线烘焙。 b). UV合理性 UV基础规范：如果是使用UDIM（多象限UV），从【0,1】框开始依次摆放，正常情况下全部UV放于【0,1】框内，虽然UV是平铺的，但是我们常用的软件，例如SP，绘制过程中，只能在【0,1】框中绘制 提高UV利用率： 打直UV 可进行均匀缩放（但非均匀缩放大部分情况是不允许的） 公用UV注意事项： 对于公用的UV（比如一条左右纹理相同的裤子，为了节省UV空间，使得左半边和右半边UV重叠），在烘焙时，如果有公用的UV需要挪出【0,1】框，如果不挪出去烘焙时会识别不了你需要烘哪一边作为结果，导致得到的法线贴图出现错误 硬边的地方UV必须断开，否则会出现接缝 UV接缝的两侧对最好是对齐状态，特别是使用Tiling贴图时 c). 光滑组（软硬边） 值得注意的是，在三维软件中（maya，max）导出模型法线会处于锁定状态，而导入模型后解锁法线，由于maya和max定义软硬边的方式不同（maya直接对边定义软硬边，max通过定义面的光滑组定义软硬边），会导致光滑组/软硬边丢失，可以通过插件实现在保持软硬边的情况下解锁法线，也就是先记录软硬边信息再去解锁，解锁后重新赋予即可 由于定义了软硬边，后期的烘焙过程中，烘焙时拾取的是你最后使用的模型的点的法线，如果你在烘焙结束后又去修改了软硬边信息，正常情况下软硬边信息不对等的地方法线会出现错误。简而言之就是，烘焙的信息是对于当前光滑组的信息，光滑组修改了就要重新烘焙。 d). 检查1.该合并的点全部合完了 2.没有非法面，N边面等不规范面的存在 3.有UV，用于贴图 4.不出现镂空面穿帮 5.场景大小设置正确 6.拥有规范命名，方便资产整理（模型一般前缀使用“SM_”，及static mesh） 7.Maya模型请检查历史清除干净没有，Max模型请塌陷编辑器 8.模型的坐标轴归零（习惯问题，否则进入引擎后你可能法线坐标轴不在你模型的周围） 9.进入引擎前最好三角面化 e). 命名及存储规范 规范内容 修改建议 文件及文件夹命名 统一命名规范，方便管理；分类整理，不同用途的文件在不同的文件夹中（可详细定制） 存放文件夹 角色模型-/char 场景模型-/scene 道具模型-/prop 动画-/anim 命名规范之前后缀（导出后） 特效_vfx 带通道图_al 模型SM_ 命名规范（模型）（导出前） Door-red-01 命名规范（贴图）（导出前） Door-red-01-cm/sm/nm 命名规范（材质球）（导出前） Door-red-01-mat 贴图命名 无中文、不重名，带有A通道的导出TGA或PNG（后缀_al） f). 制作规范 规范内容 修改建议 单位 在建模软件中正确的设置单位 方向 根据不同的使用场景（如从Max到unity）保持方向统一 顶点数与面数 建模时的数量信息可能和导出后不一致（例如1个点对应不同UV点后，会在Unity中变成2个点），注意减少面数 面数控制 设定一个具体的面数范围（针对不同的性能需求），我没经验我也不知道 顶点属性 建模中清除掉不必要的顶点属性信息（如删除没用到的UV2，UV3，只保留一套） 骨骼绑定 IK、CAT、BIP，其他Unity不认，单个物体骨骼数量限制为具体个数 动画帧数 约定每秒多少帧，一个动画多少秒 贴图格式和尺寸 文件尺寸为2的n次方、确定具体最大的贴图尺寸 UV 打直UV，提高利用率，减少不均匀的拉伸，烘焙时，共用的UV移出01框（如重叠的UV），断开硬边避免接缝，接缝处的UV两边对齐，避免Tiling时出现错误 布线合理性 低模中减少不必要的线，增加关节处的线，避免五星线出现在卡线上，连接好边再导出，注意布线导致的法线方向错误 光滑组 展UV时断开硬边，注意法线的锁定问题 g). 完成导出检查 规范内容 修改建议 坐标归零 制作完成后坐标轴归零，根据实际场景选择不同的零点 检查模型 检查反面、废点、废线、废面、不规范面，完成后重置变换 优化模型 删除不必要的面、合并顶点、在特定部位进行修改（关节处增加线） 模型导出 清除场景中不必要的物件，清除历史记录、塌陷编辑器 贴图支持 检查使用场景下，导出的贴图是否被支持 蒙皮、动作调节 见动画规范表（暂无） 动画导出 导出只有动画的fbx 导入法线锁定 注意重新设置软硬边或光滑组","categories":[{"name":"百人计划","slug":"百人计划","permalink":"https://whitetail-o.github.io/categories/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://whitetail-o.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"百人计划","slug":"百人计划","permalink":"https://whitetail-o.github.io/tags/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/"},{"name":"美术","slug":"美术","permalink":"https://whitetail-o.github.io/tags/%E7%BE%8E%E6%9C%AF/"},{"name":"模型制作流程","slug":"模型制作流程","permalink":"https://whitetail-o.github.io/tags/%E6%A8%A1%E5%9E%8B%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/"}]},{"title":"HPP_Art_2.3 硬表面基础","slug":"HPP_Art_02.3_硬表面基础","date":"2023-02-03T05:23:32.000Z","updated":"2023-02-04T06:49:21.036Z","comments":true,"path":"2023/02/03/HPP_Art_02.3_硬表面基础/","link":"","permalink":"https://whitetail-o.github.io/2023/02/03/HPP_Art_02.3_%E7%A1%AC%E8%A1%A8%E9%9D%A2%E5%9F%BA%E7%A1%80/","excerpt":"a). 什么是硬表面 从外表/建模来说：有着重工业质感、该平滑的时候平滑，该硬朗的时候硬朗。即平的平，弯的弯。 从光影来说：光影变化均匀，硬朗，有经过打磨的感觉。 需要区别于LowPoly，Lowpoly有种纸片的拼凑感，更像是纸膜，主要是倒角所给予硬表面的厚度。即缺少最重要的倒角。 b). 如何制作硬表面（高模上倒角方法） 在游戏中硬表面通常是使用低模进行体现。因为硬表面的质感很大程度上取决于倒角。倒角会很大的增加模型面数。对于一些较小的结构，小凹槽，实际在低模上进行倒角或者卡边做出结构是不太划算的。本质上是要让高光的呈现更加集中，如果高光过于散开，就会显得较软，漂亮的高光边会表现很强的质感。 b.1). 卡双线 第一对线用于Smooth后形成倒角，第二对线用于收敛高光 b.2). 方倒角 对两个倒角卡双线 b.3). 直接倒角效果最好，可得到漂亮的高光边，但是因为增加的边数很多，过于密集，修改起来麻烦。 b.4). 光滑组（软硬边）+ 卡单线 通过将两个面设为同一光滑组（Maya里则将连接边设为软边）+ 两边各卡一条线用于收敛高光区域 光滑组的本质： 改变点法线光滑组的本质是改变点法线，进而影响面法线，进而影响三角线遍历中Normal的插值；","text":"a). 什么是硬表面 从外表/建模来说：有着重工业质感、该平滑的时候平滑，该硬朗的时候硬朗。即平的平，弯的弯。 从光影来说：光影变化均匀，硬朗，有经过打磨的感觉。 需要区别于LowPoly，Lowpoly有种纸片的拼凑感，更像是纸膜，主要是倒角所给予硬表面的厚度。即缺少最重要的倒角。 b). 如何制作硬表面（高模上倒角方法） 在游戏中硬表面通常是使用低模进行体现。因为硬表面的质感很大程度上取决于倒角。倒角会很大的增加模型面数。对于一些较小的结构，小凹槽，实际在低模上进行倒角或者卡边做出结构是不太划算的。本质上是要让高光的呈现更加集中，如果高光过于散开，就会显得较软，漂亮的高光边会表现很强的质感。 b.1). 卡双线 第一对线用于Smooth后形成倒角，第二对线用于收敛高光 b.2). 方倒角 对两个倒角卡双线 b.3). 直接倒角效果最好，可得到漂亮的高光边，但是因为增加的边数很多，过于密集，修改起来麻烦。 b.4). 光滑组（软硬边）+ 卡单线 通过将两个面设为同一光滑组（Maya里则将连接边设为软边）+ 两边各卡一条线用于收敛高光区域 光滑组的本质： 改变点法线光滑组的本质是改变点法线，进而影响面法线，进而影响三角线遍历中Normal的插值； c). 烘焙（低模） 事先准备： 准备好低模（在中模的基础上简化） 展UV 分好光滑组（软硬边） c.1). 烘焙过程中，光滑组注意事项对于倒角的部分，烘焙前需要设置好光滑组，对于硬边需要断开UV，否则会出现接缝； 即：对于需要烘焙的低模，同一光滑组（软边），UV需相连；对于不同光滑组（硬边），UV需断开且隔开一定距离 如低模中，本需硬边烘焙的Normal使用了软边，那烘焙时会通过用反相的Normal把Normal复原（在法线本应改在（0,0,1）时） d). 硬表面其他制作方法假高模 用图片转normal 在SP里面印normal 使用OpenSubdiv 使用ZBrush做倒角 使用点法线","categories":[{"name":"百人计划","slug":"百人计划","permalink":"https://whitetail-o.github.io/categories/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://whitetail-o.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"百人计划","slug":"百人计划","permalink":"https://whitetail-o.github.io/tags/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/"},{"name":"美术","slug":"美术","permalink":"https://whitetail-o.github.io/tags/%E7%BE%8E%E6%9C%AF/"},{"name":"模型制作流程","slug":"模型制作流程","permalink":"https://whitetail-o.github.io/tags/%E6%A8%A1%E5%9E%8B%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/"}]},{"title":"HPP_Art_1 美术理论基础(角色/场景设计精要)","slug":"HPP_Art_01_美术理论基础","date":"2023-02-03T03:23:32.000Z","updated":"2023-02-04T06:48:01.369Z","comments":true,"path":"2023/02/03/HPP_Art_01_美术理论基础/","link":"","permalink":"https://whitetail-o.github.io/2023/02/03/HPP_Art_01_%E7%BE%8E%E6%9C%AF%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/","excerpt":"","text":"https://www.yuque.com/sugelameiyoudi-jadcc/okgm7e/pfo9oz","categories":[{"name":"百人计划","slug":"百人计划","permalink":"https://whitetail-o.github.io/categories/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://whitetail-o.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"百人计划","slug":"百人计划","permalink":"https://whitetail-o.github.io/tags/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/"},{"name":"美术","slug":"美术","permalink":"https://whitetail-o.github.io/tags/%E7%BE%8E%E6%9C%AF/"},{"name":"美术理论","slug":"美术理论","permalink":"https://whitetail-o.github.io/tags/%E7%BE%8E%E6%9C%AF%E7%90%86%E8%AE%BA/"}]},{"title":"Games202-3 Real-time Environment Mapping","slug":"Games202_03_Real-time Environment Mapping","date":"2023-02-01T08:42:10.000Z","updated":"2023-02-12T13:17:10.225Z","comments":true,"path":"2023/02/01/Games202_03_Real-time Environment Mapping/","link":"","permalink":"https://whitetail-o.github.io/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/","excerpt":"Mesh Distance Fields，Real Shading in Unreal Engine 4 a). Shading from Environment Lighting(IBL) 通过环境贴图着色的方式，又被命名为 Image-Based Lighting (IBL) a.1). How 对于IBL，可以看做是上半球（可以联想下UE中的HDRI）的光照和BRDF的积分； Observation： 对于Glossy，其BRDF支持集很小（Lobe范围小）； 对于Diffuse，其BRDF非常平滑； 联想到上节课渲染方程不等式成立的条件（拆出乘积积分的那个） 这里$\\Omega_{G}$ 指积分域上，$g(x)$有值的区域。 如$g(x)$ 为BRDF，$\\Omega_{G}$ 即为原点向Lobe各点出发，与积分半球相交的区域集合 We can safely take the lighting term out! 我们把渲染方程分为了两部分积分，分别是： 在$\\Omega_{fr}$(即Lobe对应的半球区域)，对光照Radiance积分 在半球内对BRDF积分；","text":"Mesh Distance Fields，Real Shading in Unreal Engine 4 a). Shading from Environment Lighting(IBL) 通过环境贴图着色的方式，又被命名为 Image-Based Lighting (IBL) a.1). How 对于IBL，可以看做是上半球（可以联想下UE中的HDRI）的光照和BRDF的积分； Observation： 对于Glossy，其BRDF支持集很小（Lobe范围小）； 对于Diffuse，其BRDF非常平滑； 联想到上节课渲染方程不等式成立的条件（拆出乘积积分的那个） 这里$\\Omega_{G}$ 指积分域上，$g(x)$有值的区域。 如$g(x)$ 为BRDF，$\\Omega_{G}$ 即为原点向Lobe各点出发，与积分半球相交的区域集合 We can safely take the lighting term out! 我们把渲染方程分为了两部分积分，分别是： 在$\\Omega_{fr}$(即Lobe对应的半球区域)，对光照Radiance积分 在半球内对BRDF积分； a.2). Lighting（对Radiance积分） Lighting： \\frac{\\int_{\\Omega_{f_{r}}} L_{i}\\left(p, \\omega_{i}\\right) \\mathrm{d} \\omega_{i}}{\\int_{\\Omega_{f_{r}}} \\mathrm{~d} \\omega_{i}} 即在$\\Omega_{fr}$(即Lobe对应的半球区域)，对光照Radiance积分，再归一化（normalize，分母用于归一化）； 类比于PCF，就是对Environment Map做滤波； 滤波方法：Mipmap 在Shading中，需要获得Lighting项的值，只需要求得Environment Map对应Mipmap层，Lobe中点(镜面反射方向)方向的结果 和百人计划图形2.5中，做Relief Mapping时在Unity用到的texCUBElod()，对Mipmap采样联系上了； 1fixed3 Reflection = ACESToneMapping(texCUBElod(_CubeMap, float4(worldRef, (255-_Gloss)*8/255)).rgb, 1) * SpecularTint * _EnvIntensity; a.3). 对BRDF积分（Split Sum） \\int_{\\Omega^+}f_r(p,w_i,w_o)cos\\theta_i d\\omega_i假设使用微表面理论的BRDF 做法： 预计算考虑进所有变量（roughness、color等）的可能值的积分； 但是，维度过高，存储成本过高，因此需要降维； 降维过程： 对应微表面BRDF，只考虑Fresnel term($F(i,h)$)和distribution of normals($D(h)$) Fresnel term采用the Schlick’s approximation 至此，积分降维为三维 $R_0$ ：零度菲涅尔值 $\\alpha$ ：可表示为roughness，$\\alpha$ 越大，越粗糙； $\\theta(\\theta_h)$ ：在实时渲染中，我们认为出射角、入射角以及入射角/出射角与半程向量的夹角，这三者是相同性质的（不是说值近似相等，而是指作为积分的元素效果相同） 在对BRDF的积分式中，通过Schlick’s approximation，将$R_0$拆出，即写成下列式子 积分现在被降维为二维（$R_0$被拆出，$f_r$中的菲涅尔项被分母抵消） $\\alpha$ $\\theta$ 至此，我们对积分的两项分别进行预计算，储存在表格或者图片中（R、G通道分别两项积分结果）通过LUT查询即可 而$R_0$ 则可通过BaseColor（Metallic Workflow）、Specular（Specular Workflow）贴图或软件内置（一般默认为4%）即可获得；（看百人计划美术 2.7 Metallic与Speculer流程） 名字由来： Split sum 假设使用Lambert的BRDF \\int_{\\Omega^+}f_r(p,w_i,w_o)cos\\theta_i d\\omega_i $f_r = {1\\over \\pi}$ $\\int_{\\Omega^+}cos\\theta_i d\\omega_i = \\pi$ （看Games101 Lecture 17-18 Materials二重积分） 所以正好BRDF积分为1 b). Shadow from Environment Light 在实时渲染中，没有完美的解决方案； 难以用实时渲染方程（那个不等式）来近似： Support大，为整个半球 带有Gloosy项，不够smooth 工业界方法： 只计算最亮的灯光（如UE中HDRI带一个Direction Light） Related research Imperfect shadow maps Light cuts RTRT (Real-Time Ray Tracing, might be the ultimate solution) Precomputed radiance transfer(PRT) c). Spherical Harmonics(SH, 球面谐波函数)c.1). 前置知识Fourier Transform 这里是偶函数，所以 $sin$ 项系数都为0 Convolution Theorem 时域卷积等于频域乘积 A general understanding product intergral: 相乘后积分，对应离散的情况就是相乘后相加。如： $n$维向量$\\bold{a} = (x_1, x_2,…,x_n)$ 和 $\\bold{b} = (y_1, y_2,…,y_n)$ 进行product intergral，即点乘 $\\bold{a} \\cdot \\bold{b} = x_1y_1+x_2y_2+…+x_ny_n$ 我们认为，函数相乘后积分（product intergral），就是滤波（卷积） 积分结果的频率，取决于频率最低的项（$f(x),g(x)$） Basis Functions（基函数） $c_i$ 为系数 如傅里叶变换中，各项就为正交基； 或者多项式和泰勒展开等 c.2). 简介What？ 球谐函数 是一系列 二维球面函数的正交基函数 球谐函数具有正交、归一、完备性 如 f(\\omega)=\\sum_{i} c_{i} \\cdot B_{i}(\\omega) $f(\\omega)$ 为球面函数，$\\omega$ 为向量 $c_i$ 为系数 $B_{i}(\\omega)$ 则为球谐函数 说明： 每一行（$l=n$），频率相同 对于$l=n$行（第$n$阶），函数数量为$2l+1$ 每一阶各SH都有编号，即$m$ 从$-l$ 到 $l$； How？ 每一阶的SH函数，由勒让德多项式求得； 如何求得$c_i$ 投影（Projection） 类似于傅里叶展开中，函数和各个正交基相乘求系数 c.3). 性质 正交性； 投影性； 旋转方便（旋转$f(x)$，相当于旋转基函数$B(i)$） SH中，旋转后的基函数，可通过同阶的基函数线性组合得到； d). Shading from Environment Lighting(SH, Diffuse项)d.1). 简介 如果不通过IBL方式，计算shading，那可以通过SH展开$L_i(p,\\omega_i)$ ，即展开Environment Map（Environment Map可以写成二维函数） d.2). 分析Diffuse项的BRDF $A_l$ 就是基函数的系数； 由图可见，通过SH分析Diffuse项的BRDF后，可得出结论 当$l\\geq3$ (即第四阶开始)，其 $A_l$ 接近0，说明Diffuse项的BRDF频率低，由SH前三阶表示即可； 积分结果的频率，取决于频率最低的项（$f(x),g(x)$） Diffuse BRDF acts like a low-pass filter 因此，对于Environment Map的展开，只需要SH前三阶即可 d.3). SH展开Environment Map 通过求得各球谐函数的结果后，再通过结果逆变换得到Shading结果 通过ShadingPoint法线，再经过一系列计算（？）得到shading e). Precomputed Radiance Transfer 对于渲染方程，如果我们把它每一项都进行Brute-force（蛮力）计算 $L_i$ : 二维，方位角$\\omega$和俯仰角$\\theta$ $V(i)$ : 二维，方位角和俯仰角 $\\rho(\\mathbf{i}, \\mathbf{o})$ : 四维，入射角和出射角的方位角和俯仰角 存储压力过于大； e.1). PRT 前提： 假设场景中除了Lighting，其他都不变； 将RE分为两项， Lighting变化； light transport不变； $V(i): $ 二维，$\\omega,\\theta$，可烘焙为图像，如CubeMap（场景摆放固定） $\\rho(\\mathbf{i}, \\mathbf{o}): $ BRDF Diffuse Case: 常数 Gloosy Case: 四维，$\\omega_{i},\\theta_i, \\omega_o,\\theta_o$，入射和出射的方位角和俯仰角（相机固定，入射角固定） e.2). Diffuse Case 此处（图形学中，大部分情况都是），积分和求和位置可变； 经过预计算后，求得Shading结果只需要在SH空间中，对向量进行点乘即可； e.2.1). 计算 注意： 此处两次求和复杂度仍然是$O(n)$，因为SH基函数具有正交性； Runtime is independent of transport complexity 计算Light Transport简易理解： 积分形式和渲染方程相似，$B_i(\\bold{i})$ 类似于$L_i(\\bold{i})$ ，可看成是将球谐函数作为光照进行Shading得到Light Transport结果 e.3). Glossy Case 此时，BRDF是关于入射和出射的方位角和俯仰角的四维函数； 做法： 对 $\\bold{o}$ 也进行SH展开；（对于Gloosy不止展开到第三阶） light coefficient与Diffuse Case相同，为SH空间的一维向量； transport matrix则是关于 $\\bold{o}$ 和 $\\bold{i}$ 四维函数（入射和出射的方位角和俯仰角），为SH空间的二维矩阵； reflected radiance coefficient则是关于 $\\bold{o}$ 的二维函数（出射角的方位角和俯仰角），通过SH逆变换，即可得出相应视角（ $\\bold{o}$ ）下的Gloosy radiance； 具体怎么变换的？待实现 e.4). 总结和限制 f). Wavelet(小波) 定义在二维平面上的一系列基函数 A non-linear approximation: 二维函数经过小波变换后，大部分系数接近0，这时可采用只记录系数大于一定值的项来近似原函数； 对于Environment Map，小波变换无法变换球面函数，因此展开为Cubemap后进行小波变换； 每一个矩形经过小波变换后，把高频信息放在右上、右下、左下子块，剩下的低频信息放在左上，继续做小波变换； 其他应用：JPG格式图片压缩， 使用类似与小波变换的DCT（Discrete cosine transform，离散余弦变换）、JPEG2000 效果对比： 缺点： 旋转不方便（不同于SH基函数的旋转简易型，小波旋转需要从Wavelet展开，旋转后再做小波变换）","categories":[{"name":"Games202","slug":"Games202","permalink":"https://whitetail-o.github.io/categories/Games202/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://whitetail-o.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"Games202","slug":"Games202","permalink":"https://whitetail-o.github.io/tags/Games202/"},{"name":"IBL","slug":"IBL","permalink":"https://whitetail-o.github.io/tags/IBL/"}]},{"title":"Games202-2 Real-Time Shadow","slug":"Games202_02_Real-Time Shadow","date":"2023-02-01T08:23:10.000Z","updated":"2023-02-12T13:17:17.247Z","comments":true,"path":"2023/02/01/Games202_02_Real-Time Shadow/","link":"","permalink":"https://whitetail-o.github.io/2023/02/01/Games202_02_Real-Time%20Shadow/","excerpt":"a). Shadow Mapping A 2-Pass Algorithm Light pass: Generate the SM(Shadow Map) Camera pass: uses the SM An image-space algorithm Pro(优点): no knowledge of scene’s geometry is required Con(缺点): causing self occlusion(自遮挡) and aliasing(走样) issues Pass 1: Render from Light 输出一张光源视角的深度图（Depth Buffer） Pass 2: Render from Eye(Camera) 将光源视角对应的深度转换到View Space, 与Camera视角的深度进行深度比较； 如$Depth_{cam} &gt; Depth_{light}$ ，那说明该点在阴影中（相机可见，光源不可见） 如$Depth_{cam} &lt; Depth_{light}$ ，那说明该点在不在阴影中（相机可见，光源可见） 用于比较的深度值： 经过透视投影中的Squeez矩阵后（具体看Games101 Math笔记），z会被推向远平面 $M_{\\text {persp } \\rightarrow \\text { ortho }}=\\left(\\begin{array}{cccc}n &amp; 0 &amp; 0 &amp; 0 \\\\0 &amp; n &amp; 0 &amp; 0 \\\\0 &amp; 0 &amp; n+f &amp; -nf \\\\0 &amp; 0 &amp; 1 &amp; 0\\end{array}\\right)$ 用于比较的$Depth$ 可以是经过MVP中的深度值（即Depth Buffer中的深度值）； 也可以是该点在同一空间（如模型空间）中，该点到相机/光源的线性距离；","text":"a). Shadow Mapping A 2-Pass Algorithm Light pass: Generate the SM(Shadow Map) Camera pass: uses the SM An image-space algorithm Pro(优点): no knowledge of scene’s geometry is required Con(缺点): causing self occlusion(自遮挡) and aliasing(走样) issues Pass 1: Render from Light 输出一张光源视角的深度图（Depth Buffer） Pass 2: Render from Eye(Camera) 将光源视角对应的深度转换到View Space, 与Camera视角的深度进行深度比较； 如$Depth_{cam} &gt; Depth_{light}$ ，那说明该点在阴影中（相机可见，光源不可见） 如$Depth_{cam} &lt; Depth_{light}$ ，那说明该点在不在阴影中（相机可见，光源可见） 用于比较的深度值： 经过透视投影中的Squeez矩阵后（具体看Games101 Math笔记），z会被推向远平面 $M_{\\text {persp } \\rightarrow \\text { ortho }}=\\left(\\begin{array}{cccc}n &amp; 0 &amp; 0 &amp; 0 \\\\0 &amp; n &amp; 0 &amp; 0 \\\\0 &amp; 0 &amp; n+f &amp; -nf \\\\0 &amp; 0 &amp; 1 &amp; 0\\end{array}\\right)$ 用于比较的$Depth$ 可以是经过MVP中的深度值（即Depth Buffer中的深度值）； 也可以是该点在同一空间（如模型空间）中，该点到相机/光源的线性距离； a.1). Issues in Shadow Mappinga.1.1). Self occlusion(自遮挡) Self occlusion： 阴影自遮挡，造成阴影毛刺的现象； 原因： 如上图， Shadow Map分辨率有限，一个像素内记录的深度值相同。如图中红色和橙色斜线表示Shadow Map中深度相同的位置（$Depth_A = Depth_{A’}$）； 当计算平面中$B$点是否在阴影中时，$Depth_{light} = z1 = Depth_A$，而相机视角下的点$B$转换到光源视角下对应的深度为 $z2$ ，即$Depth_{cam} = z2 = Depth_B$ 因此，$Depth_{cam} &gt; Depth_{light}$ ，说明该点在阴影中，因此造成Self occlusion 解决方法： 引入Bias； 认为对于$B$点，如$Depth_{cam} &gt; Depth_{light}$，但$Depth_{light}$ 处于橙色中，那该点仍然不在阴影中； 即： $Depth_{cam} &gt; Depth_{light}+bias$，才使得该点在阴影中； $Depth_{cam} &lt; Depth_{light}+bias$，该点不在阴影中； 易得，当光源方向垂直于平面时，所需的Bias最小，因此可引入光源与平面法线的夹角 $cos\\alpha$ ，来调整Bias大小； 引入bias会造成的问题：Detached shadow(不接触阴影，Peter Panning) a.1.2). Detached shadow 解决方法： Second-depth shadow mapping 工业界实际没什么人用，只是学术界提出的解决方案 a.1.3). Aliasing b). Mathb.1). Approximation in RTR RTR中常用的不等式； 该不等式“准确”的条件： Support（支撑集，积分的范围）足够小时； $g(x)$ 足够光滑（指频率低，起伏小） b.2). 渲染方程的不等式 $V(p,\\omega_i)$为Visibility，阴影因子； 单独拆出Visibility，即先做shading，后做Visibility，最后相乘 b.3). in Shadow Mapping什么情况下，Shadow Mapping（先着色，后计算阴影）是准确的； Small support 在计算阴影中，支撑集小，意味着光源小； 因此，对于点光源和方向光源，做Shadow Mapping硬阴影结果是准确的； Smooth integrand对于不等式处理后的渲染方程，$g(x)$ 代表光照。 当$g(x)$ 足够光滑（指频率低，起伏小），不等式为准确的； $L_i$ 光滑，对应光源为面光源； BRDF，即$f_r$ 光滑，对应Diffuse项； 即对于光源为面光源的Diffuse项，不等式处理后的渲染方程是准确的； c). PCSS(Percentage-Closer Soft Shadow) c.1). PCF(Percentage Closer Filtering) PCF用于抗锯齿，而不用于软阴影（用于软阴影的叫PCSS，两者实质是一个东西，但应用不同叫法不同） 在生成Shadow Map后，阴影比较时（即对阴影比较的结果），进行Filtering 面光源生成Shadow Map：以面光源的中心点(放置相机)生成shadow map 做法： 不止对着色点与其在Shadow Map中的对应点进行深度比较，而是着色点深度与其在Shadow Map中对应点及其周围点深度进行比较，最后对各个Visibility的结果取平均值（或加权平均） eg1. $P$点在Cam视角下深度为$Depth_p$，转换到光源视角下深度为$Depth_{p’}$，$Depth_{p’}$ 与其在Shadow Map中对应点周围3x3（Filter size）像素进行比较，得到结果 \\begin{array}{l} 1,0,1 \\\\ 1,0,1 \\\\ 1,1,0 \\end{array}取平均得到Visibility为 0.667 Filter size Small -&gt; sharper Large -&gt; softer 为选取合适的Filter size，产生了PCSS c.2). PCSS(Percentage-Closer Soft Shadow)c.2.1). 什么是PCSS？ 关键： 自适应Filter size 观察可得： 钢笔（Blocker）与接收平面（Receiver）的距离越小（笔尖），阴影越硬 钢笔（Blocker）与接收平面（Receiver）的距离越大（笔尖），阴影越软 即阴影的软硬程度，一部分取决于Blocker和Receiver的距离 阴影的软硬取决于 $w_{Light}$ （光源的宽度） $d_{Blocker}$ 与 $d_{BtoR}$ 的比值； Blocker定义： Shading point变换到Light视角，对应深度为$Depth_{scene}$ 。查询区域内，深度值$z &lt; Depth_{scene}$ 的texel即为Blocker； $d_{Blocker}$ 为 Average blocker distance Average blocker distance： Shadow Map一定范围内的Blocker的深度平均值 类似eg1 eg1. $P$点在Cam视角下深度为$Depth_p$，转换到光源视角下深度为$Depth_{p’}$，$Depth_{p’}$ 与其在Shadow Map中对应点周围3x3（Filter size）像素进行比较，得到结果 \\begin{array}{l} 1,0,1 \\\\ 1,0,1 \\\\ 1,1,0 \\end{array}取平均得到Visibility为 0.667 其中，Visibility为0的点，即 处于阴影中，$Depth_{cam} &gt; Depth_{light}+bias$ 的点即为Blocker，对Blocker在Shadow Map中的深度值取平均值，即得到Average blocker distance c.2.2). 做法 首先将shading point点$x$投应到shadow map上,找到其对应的像素点$P$。PCSS算法的实现流程如下： 第一步：Blocker search，即获取某个区域的平均遮挡物深度（在点p附近取一个范围(这个范围是自己定义或动态计算的),将范围内各像素的最小深度与x的实际深度比较,从而判断哪些像素是遮挡物，把所有遮挡物的深度记下来取个平均值作为blocker distance。） 第二步：Penumbra estimation，使用平均遮挡物深度计算滤波核尺寸（用取得的遮挡物深度距离来算在PCF中filtering的范围。） w_{\\text {Penumbra }}=\\left(d_{\\text {Receiver }}-d_{\\text {Blocker }}\\right) \\cdot w_{\\text {Light }} / d_{\\text {Blocker }}第三步：Percentage Closer Filtering，对应该滤波核尺寸应用PCF算法。 如何动态计算Blocker search的“某个范围” Light越远，Region越小；Light越近，Region越大；（好像和图不太对应，如非要对应，就类似与Shadow Map位置不变，Light距离变大/小） 那么PCSS中那些步骤会导致速度变慢？ 第一步：Blocker search，需要多次采样查询深度信息并比较，计算Blocker的平均深度$d_{Blocker}$ 第三步：PCF，阴影越软→滤波核尺寸越大→采样查询次数变多→速度变慢 由此可见，主要是多次采样并比较的方法使得速度变慢； 加速方法： 随机采样，后降噪； 如果觉得区域过大不想对每一个texels都进行比较,就可以通过随机采样其中的texels，而不是全部采样，会得到一个近似的结果,近似的结果就可能会导致出现噪声。工业的处理的方式就是先稀疏采样得到一个有噪声的visibility的图,接着再在图像空间进行降噪。 Variance Soft Shadow Mapping(VSSM) c.2.3). Math V(x)=\\sum_{q \\in \\mathcal{N}(p)} w(p, q) \\cdot \\chi^{+}\\left[D_{\\mathrm{SM}}(q)-D_{\\text {scene }}(x)\\right] 其中$\\chi^{+}$ 类似于$step()$ 函数 $D_{\\mathrm{SM}}(q)-D_{\\text {scene }}(x) \\geq 0$， 即$Depth_{ShadowMap} \\geq Depth_{cam}$，$\\chi^{+}\\left[D_{\\mathrm{SM}}(q)-D_{\\text {scene }}(x)\\right] = 1$ $D_{\\mathrm{SM}}(q)-D_{\\text {scene }}(x) &lt; 0$， 即$Depth_{ShadowMap} &lt; Depth_{cam}$，$\\chi^{+}\\left[D_{\\mathrm{SM}}(q)-D_{\\text {scene }}(x)\\right] = 0$ d). Variance Soft Shadow Mapping(VSSM) vs PCSS: Fast blocker search(step 1) and filtering(step 3) 关键思想： 只用知道有多少（百分比）的 texels 在着色点前面； d.1). Solve step3(PCF) 通过正态分布（Normal distribution），求得着色点的深度在采样点中大概的排位，即可得到近似的结果； 需要定义一个正态分布，需要得知其均值（mean）和方差（variance） Mean: Hardware MIPMAPing (快，但不一定准确); Summed Area Tables (SAT, 积分表); Variance: $Var(X) = E(X^2)-E^2(X)$ ，方差等于平方的均值（均方值）减去均值的平方； 只需要在Depth Buffer的空余通道中多存储一个$depth^2$； 通过求正态分布$P(x&gt;Depth_{cam}) (Depth_{cam}为着色点转换到光源视角的深度)$ 的面积，即求CDF（累积分布函数 ）即可求得Visibility CDF(x) 求解： 查表； 切比雪夫不等式； 切比雪夫不等式（并不需要知道具体的分布情况，而是通过不等式直接得出，如使用切比雪夫就不用正态分布，只需要求得均值和方差即可，但是也需要分布情况较为简单） 通过近似值约等出Visibility的结果，即红色面积； （准确的条件：）$t\\geq mean$ （但一般不管这个，就理解成约等就行） 至此解决了Step3 d.2). Solve step1 Shading point转换到光源下， 关键式： \\frac{N_{1}}{N} z_{\\text {unocc }}+\\frac{N_{2}}{N} z_{o c c}=z_{\\text {Avg }} $\\frac{N_{1}}{N} = P(x&gt;t)$ ，通过切比雪夫不等式求出； $\\frac{N_{2}}{N} = 1-P(x&gt;t)$ $z_{Avg}$：SM中，采样范围深度均值 $z_{unocc}$：近似等于$t$ 最终，由关键式得出$ z_{o c c}$ d.3). Summed Area Tables (SAT, 积分表) SAT为数据结构，使用前缀和算法 2D的SAT：每一个点记录左上角区域的和； 先计算一行的一维SAT； 再对计算后的SAT进行列方向的累加，求出二维的SAT； 求蓝色区域和只需要查询四次SAT即可； SAT的并行性： 由于先进行行方向SAT计算，后进行列方向SAT计算，具有一定的并行性； d.4). 缺陷由于使用了切比雪夫不等式或正态分布，隐含了Shadow Map中对应范围的深度分布要较为简单或接近正态分布 如上右图，分布主要集中在三个值，过于离散，造成VSSM不准确； Light leaking（漏光） e). Moment Shadow Mapping(MSM) VSSM不够准确，需要用更高的矩（Moment）来描述PCF（Use higher order moments to represent a distribution） 矩（Moments）： Quite a few variations on the definition We use the simplest: $x,x^2,x^3,x^4,…$ VSSM中，我们用到了二阶矩（$depth^2$） 有点类似于展开（比如泰勒展开）； f). Distance Field Soft Shadow(SDF, 有向距离场)f.1). Distance functions 定义： 对于空间中任意一点，其值为到物体的最近距离。并且可定义其在内部符号（Signed）为负，在外符号为正，即为有向距离场（Signed Distance Functions, SDF）; An Example: Blending (linear interp.) a moving boundary 背后理论： 最优传输（Optimal Transport） SDF性质： 对于刚体，SDF不需要实时计算； $n$个刚体运动，对于一个点$P$ ，就有$SDF_1(P), SDF_2(P)……SDF_n(P)$，那该点最后的SDF值即为$min(SDF_1(P), SDF_2(P)……SDF_n(P))$ 对于形变的物体，SDF需要实时计算； 用途： Ray marching 软阴影 WARNING：不要看到图形就认为SDF是存储一张图形，SDF是三维存储，对于空间中每一个点都有其SDF值 f.1.1). Ray marching 作用：Ray marching(sphere tracing)用来在SDF中射线与物体求交 关键思想： SDF中一点的值，即是该点与周围物体不相交的“安全距离”。如对于点$P$，在周围半径为$SDF(P)$ 的距离内，不与物体相交； 因此，以图为例，求SDF中射线与物体相交只需要依次步进$SDF(P)$ , $SDF(A)$ , $SDF(P)$，只需要终点的$SDF(Last)$ 小于一定值，即该点为交点（或一定次数步进后仍没交点，说明该点无交点） f.1.2). Soft Shadow 作用： 使用SDF来近似表现遮挡百分比（Visibility） 关键思想： SDF中一点的值，即是该点实现不被某一物体遮挡“安全角度” 如着色点$P$看向面光源$AB$，通过得到射向面光源中点的Ray marching来得到”安全角度”。通过安全角度在总角度中的占比，来近似Visibility Smaller “safe” angle &lt;-&gt; less visibility 安全角度： 缺点： 在shader中涉及反三角函数，开销大； 因此用 \\min \\left\\{\\frac{k \\cdot \\operatorname{SDF}(p)}{|p-o|}, 1.0\\right\\}来替代，并用 $k$ 控制阴影的软硬程度； f.2). Pros and Cons Pros 快（使用角度，不考虑生成） 高质量 Cons 需要预计算 需要额外存储（不仅仅是图形，而是需要三维空间存储） 对于形变物体需要大量实时计算 ……","categories":[{"name":"Games202","slug":"Games202","permalink":"https://whitetail-o.github.io/categories/Games202/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://whitetail-o.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"Games202","slug":"Games202","permalink":"https://whitetail-o.github.io/tags/Games202/"},{"name":"Shadow","slug":"Shadow","permalink":"https://whitetail-o.github.io/tags/Shadow/"}]},{"title":"Games202-1 Recap of CG Basics","slug":"Games202_01_Recap of CG Basics","date":"2023-02-01T08:15:10.000Z","updated":"2023-02-04T06:32:31.699Z","comments":true,"path":"2023/02/01/Games202_01_Recap of CG Basics/","link":"","permalink":"https://whitetail-o.github.io/2023/02/01/Games202_01_Recap%20of%20CG%20Basics/","excerpt":"a). Graphics Pipeline b). OpenGL A. Place objects/models Model specification(模型信息) Model transformation B. Set up an easel(画架) View transformation Create /use a framebuffer C. Attach a canvas to the easel指定Pass到framebuffer，就和Unity中FS的SV_TARGET一样。 E. you can also paint multiple pictures using the same easel 一个Rendering Pass，使用一个framebuffer，渲染一个或多个texture（shading, depth, etc.）作为输出 即一个framebuffer可以绑定多个纹理（MRT） Multiple Render Target（MRT）是一种指可以使绘制程序在单帧中同时渲染多个Render Target D. Paint to the canvas This is when vertex / fragment shaders will be used For each vertex in parallel OpenGL calls user-specified vertex shader: Transform vertex (ModelView, Projection), other ops For each primitive, OpenGL rasterizes Generates a fragment for each pixel the fragment covers For each fragment in parallel OpenGL calls user-specified fragment shader: Shading and lighting calculations OpenGL handles z-buffer depth test unless overwritten Summary: in each pass Specify objects, camera, MVP, etc. Specify framebuffer and input/output textures Specify vertex / fragment shaders (When you have everything specified on the GPU) Render","text":"a). Graphics Pipeline b). OpenGL A. Place objects/models Model specification(模型信息) Model transformation B. Set up an easel(画架) View transformation Create /use a framebuffer C. Attach a canvas to the easel指定Pass到framebuffer，就和Unity中FS的SV_TARGET一样。 E. you can also paint multiple pictures using the same easel 一个Rendering Pass，使用一个framebuffer，渲染一个或多个texture（shading, depth, etc.）作为输出 即一个framebuffer可以绑定多个纹理（MRT） Multiple Render Target（MRT）是一种指可以使绘制程序在单帧中同时渲染多个Render Target D. Paint to the canvas This is when vertex / fragment shaders will be used For each vertex in parallel OpenGL calls user-specified vertex shader: Transform vertex (ModelView, Projection), other ops For each primitive, OpenGL rasterizes Generates a fragment for each pixel the fragment covers For each fragment in parallel OpenGL calls user-specified fragment shader: Shading and lighting calculations OpenGL handles z-buffer depth test unless overwritten Summary: in each pass Specify objects, camera, MVP, etc. Specify framebuffer and input/output textures Specify vertex / fragment shaders (When you have everything specified on the GPU) Render c). Shading Language(GLSL)c.1). Initializing Create shader(Vertex and Fragment) Compile shader Attach shader to program Link program Use program c.2). Phong Shader in Assignment 0 Vertex Shader attribute: 顶点附带的属性，FS中不会出现 uniform: 全局变量，由CPU直接传递给GPU varying: 需要插值的变量 highp: 高精度 gl_Position: 类似于Unity的SV_Position，裁剪空间中的顶点位置； Fragment Shader","categories":[{"name":"Games202","slug":"Games202","permalink":"https://whitetail-o.github.io/categories/Games202/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://whitetail-o.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"Games202","slug":"Games202","permalink":"https://whitetail-o.github.io/tags/Games202/"}]},{"title":"Games101_19_20 Cameras Lenses and Light Fileds","slug":"Games101_19_20_Cameras_Lenses_LightFileds","date":"2022-10-03T10:25:10.000Z","updated":"2023-02-04T06:31:58.850Z","comments":true,"path":"2022/10/03/Games101_19_20_Cameras_Lenses_LightFileds/","link":"","permalink":"https://whitetail-o.github.io/2022/10/03/Games101_19_20_Cameras_Lenses_LightFileds/","excerpt":"Lecture19 讲相机的，老本行笔记直接看别人的吧； http://t.csdn.cn/4gODC b). Light Field / Lumingraph(光场) 两者看到的光线信息完全相同，那人眼中的世界就完全相同； b.1). The Plenoptic Function(全光函数) 现实世界可以用一个七维的全光函数进行描述，记录了任意时间，不同位置的不同方向接收光的波长 参数： $\\theta$ ：方位角 $\\phi$：俯仰角 $\\lambda$：波长 $t$：时间 $V_X，V_Y,V_Z$：位置 b.2). Light Field光场则可以认为是记录了任何一个点所接收的任何一个方向的irradiance。 可用四维函数表示，二维描述位置，二维描述方向 光线可由两个点定义，因此这四维可改写成s,t,u,v。即两个平面上的位置； 由此得出，描述一个物体的光场，只需要记录其包围盒上四维的全光函数即可 从uv平面看向st平面，得到的是这个物体从各个方向看的相应的图像； 而从st看向uv，则得到的是这个物体在这个方向的irradiance的集合（不是合起来，而是类似二维数组的集合）即radiance st到uv 记录不同方向的光线radiance（注意和拜耳阵列的区分，这里三色只是代表不同方向）","text":"Lecture19 讲相机的，老本行笔记直接看别人的吧； http://t.csdn.cn/4gODC b). Light Field / Lumingraph(光场) 两者看到的光线信息完全相同，那人眼中的世界就完全相同； b.1). The Plenoptic Function(全光函数) 现实世界可以用一个七维的全光函数进行描述，记录了任意时间，不同位置的不同方向接收光的波长 参数： $\\theta$ ：方位角 $\\phi$：俯仰角 $\\lambda$：波长 $t$：时间 $V_X，V_Y,V_Z$：位置 b.2). Light Field光场则可以认为是记录了任何一个点所接收的任何一个方向的irradiance。 可用四维函数表示，二维描述位置，二维描述方向 光线可由两个点定义，因此这四维可改写成s,t,u,v。即两个平面上的位置； 由此得出，描述一个物体的光场，只需要记录其包围盒上四维的全光函数即可 从uv平面看向st平面，得到的是这个物体从各个方向看的相应的图像； 而从st看向uv，则得到的是这个物体在这个方向的irradiance的集合（不是合起来，而是类似二维数组的集合）即radiance st到uv 记录不同方向的光线radiance（注意和拜耳阵列的区分，这里三色只是代表不同方向） b.3). Light Field Camera 支持先拍照，后期动态调焦、光圈等 Lecture20","categories":[{"name":"Games101","slug":"Games101","permalink":"https://whitetail-o.github.io/categories/Games101/"}],"tags":[{"name":"Games101","slug":"Games101","permalink":"https://whitetail-o.github.io/tags/Games101/"},{"name":"图形学","slug":"图形学","permalink":"https://whitetail-o.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"Games101_17_18 Materials","slug":"Games101_17_18_Materials","date":"2022-10-03T10:20:10.000Z","updated":"2023-02-12T13:17:44.929Z","comments":true,"path":"2022/10/03/Games101_17_18_Materials/","link":"","permalink":"https://whitetail-o.github.io/2022/10/03/Games101_17_18_Materials/","excerpt":"Lecture 17 Materials and AppearancesMaterial == BRDF a). Diffuse / Lambertian Material 对于此类材质，当假定各方向9入射的光线radiance相同，反射的光同样是Uniform的。因为能量守恒（假定不发光，不吸收），使得进入的 Irradiance入 和出去的 Irradiance出 相同； 二重积分 b). Glossy material c). Ideal reflective / refractive material(BSDF) 计算镜面反射方向 几何 方位角 c.1). Specular Refraction 现象：色散、Caustic等 Snell’s Law 可推出只有当光密到光疏介质时，才有可能发生折射；（${n_i\\over n_t}&gt;1$） 折射属于BT(Transmit)DF; BTDF + BRDF = BSDF c.2). Fresnel Reflection(菲涅尔) 反应了特定方向的入射光的反射和折射的比例； 左图是绝缘体的菲涅尔项，右图是导体（金属）的菲涅尔项","text":"Lecture 17 Materials and AppearancesMaterial == BRDF a). Diffuse / Lambertian Material 对于此类材质，当假定各方向9入射的光线radiance相同，反射的光同样是Uniform的。因为能量守恒（假定不发光，不吸收），使得进入的 Irradiance入 和出去的 Irradiance出 相同； 二重积分 b). Glossy material c). Ideal reflective / refractive material(BSDF) 计算镜面反射方向 几何 方位角 c.1). Specular Refraction 现象：色散、Caustic等 Snell’s Law 可推出只有当光密到光疏介质时，才有可能发生折射；（${n_i\\over n_t}&gt;1$） 折射属于BT(Transmit)DF; BTDF + BRDF = BSDF c.2). Fresnel Reflection(菲涅尔) 反应了特定方向的入射光的反射和折射的比例； 左图是绝缘体的菲涅尔项，右图是导体（金属）的菲涅尔项 d). Microfacet Material(微表面材质) 关键： 微表面的法线分布 d.1). Microfacet BRDF 菲涅尔项； Shadowing-masking term 考虑微表面之间的遮挡和阴影； 当光线几乎平行与表面入射时(Grazing angle)，微表面之间遮挡变多 Disterbution of normals e). Isotropic / Anisotropic Materials (BRDFs) Key: directionality of underlying surface e.1). Anisotropic BRDFs 如尼龙、天鹅绒等 f). Properties of BRDFs(BRDF的性质) 非负性 f_{r}\\left(\\omega_{i} \\rightarrow \\omega_{r}\\right) \\geq 0 线性性质 如 高光、漫反射、环境光等的BRDF分开计算最后再求和，和用整体的BRDF和整体的光线一起计算结果相等 可逆性 能量守恒 各向同性时，BRDF可转为三维(两个俯仰角，及方位角之差) Lecture 18 Advanced Topics in Renderinga). Advanced Light Transporta.1). 分类 Unbiased（无偏）： 无论采样多少次，其数学期望和正确的值相同； 否则，则为biased（有偏） 在某种情况下（如采样数增大），其数学期望逐渐向正确的值收敛，则称为consistent（一致的） a.2). Bidirectional Path Tracing(BDPT) 当使用PT，摄影机出发的光线的第一次Bounce大部分是Diffuse时，其不容易得到光线强的方向的贡献，此时BDPT效率更高（语言待优化） a.3). Metropolis Light Transport(MLT) 通过马尔科夫链 在已有样本周围形成新样本，其得到的PDF的形状与被积函数 $f(x)$ 形状一致（此时）方差最小； 优点：适合复杂、困难的光线传播 如：图一和图二SDS(Specular-Diffuse-Specular) 缺点：难以估计何时收敛，不知道采样到什么程度才可以没噪声，造成Dirty； a.4). Photon Mapping(光子映射) 做法之一： 光源发射光子，弹射数次后最终停留在Diffuse表面 摄影机发射光子，弹射数次后最终停留在Diffuse表面 局部密度估值（光子密度越大，该点越亮）； 可使用KD-Tree等加速结构 biased会导致模糊 a.5). Vertex Connection Merging(VCM) 使用BDPT后，对于临近的端点使用Photon Mapping 电影常用 a.6). Instant Radiosity(实时辐射度) 出现亮点原因： 计算直接光照时，换元成了dA，而此处换元依赖于，面积A和立体角w的计算，其中分母是距离的平方，如果距离很接近，那么就会除以一个极小值，使得结果变过大 b). Advanced Appearance Modelingb.1). 分类 b.2). Non-surface modelsb.2.1). Participation media 光在传播过程中，有穿过一个Participation medium，那么它会被吸收、散射 Rendering b.2.2). Hair/Fur Appearance Kajiya_Kay_Model Marschner Model 认为毛发表面类似玻璃柱，其中分为Cuticle（表皮）、Cortex（皮质，吸收光） 光经过毛发被分为3项，R、TT、TRT Double Cylinder Model 考虑了髓质（Medulla，散射光线） 光经过毛发被分为5项，R、TT、TRT、TTs、TRTs b.2.3). Granular Material（颗粒材质） b.3). Surface modelsb.3.1). Translucent(半透明) Material 概念：Translucent实际上和半透明有一定区分，它还涉及到吸收、散射（SSS）等现象。Translucent只是表示光从表面一个地方进入，再从表面一个地方射出（如玉石、人的皮肤、水母等）； Subsurface Scattering BSSRDF： 对BRDF的延伸，一点出射方向的贡献不止有该点，还有周围点的贡献（多了对面积的积分） Dipole Approximation（模拟次表面散射的一种方法） 材质下加入一个光源，材质上也加入一个虚拟光源 b.3.2). Cloth Rendering BRDF 分块，每一块都是Participating Media b.3.3). Detailed Appearance: Motivation $D(h)$ 过于简单，无法模拟细节 Result b.4). Procedural Appearance","categories":[{"name":"Games101","slug":"Games101","permalink":"https://whitetail-o.github.io/categories/Games101/"}],"tags":[{"name":"Games101","slug":"Games101","permalink":"https://whitetail-o.github.io/tags/Games101/"},{"name":"图形学","slug":"图形学","permalink":"https://whitetail-o.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"Materials","slug":"Materials","permalink":"https://whitetail-o.github.io/tags/Materials/"}]},{"title":"Games101_21_22 Animation","slug":"Games101_21_22_Animation","date":"2022-10-03T10:20:10.000Z","updated":"2023-02-12T13:17:31.677Z","comments":true,"path":"2022/10/03/Games101_21_22_Animation/","link":"","permalink":"https://whitetail-o.github.io/2022/10/03/Games101_21_22_Animation/","excerpt":"Lecture 21 Animationa). Historyb). Keyframec). Physical Simualtion c.1). Mass Spring System Idealized spring 但永远不会停止，因此加入摩擦力 中间项为相对速度在向量$ab$方向的投影，因为（处于原长状态时）如果a点不动，b点绕a点做圆周运动，那$f_b=0$； 但是无法表现剪切力（如对角线拉布，布基本形状不变）、弯曲力（out-of-plane，抗拒被像纸一样完全折叠为两个三角形）等 加入两条对角线，以及skip connection 红色较弱，仅其辅助作用；蓝色较强，其主要作用； 其他方式：FEM (Finite Element Method, 有限元) Instead of Springs，考虑力传导 c.2). Particle System 粒子系统不仅可描述微小粒子，还可以描述一些群落； d). Forward Kinematics(FK) 关节（Joint）分类： e). Inverse Kinematics(IK) 解决多个解的方法：梯度下降 f). Rigging Blend shapes: 混合控制点或骨骼位置 g). Motion Capture / Facial Motion Capture","text":"Lecture 21 Animationa). Historyb). Keyframec). Physical Simualtion c.1). Mass Spring System Idealized spring 但永远不会停止，因此加入摩擦力 中间项为相对速度在向量$ab$方向的投影，因为（处于原长状态时）如果a点不动，b点绕a点做圆周运动，那$f_b=0$； 但是无法表现剪切力（如对角线拉布，布基本形状不变）、弯曲力（out-of-plane，抗拒被像纸一样完全折叠为两个三角形）等 加入两条对角线，以及skip connection 红色较弱，仅其辅助作用；蓝色较强，其主要作用； 其他方式：FEM (Finite Element Method, 有限元) Instead of Springs，考虑力传导 c.2). Particle System 粒子系统不仅可描述微小粒子，还可以描述一些群落； d). Forward Kinematics(FK) 关节（Joint）分类： e). Inverse Kinematics(IK) 解决多个解的方法：梯度下降 f). Rigging Blend shapes: 混合控制点或骨骼位置 g). Motion Capture / Facial Motion Capture Lecture 22a). Single Particle Simulation Velocity vector field: 给定位置，可以得出改点速度。和磁场、电场类似； Oridinary Differential Equation(ODE, 常微分方程) 已知解得 t 时刻，粒子的位置和速度，需求得下一时刻的粒子位置； 方法1：显式欧拉法（Explicit Euler method），用差分代替微分，但会引起误差，且稳定性差； a.1). Euler’s Method 缺点： 存在误差，可通过减小步长（$\\Delta t$）来减少误差； 稳定性差，如速度场为同心圆时，不管步长多小都会逐渐偏移（diverge） a.2). Combating Instability a.2.1). Midpoint Method 计算下一时刻位置后取中点，得到中点速度，在计算下一时刻位置时，使用中点速度 a.2.2). Adaptive Step Size a.2.3). Implicit Euler Method 使用下一时刻的速度和加速度，并求解 、 龙格库塔 a.2.4). Position-Based / Verlet Integration 非基于物理 时间快 b). Rigid Body Simulation 与单粒子类似 c). Fluid Simulationc.1). A Simple Position-Based Method c.2). Eulerian vs. Lagrangian 拉格朗日（质点法）：考虑单个粒子的运动 欧拉（网格法）：考虑不同位置的网格 Material Point Method (MPM ，混合上两种方法)","categories":[{"name":"Games101","slug":"Games101","permalink":"https://whitetail-o.github.io/categories/Games101/"}],"tags":[{"name":"Games101","slug":"Games101","permalink":"https://whitetail-o.github.io/tags/Games101/"},{"name":"图形学","slug":"图形学","permalink":"https://whitetail-o.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"Animation","slug":"Animation","permalink":"https://whitetail-o.github.io/tags/Animation/"}]},{"title":"Games101-13-16 RayTracing","slug":"Games101_13_16_RayTracing","date":"2022-10-03T10:15:10.000Z","updated":"2023-02-12T13:18:29.194Z","comments":true,"path":"2022/10/03/Games101_13_16_RayTracing/","link":"","permalink":"https://whitetail-o.github.io/2022/10/03/Games101_13_16_RayTracing/","excerpt":"Lecture 13 Ray Tracinga). vs. Rasterization 光栅化难以表现全局（global）效果，如 （软）阴影（Soft shadows） 光线反弹超过一次（Glossy reflection） Indirect illumination（间接光照） Rasterization is fast, but quality is relatively low； b.). Basic Ray-Tracing Algorithm 光追中光线的性质： 光是沿直线传播的； 光相交时，并不产生干扰； 光从光源出发，传播到眼睛（由于光路可逆，也可是光线从眼睛出发，传播到光源） b.1). Ray Casting 做法： Generate an image by casting one ray per pixel;（生成从眼睛出发的光线） Check for shadows by sending a ray to the light;（检查光线投射点是否可传播到光源） 光线由眼睛出发，可不再使用深度缓存； 投射点到光源发射Shadow Ray，查看该点是否在阴影里（是否对光源可见）；","text":"Lecture 13 Ray Tracinga). vs. Rasterization 光栅化难以表现全局（global）效果，如 （软）阴影（Soft shadows） 光线反弹超过一次（Glossy reflection） Indirect illumination（间接光照） Rasterization is fast, but quality is relatively low； b.). Basic Ray-Tracing Algorithm 光追中光线的性质： 光是沿直线传播的； 光相交时，并不产生干扰； 光从光源出发，传播到眼睛（由于光路可逆，也可是光线从眼睛出发，传播到光源） b.1). Ray Casting 做法： Generate an image by casting one ray per pixel;（生成从眼睛出发的光线） Check for shadows by sending a ray to the light;（检查光线投射点是否可传播到光源） 光线由眼睛出发，可不再使用深度缓存； 投射点到光源发射Shadow Ray，查看该点是否在阴影里（是否对光源可见）； c). Whitted-Style Ray Tracing(Recursive, 递归) 过程： 生成眼睛到像素a的光线（Primary ray），打到第一个与光线相交的点； 形成反射（镜面反射）和折射的光线（Secondary rays，之后的都是Secondary rays）； 对每条光线与object的交点做到光源的光线（Shadow rays）； 将所有Shadow rays未被阻挡的光线的着色结果相加，即为像素a的着色结果； c.1). Ray-Surface Intersection（求交点）c.1.1). 与球形相交： 推广：与隐式表面相交 c.1.2). 与三角形求交： 几何上：判断内外； 空间内任意一点为起点做一光线，若该光线与object（封闭）交点数为奇数，则该点在object内；若交点数为奇数，则该点在object外；（缠绕数的奇-偶原则） 计算过程： 即 $r(t)=o+td,0\\leq t &lt; \\infty$ 和 $(p-p’)·N=0$ 联立求 $t$； 之后求得点P是否在三角形内； Möller Trumbore Algorithm 按传统求解，求出 $t$ 后，还需要判断 P 点是否在三角形内，较为繁琐，因此提出Möller Trumbore Algorithm 射线$r(t)=O+tD$ ，与由重心坐标表示的三角形上的点 $P$ 求解（三个式子，三个未知量，根据克拉默必定有解）； 求得交点后，可通过重心坐标得知该点是否在三角形外； c.2). Acclerating Ray-Surface Intersection 原因：当需要求得光线最近的交点时，需要遍历场景所有三角面，速度慢，需要加速； c.2.1). Axis-Aligned Bounding Box(AABB，轴对齐包围盒) Bounding Volumes 思想：当物体不与包围体积相交时，更不可能和物体相交； Bounding Box（AABB for example）： 理解：盒子是3对对立的面的交集； Axis-Aligned Bounding Box(AABB) AABB包围盒的面总在xy/xz/yz平面； 光线与AABB求交： 2D情况下（3D同理） 思想： 光线进入Box：只有当光线进入所有的对立面； 光线出Box：只要光线出射一个对立面； 对于3D的Box，$t_{enter}=max\\{t_{min}\\},t_{exit}=min\\{t_{max}\\}$； 如果 $t_{enter}&lt;t_{exit}$，则光线经过Box； 对于 $t_{enter}$ 和 $t_{exit}$ 正负情况的考虑： $t_{exit}&lt;0$：不相交（Box在光线后边） $t_{exit}&lt;0$ and $t_{enter}&lt;0$：光线起点在盒子里，一定相交 当且仅当 $t_{enter}&lt;t_{exit}\\quad\\&amp;\\&amp;\\quad t_{exit}\\geq0$，光线与AABB相交； 为什么使用AABB：求交方便； Lecture 14&amp;15 Ray Tracing(Acceleration &amp; Radiometry; Light Transport &amp; Global Illumination)a). Uniform Spatial Partitions（统一空间分区） Heuristic: #cells = C * #objs C ≈ 27 in 3D 缺陷： 格子大小相同，浪费空间； 对于空间分布不均匀的场景容易造成“Teapot in a stadium” problem，浪费性能； b). Spatial Partition 常见的空间划分的类型： Oct-Tree（3维中是八叉树，2维中是四叉树；$2^n$叉树，n=维度） 受维度影响； KD-Tree； 每次只划分一次，如果是三维则按x，y，z方向循环划分； BSP-Tree b.1). KD-Tree 预处理：对空间进行划分，对于子空间每次只划分一次（1、2、3划分省略）； 树节点（Internal node）的数据结构： 划分轴：x-, y- , or z-axis; 划分位置：分割平面沿轴的坐标；（？） 子节点； 不存储object； 叶子节点数据结构： object的列表 过程： 光线和叶子节点1（为方便把$1$暂看作叶子节点，尽管个节点应该继续划分，$2,3$同理）相交，判断光线和$1$中储存的object是否相交（无相加，继续）； …… 光线和叶子节点3相交，判断光线和$1$中储存的object是否相交，相交，记录$t_{hit}$； 缺点： 预处理的过程中，物体（三角形）和网格求交难； 如三角形和Box求交，有可能是一个小Box穿过三角形（被三角形“包裹”） 同一个Object可能储存在多个叶子节点中； c). Bounding Volume Hierarchy (BVH) 特征：先将object分为两组，再重新计算包围盒，使得同一个obejct只会在一个叶子节点中出现；（但会造成Bounding Box空间的冗余） 过程： 找到包围盒； 递归地将物体的集分为两个子集； 重新计算子集的包围盒； 满足条件时停止； 储存objects到对应的叶子节点； 划分子节点： 选择一个维度去划分； Heuristic #1: 选择最长的轴去划分； Heuristic #2: 选择中间的object的位置去划分；（快速选择算法） BVHs的数据结构： 非叶子节点： Bounding box Children: pointer to child nodes 叶子节点： Bounding box List of objects Nodes represent subset of primitives in scene BVH Traversal: 空间划分和物体划分: d). Radiometryd.1). Radiant Energy and Flux(Power) Radiant Energy(辐射能量): Definition: Radiant energy is the energy of electromagnetic radiation. It is measured in units of joules, and denoted by the symbol: Q[J=Joule] Flux(辐射通量): Definition: Radiant flux (power) is the energy emitted, reflected, transmitted or received, per unit time. \\Phi \\equiv \\frac{\\mathrm{d} Q}{\\mathrm{~d} t}[\\mathrm{~W}=\\mathrm{Watt}][\\operatorname{lm}=\\text {lumen}] Important Light Measurements of Interest d.2). Radiant Intensity(辐射强度) 定义：单位立体角上，产生的、反射的、接收的辐射通量。符号：I；单位：瓦特/sr、lm/sr、candela、cd。 立体角(solid angle)是有方向的，所以辐射强度是一个方向有关的属性 d.2.1). Solid angle 角度（2D）： 弧长除以半径； $\\theta={l\\over r}$ 立体角：立体角面积除以半径的平方 $\\Omega=\\frac{A}{r^{2}}$ 球体的立体角为$4\\pi$ d.2.2). 计算过程 立体角微分： 二重积分计算，总的立体角 = 球面上无数个单位立体角的加和，即∫∫sinθdθdφ积分限也比较好理解：θ：0 → π，一个半圆弧， φ：0 → 2π，用半圆转一整圈得到球面 通常把ω当做方向向量来理解，这样比较好描述intensity 如果点光源向三维空间中均匀的辐射出能量，怎么描述强度？ I = Φ / 4πΦ：点光源单位时间内，向三维空间中辐射出的能量4π：整个三维空间的总立体角其比值就是单位立体角上的辐射通量 d.2.3). Irradiance(辐照度) 定义：每单位面积（与光线垂直，Lambert’s Cosine Law）的能量 Lambert’s Cosine Law e.g. 太阳高度角造成四季变化 随半径变大，Irradiacne变小，而radiant intensity不变； d.2.4). Radiance(辐亮度) 介绍： Radiance是和光线有关的量； 渲染就是在计算radiance； 单位：The radiance(luminance) is the power emitted. reflected, transmitted or receivedd by a surface, per unit solid angle, per projected unit area. 理解： Radiance定义：power per unit solid angle, per projected unit area. Irradiance: power per projected unit area Intensity: power per solid angle So: Radiance: Irradiance per solid angle ​ - Incident Radiance Radiance: Intensity per projected unit area ​ - Exiting Radiance Incident Radiance: The irradiance per unit solid angle arriving at the surface 即 $\\omega$ 方向的光线对于 $dA$ 的贡献； Exiting Radiance: The intensity per unit projected area leaving the surface 即面积光 $dA$ ，对 $\\omega$ 出射方向的贡献； Irradiance vs. Radiance Irradiance和Radiance的区别在于方向性； 图中，$dA$ 的辐照度 $E(p)$ 为各方向（半圆）对 $dA$ 的贡献。$dA$ 的Radiance $L_i(p,w)$ 为入射方向 $d\\omega$ 对 $dA$ 的贡献； 即，Irradiance $E(p)$ 是 radiance $L_i(p,w)$ 对于各个立体角的积分，$L_i(p,\\omega)$ 是 $E(p)$ 方向 $\\omega$ 的积分； c). BRDF(Bidirectional Reflectance Distribution Function)Ver Games101 过程：光线照射到一点（$p$），该点吸收能量，再辐射出去； 定义： 分母：${\\omega}_i$ 方向入射的radiance $L_i(x,{\\omega}_i)$，被一点吸收后，辐射往各个方向的Irradiance $E_i({\\omega}_i)$； 分子：$E_i({\\omega}_i)$，对 ${\\omega}_r$ 方向radiance的贡献 $L_r(x,{\\omega}_r)$ Ver self: 定义：BRDF（双向反射分布函数, bidirectional reflective distribution function）， 是指当一束光从某个方向( $\\vec l$ )照射到某个点($p$)上时，在某个方向上( $\\vec v$ )的出射辐射通量占总的入射辐射通量的比例 基于物理着色：BRDF - Maple的文章 - 知乎 关于brdf的两件小事 - Dua的文章 - 知乎 可以理解对于某一微小（对立体角）出射光线ωi，某一微小入射光线ωj对其radiance的贡献； 也可以理解成某一微小入射光线ωj，弹射到某一方向的微小立体角ωi的光线强度的比值； 由于为了方便测量，不定义为radiance相除（即如果按照我们一开始对入射方向 微分的方式定义brdf，那么科学家们只需要使用一个极小的光源从 方向入射到点p，就可以测得brdf的值。但是如果定义为radiance相除，就很难输入一个填充立体角刚好等于1的光源。)正常单位为： {1\\over{sr}} d). Rendering equationd.1). 简介 The Reflection Equation $f_r(p,w_i,w_r)$ 为该点的BRDF 问题： incoming radiance 不止来源于光源，也来源于其他反射（递归）； 未考虑自发光情况（加入自发光项，变为渲染方程） The Rendering Equation 加入了自发光项 $L_e(p,{\\omega}_o)$ 考虑多次反射 注意：该方程假定所有方向都是朝外的； $H^2$ 和 $\\Omega$ 表示半球的积分域； d.2). 理解 Reflection Equation: 反射的Radiance是各个方向光源对出射方向Radiance贡献的积分； 未考虑光线多次弹射 Rendering Equation: 考虑多次弹射，即其他物体反射的光线也会对出射方向 ${\\omega}_r$ 的Radiance做出贡献； 对于渲染方程，只有 $L_r(x,{\\omega}_r)$ 和 $L_r(x’,-{\\omega}_i)$ 是未知的； 简化渲染方程： Rendering Equation as Integral Equation Linear Operator Equation $E$ 环境中自发光对应向量，$L$ Radiance对应的向量； $K$ 反射算子（矩阵） 对于Rendering Equation的线性形式，我们可以用以下式子逼近（类似泰勒展开）： Rendering Equation的线性形式对于光追的启示： $E$ 为自发光，$KE$ 为 直接光照（即弹射一次），$K^2E$ 为间接光照（弹射两次） 全局光照（Global illumination, GI）：直接光照+间接光照 基础的光栅化只做了自发光和直接光照，即 $E$ 和 $KE$ 对比 上方玻璃灯：两次弹射时，光线从摄影机出发不能从玻璃罩中射出，因此其为黑色。而四次弹射时，光线从摄影机出发可以从玻璃罩中射出； 当bounce数目增大时，亮度会趋于一个值，而不会无限增大； e). Probability Lecture 16 Ray Tracing 4 (Monte Carlo Path Tracing)a). Monte Carlo Integration 使用原因：一些函数过于复杂，因此对于特定积分域，不求不定积分，只求其积分的结果。（一种数值方法） 过程：对函数的随机样本进行平均来估计函数的数值； 除以 $p(x_i)$ 是一种加权，因为对于积分域上样本的采样可能是不均匀随机采样 均匀采样的情况： Some notes： 采样越多，方差越小 如在$x$上积分，要采样$x$ b). Paht Tracingb.1). vs Whitted-Style Ray Tracing Whitted-Style Ray Tracing 遇到光滑物体会只会 反射/折射（择一进行） 无法表现Glossy reflection 遇到漫反射物体停止弹射 没有Color Blooding(eg.direct illumination)，考虑不到漫反射物体之间的光线传播 But the rendering equation is correct L_{o}\\left(p, \\omega_{o}\\right)=L_{e}\\left(p, \\omega_{o}\\right)+\\int_{\\Omega^{+}} L_{i}\\left(p, \\omega_{i}\\right) f_{r}\\left(p, \\omega_{i}, \\omega_{o}\\right)\\left(n \\cdot \\omega_{i}\\right) \\mathrm{d} \\omega_{i} 需要做的： 解决半球域的定积分 蒙特卡洛积分 递归 b.2). A Simple Monte Carlo Solution(Direct illumination) 渲染一个Pixel（Point），当前 之考虑直接光照 当 $\\omega_i$ 与light相交时，计算该方向的radiance；与Box相交时，则该方向的radiance=0； P-Code b.3). Global illumination(加入递归)b.3.1). GI and problems P-Code Problem1: Explosion of #rays as #bounces go up 解决方法： N=1（N=1即Path Tracing，Distributed Ray Tracing if N != 1） N=1会造成较多的Noise，因此采用Subpixel，即每个像素内多次采样（Samples per pixel, SPP） Problem2: 递归不会停止 现实世界中，光线的弹射次数是无限的 简单地，减少弹射次数 == 减少能量； 解决方法： Russian Roulette(RR, 俄罗斯轮盘赌) b.3.2). Russian Roulette(RR, 俄罗斯轮盘赌) 先前一点的着色结果是 $L_o$，引入RR后 With probability $P$, shoot a ray and return the shading result divided by P: Lo / P With probability $1-P$, don’t shoot a ray and you’ll get 0 由此可得出数学期望 $E=P \\cdot\\left(\\frac{L_{o}}{p}\\right)+(1-P) \\cdot 0=L_{o}$ b.3.3). 优化 计算直接光照时，如对点P向各个方向均匀采样，当光源小时，直接光照的贡献会小，造成较多的噪声； 解决方法： 换元，使渲染方程对光源面积 $A$ 进行积分，pdf = 1/A d \\omega=\\frac{d A \\cos \\theta^{\\prime}}{\\left\\|x^{\\prime}-x\\right\\|^{2}} (Note: \\theta^{\\prime} , not \\theta ) 立体角可以看前面辐射度量学的部分 过程：（直接光照，间接光照分开计算） light source (direct, no need to have RR) other reflectors (indirect, ues RR) P-Code（未考虑遮挡） 遮挡 附上上学期做的光追（借鉴smallpt）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531/*** 采用Monte Carlo Path Tracing* 漫反射采用的是Lambert* 定义了三角面片和球体，其中三角面片可多片合成一个对象，* 与三角面片求交则使用克拉默法则，而基于此做条件上的修改就可构建平行四边形，因此将平行四边形也归入三角面片* 用平行四边形代替两个三角面片在适用且数量较多的情况下可显著提高运算效率* 球体求交运算量小于三角面片，因此墙壁通过大半径的球体构建** 由于想要表现出计算过程，许多数学运算未化简，运算效率不高* 由于未使用BVH等方式约束，三角面片较为影响性能* 目前场景除墙面外中有两个球体（镜面反射以及玻璃），以及一个立方体，通过6个三角面片（平行四边形）构成** 由于为了提高运算效率，本程序中使用的蒙特卡洛采样方向约束在朝向其他对象的方向（射线在必定与其他对象相交的范围内随机），* 但三角面片的约束范围较复杂，因此不支持将三角面片定义为光源** 虽会增加噪声，为了运算效率，除了最大迭代次数，还引入经处理可使radiance的数学期望与原值相同的Russian Roulette，开始RR的次数为最大迭代次数除以2* * 由于运算量大，采样默认设置为1，如想提高运行效率可删除掉三角面片* * 绘制通过glut* 程序输出为ppm格式图片**/#define _CRT_SECURE_NO_WARNINGS#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;gl/glut.h&gt;#define DEPTH_MAX 10 //最大迭代次数#define WIDTH 512#define HIGHT 385double M_PI = 3.1415926535;double erand48(unsigned short xsubi[3]) &#123; return (double)rand() / (double)RAND_MAX;&#125;struct Vec &#123; double x, y, z; Vec(double _x = 0, double _y = 0, double _z = 0) &#123; x = _x; y = _y; z = _z; &#125;; Vec operator+(const Vec&amp; b) const &#123; return Vec(x + b.x, y + b.y, z + b.z); &#125;; //加 Vec operator-(const Vec&amp; b) const &#123; return Vec(x - b.x, y - b.y, z - b.z); &#125; //减 Vec operator*(double b) const &#123; return Vec(x * b, y * b, z * b); &#125;; //数乘 Vec mult(const Vec&amp; b) const &#123; return Vec(x * b.x, y * b.y, z * b.z); &#125; //数乘 Vec&amp; norm() &#123; return *this = *this * (1 / sqrt(x * x + y * y + z * z)); &#125; //单位向量 double dot(const Vec&amp; b) const &#123; return x * b.x + y * b.y + z * b.z; &#125; //点乘 Vec cross(const Vec&amp; b) const &#123; return Vec(y * b.z - z * b.y, z * b.x - x * b.z, x * b.y - y * b.x); &#125; //叉乘&#125;;struct Ray &#123; Vec o, d; Ray(Vec _o, Vec _d) : o(_o), d(_d) &#123;&#125;;&#125;;enum Refl_t &#123; //反射类型 DIFF, SPEC, REFR&#125;;struct MeshTriangle &#123; // 三角面片 const Vec* verts; // 顶点 const int* vertsIndex; //顶点排序 const int numTris; // 三角形数量 Vec* vertices; Vec e, c; // emission, color Refl_t refl; int isTriangle; //顶点， 顶点列表（决定构建顺序以及法线正负）， 三角面片数量， emission, color， 材质， 是否是三角形（或平行四边形） MeshTriangle(const Vec* _verts, const int* _vertsIndex, const int _numTris, Vec _e, Vec _c, Refl_t _refl, int _isTriangle = 1) : verts(_verts), vertsIndex(_vertsIndex), numTris(_numTris), e(_e), c(_c), refl(_refl), isTriangle(_isTriangle) &#123; vertices = new Vec[3 * numTris]; for (int i = 0; i &lt; numTris; i++) &#123; for (int n = 0; n &lt; 3; n++) &#123; vertices[3 * i + n] = verts[vertsIndex[3 * i + n]]; &#125; &#125; &#125; void move(int x, int y, int z) &#123; // 方便调试 for (int i = 0; i &lt; 3 * numTris; i++) &#123; vertices[i] = vertices[i] + Vec(x, y, z); &#125; &#125; double intersect(const Ray&amp; r, Vec&amp; n) const &#123; // n返回法线 double tnear = 1e20; double tnear_out; //std::cout &lt;&lt; numTris &lt;&lt; std::endl; // Vec temp_normal; double temp = 1e20; bool flag = false; for (int i = 0; i &lt; numTris; i++) &#123; Vec&amp; v0 = vertices[3 * i]; Vec&amp; v1 = vertices[3 * i + 1]; Vec&amp; v2 = vertices[3 * i + 2]; /*std::cout &lt;&lt; &quot;x:&quot; &lt;&lt; v0.x &lt;&lt; &quot;y:&quot; &lt;&lt; v0.y &lt;&lt; &quot;, z:&quot; &lt;&lt; v0.z &lt;&lt; std::endl; std::cout &lt;&lt; &quot;x:&quot; &lt;&lt; v1.x &lt;&lt; &quot;y:&quot; &lt;&lt; v1.y &lt;&lt; &quot;, z:&quot; &lt;&lt; v1.z &lt;&lt; std::endl; std::cout &lt;&lt; &quot;x:&quot; &lt;&lt; v2.x &lt;&lt; &quot;y:&quot; &lt;&lt; v2.y &lt;&lt; &quot;, z:&quot; &lt;&lt; v2.z &lt;&lt; std::endl;*/ Vec E1 = v1 - v0; Vec E2 = v2 - v0; n = E1.cross(E2).norm(); //三角形法线 Vec S = r.o - v0; Vec S1 = (r.d).cross(E2); Vec S2 = S.cross(E1); //tnear为时间 沿着三角形方向 t的为正 //u,v 为重心坐标前的参数 都得为非负的还得小于1 double S1E1 = S1.dot(E1); tnear = 1.0f / S1E1 * S2.dot(E2); double u = 1.0f / S1E1 * S1.dot(S); double v = 1.0f / S1E1 * S2.dot(r.d); double k = 1 - u - v; bool judge; if (isTriangle) &#123; judge = tnear &gt; 0 &amp;&amp; v &gt;= 0 &amp;&amp; v &lt;= 1 &amp;&amp; u &gt;= 0 &amp;&amp; u &lt;= 1 &amp;&amp; k &gt;= 0; &#125; else &#123; judge = tnear &gt; 0 &amp;&amp; v &gt;= 0 &amp;&amp; v &lt;= 1 &amp;&amp; u &gt;= 0 &amp;&amp; u &lt;= 1; &#125; if (judge) &#123; //不加k &gt;= 0 可构建平行四边形 if (!flag) &#123; tnear_out = tnear; temp_normal = n; flag = true; &#125; if (tnear &lt; tnear_out) &#123; tnear_out = tnear; temp_normal = n; &#125; &#125; &#125; if (flag) &#123; n = temp_normal; //std::cout &lt;&lt; tnear_out &lt;&lt; std::endl; return (tnear_out &lt; 1e20 &amp;&amp; tnear_out &gt; 0) ? tnear_out : 0; &#125; else &#123; return 0; &#125; &#125; ~MeshTriangle() &#123; delete[] vertices; &#125;&#125;;struct Sphere &#123; double rad; // radius Vec p, e, c; // position, emission, color Refl_t refl; Sphere(double _rad, Vec _p, Vec _e, Vec _c, Refl_t _refl) : rad(_rad), p(_p), e(_e), c(_c), refl(_refl) &#123;&#125; double intersect(const Ray&amp; r) const &#123; Vec op = p - r.o; double t, eps = 1e-4; double b_12 = op.dot(r.d); // -b / 2 double det_14 = b_12 * b_12 - op.dot(op) + rad * rad; // det / 4 double det_14_sqrt = sqrt(det_14); return (t = b_12 - det_14_sqrt) &gt; eps ? t : ((t = b_12 + det_14_sqrt) &gt; eps ? t : 0); //if (det_14 &lt; 0) &#123; // return 0; //&#125; //else &#123; // t = b_12 - det_14_sqrt; // if (t &gt; eps) return t; //考虑到浮点数的缺陷 // t = b_12 + det_14_sqrt; // if (t &gt; eps) return t; // return 0; //交点为反向延长线，不考虑 //&#125; &#125;&#125;;Sphere spheres[] = &#123;//Scene: radius, position, emission, color, material Sphere(1e5, Vec(1e5 + 1,40.8,81.6), Vec(),Vec(.75,.25,.25),DIFF),//Left Sphere(1e5, Vec(-1e5 + 99,40.8,81.6),Vec(),Vec(.25,.25,.75),DIFF),//Rght Sphere(1e5, Vec(50,40.8, 1e5), Vec(),Vec(.75,.75,.75),DIFF),//Back Sphere(1e5, Vec(50,40.8,-1e5 + 170), Vec(),Vec(.25,.25,.25), DIFF),//Frnt Sphere(1e5, Vec(50, 1e5, 81.6), Vec(),Vec(.75,.75,.75),DIFF),//Botm Sphere(1e5, Vec(50,-1e5 + 81.6,81.6),Vec(),Vec(.75,.75,.75),DIFF),//Top Sphere(12,Vec(27,12.5,47), Vec(),Vec(1,1,1) * .999, SPEC),//Mirr Sphere(16.5,Vec(73,16.5,78), Vec(),Vec(1,1,1) * .999, REFR),//Glas Sphere(1.5, Vec(50,81.6 - 16.5,81.6),Vec(4,4,4) * 100, Vec(), DIFF) //Lite&#125;;Vec verts[8] = &#123; //vertices Vec(26, 0, 95), Vec(41, 0, 90), Vec(31, 0, 110), Vec(46, 0, 105), Vec(26, 40, 95), Vec(41, 40, 90), Vec(31, 40, 110), Vec(46, 40, 105),&#125;;int vertsIndex[18] = &#123; 0, 4, 1, // 顺序影响法线方向 1, 5, 3, 3, 7, 2, 2, 6, 0, 6, 7, 4, 2, 0, 3,&#125;;//int vertsIndex[36] = &#123; 0, 4, 1, // 顺序影响法线方向// 1, 4, 5,// 1, 5, 7,// 1, 7, 3,// 3, 7, 6,// 3, 6, 2,// 2, 6, 0,// 0, 6, 4,// 6, 7, 4,// 7, 5, 4,// 2, 0, 3,// 3, 0, 1,// &#125;;MeshTriangle meshTriangles[] = &#123; MeshTriangle(verts, vertsIndex, 6, Vec(), Vec(.25, .75, .25), DIFF, 0),&#125;; //vertices, vertsIndex, numTris, emission, color, materialint numSphere = sizeof(spheres) / sizeof(Sphere);int numMeshTriangle = sizeof(meshTriangles) / sizeof(MeshTriangle);inline double clamp01(double x) &#123; //截断到01 return x &lt; 0 ? 0 : (x &gt; 1 ? 1 : x);&#125;inline double gamma(double x, float n = 2.2) &#123; return pow(clamp01(x), 1 / n);&#125;inline int toInt255(double x) &#123; //gamma取2.2, 四舍五入 return int(gamma(x) * 255 + .5);&#125;inline void UpdateProgress(float progress) //进度提醒&#123; int barWidth = 70; std::cout &lt;&lt; &quot;[&quot;; int pos = barWidth * progress; for (int i = 0; i &lt; barWidth; ++i) &#123; if (i &lt; pos) std::cout &lt;&lt; &quot;=&quot;; else if (i == pos) std::cout &lt;&lt; &quot;&gt;&quot;; else std::cout &lt;&lt; &quot; &quot;; &#125; //三位小数 std::cout &lt;&lt; &quot;] &quot; &lt;&lt; std::setiosflags(std::ios::fixed) &lt;&lt; std::setiosflags(std::ios::right) &lt;&lt; std::setprecision(3) &lt;&lt; float(progress * 100.0) &lt;&lt; &quot; %\\r&quot;; std::cout.flush();&#125;inline bool intersect(const Ray&amp; r, double&amp; t, int&amp; id, Vec&amp; normal) &#123; //t最短的相交, n 返回法线 double n = sizeof(spheres) / sizeof(Sphere) + numMeshTriangle; double d; double inf = t = 1e20; for (int i = 0; i &lt; n; i++) &#123; //std::cout &lt;&lt; i &lt;&lt; std::endl; // if (i &lt; numSphere) &#123; if ((d = spheres[i].intersect(r)) &amp;&amp; d &lt; t) &#123; // 注意：不自交（真坑啊。。。） t = d; id = i; &#125; &#125; else &#123; d = meshTriangles[i - numSphere].intersect(r, normal); if (d &amp;&amp; d &lt; t) &#123; //std::cout &lt;&lt; d &lt;&lt; std::endl; t = d; id = i; &#125; &#125; &#125; return t &lt; inf;&#125;//Xi:随机种子 E：whether to include emissive colorVec radiance(const Ray&amp; r, int depth, unsigned short* Xi, int E = 1) &#123; double t; //与交点距离 int id = 0; Vec temp_n; if (!intersect(r, t, id, temp_n)) &#123; //id &gt;= numSphere说明是三角面片 return Vec(); //miss &#125; //std::cout &lt;&lt; id &lt;&lt; std::endl; // Vec x = r.o + r.d * t;// Ray hit point Vec n; //normal(射线经过obj内部后,n为负数) Vec f; Refl_t obj_refl; Vec obj_e; if (id &lt; numSphere) &#123; const Sphere&amp; obj = spheres[id]; n = (x - obj.p).norm(); f = obj.c; obj_refl = obj.refl; obj_e = obj.e; &#125; else &#123; //std::cout &lt;&lt; id &lt;&lt; std::endl; //if (x.x == 36) std::cout &lt;&lt; &quot;x:&quot; &lt;&lt; x.x &lt;&lt; &quot;y:&quot; &lt;&lt; x.y &lt;&lt; &quot;, z:&quot; &lt;&lt; x.z &lt;&lt; std::endl; const MeshTriangle&amp; obj = meshTriangles[id - numSphere]; n = temp_n.norm(); f = obj.c; obj_refl = obj.refl; obj_e = obj.e; &#125; if (depth &gt; DEPTH_MAX) &#123; return Vec(); &#125; //Vec n = (x - obj.p).norm(); // sphere normal(射线经过obj内部后,n为负数) Vec n_real = n.dot(r.d) &lt; 0 ? n : n * -1; //sphere normal //std::cout &lt;&lt; &quot;x:&quot; &lt;&lt; f.x &lt;&lt; &quot;y:&quot; &lt;&lt; f.y &lt;&lt; &quot;, z:&quot; &lt;&lt; f.z &lt;&lt; std::endl; // //用rgb最大值作为Russian Roulette不终止的概率p //RR适用因为p * Li * (1/p) + 0 * (1-p) = Li，即数学期望等于Li double p = f.x &gt; f.y &amp;&amp; f.x &gt; f.z ? f.x : f.y &gt; f.z ? f.y : f.z; if (++depth &gt; int(DEPTH_MAX / 2) || !p) if (erand48(Xi) &lt; p) f = f * (1.0 / p); else return obj_e * E; //std::cout &lt;&lt; &quot;miss&quot; &lt;&lt; std::endl; if (obj_refl == DIFF) &#123; //std::cout &lt;&lt; &quot;DIFF&quot; &lt;&lt; std::endl; // //采用Lambert，出射方向任意，以极坐标的方式构建随机弹射光线方向 double r1 = 2 * M_PI * erand48(Xi); double r2 = erand48(Xi); double r2_sqrt = sqrt(r2); //标准正交系 Vec w = n_real; Vec u = ((fabs(w.x) &gt; 0.1 ? Vec(0, 1) : Vec(1)).cross(w)).norm(); Vec v = w.cross(u); Vec d = (u * cos(r1) * r2_sqrt + v * sin(r1) * r2_sqrt + w * sqrt(1 - r2)).norm(); //Ray direction, 即path tracing， N=1的那条射线 Vec e; for (int i = 0; i &lt; numSphere; i++) &#123; const Sphere&amp; s = spheres[i]; if ((s.e.x &lt;= 0 &amp;&amp; s.e.y &lt;= 0 &amp;&amp; s.e.z &lt;= 0) || i &gt;= numSphere) continue; //skip no radiance Vec sw = s.p - x, su = ((fabs(sw.x) &gt; 0.1 ? Vec(0, 1) : Vec(1)).cross(sw)).norm(), sv = sw.cross(su); //x发出射向id=i的范围内随机方向的采样射线 double cos_a_max = sqrt(1 - s.rad * s.rad / (x - s.p).dot(x - s.p)); double eps1 = erand48(Xi), eps2 = erand48(Xi); //double cos_a = 1 - eps1*(1. - cos_a_max); double cos_a = 1 - eps1 + eps1 * cos_a_max; double sin_a = sqrt(1 - cos_a * cos_a); double phi = 2 * M_PI * eps2; Vec l = su * cos(phi) * sin_a + sv * sin(phi) * sin_a + sw * cos_a; l.norm(); // Note: // 根据Monte Carlo Integration得到相应形式的渲染方程(反射率方程) // Lo(p,wo) = (1/N)*∑(i~n) &#123;(Li(p,wi)*fr(p,wi,wo)*(n*wi)) / pdf&#125; // Lo:入射radiance, p:单位半球球心, wo:入射方向（微小立体角） // N:取样数（光线数）, Li wi略 // fr:BRDF, n:法线方向 // pdf: 分布函数 // 由于采用的是path tracing N取1, Lo(p,wo) = (Li(p,wi)*fr(p,wi,wo)*(n*wi)) / pdf // 当采用Lambert漫反射的BRDF可推导出为1/pi // 对半球均匀采样时，pdf=1/单位半圆面积，但射线的方向是在于法线的夹角最大是a_max, 采样的区域被限定 // 球形对角度A(法线方向与某一点的夹角)积分， 得S = ſ 2 * pi * r*r sinA dA = abs(2 * pi * r * r * cosA), r=1 // 易得pdf = 1 / 球部分表面积 = 1 / (2 * pi * r * r(1-cos_a_max)) = 1 / (2 * pi * (1-cos_a_max)) // Lo(p,wo) = (Li(p,wi)*fr(p,wi,wo)*(n*wi)) / pdf = Li(p,wi) * (1 / pi) * cos_a * (2 * pi * (1 - cos_a_max)) Vec temp1; if (intersect(Ray(x, l), t, id, temp1) &amp;&amp; id == i) &#123; double omega = 2 * M_PI * (1 - cos_a_max); e = e + f.mult(s.e * l.dot(n_real) * omega) * (1 / M_PI); //std::cout &lt;&lt; e.x &lt;&lt; std::endl; &#125; &#125; //std::cout &lt;&lt; f.x &lt;&lt; std::endl; return obj_e * E + e + f.mult(radiance(Ray(x, d), depth, Xi, 0)); //TEST:E暂时设置为0 &#125; else if (obj_refl == SPEC) &#123; //std::cout &lt;&lt; &quot;SPEC&quot; &lt;&lt; std::endl; // return obj_e + f.mult(radiance(Ray(x, r.d - n * 2 * n.dot(r.d)), depth, Xi)); &#125; else if (obj_refl == REFR) &#123; //std::cout &lt;&lt; &quot;REFR&quot; &lt;&lt; std::endl; Ray reflRay(x, r.d - n * 2 * n.dot(r.d)); bool into = n.dot(n_real) &gt; 0; double nc = 1;//真空 double nt = 1.5;//玻璃 double nnt = into ? nc / nt : nt / nc; double ddn = r.d.dot(n_real); double cos2_t = 1 - nnt * nnt * (1 - ddn * ddn); //2是平方 if (cos2_t &lt; 0) &#123; //没有折射，发生全反射 return obj_e + f.mult(radiance(reflRay, depth, Xi)); &#125; Vec tdir = (r.d * nnt - n * ((into ? 1 : -1) * (ddn * nnt + sqrt(cos2_t)))).norm(); //考虑到计算量，采用近似算法 double a = nt - nc, b = nt + nc, R0 = a * a / (b * b), c = 1 - (into ? -ddn : tdir.dot(n)); double Re = R0 + (1 - R0) * c * c * c * c * c, Tr = 1 - Re, P = 0.25 + 0.5 * Re, RP = Re / P, TP = Tr / (1 - P); if (depth &gt; 2) &#123; if (erand48(Xi) &lt; P) &#123; // RR return obj_e + f.mult(radiance(reflRay, depth, Xi) * RP); &#125; else &#123; return obj_e + f.mult(radiance(Ray(x, tdir), depth, Xi) * TP); &#125; &#125; else &#123; return obj_e + f.mult(radiance(reflRay, depth, Xi) * Re + radiance(Ray(x, tdir), depth, Xi) * Tr); &#125; &#125;&#125;Vec* c = new Vec[WIDTH * HIGHT]; //图像缓存void Initial(void)&#123; glClearColor(1.0f, 1.0f, 1.0f, 1.0f); glMatrixMode(GL_PROJECTION); int width = glutGet(GLUT_WINDOW_WIDTH); int height = glutGet(GLUT_WINDOW_HEIGHT); gluOrtho2D(0.0, width, 0.0, height);&#125;void myDisplay(void) &#123; glClear(GL_COLOR_BUFFER_BIT); glPointSize(1); for (int y = 0; y &lt; HIGHT; y++) &#123; for (int x = 0; x &lt; WIDTH; x++) &#123; int n = (HIGHT - y - 1) * WIDTH + x; glColor3f(gamma(c[n].x), gamma(c[n].y), gamma(c[n].z)); glBegin(GL_POINTS); glVertex2f(x, y); glEnd(); &#125; &#125; glFlush();&#125; int main(int argc, char* argv[]) &#123; int w = WIDTH, h = HIGHT; int samples = 1; //设置每subpixel采样数 //设置 camera Ray cam(Vec(50, 52, 295.6), Vec(0, -0.042612, -1).norm()); Vec cx = Vec(w * 0.5135 / h); //视场角 Vec cy = (cx.cross(cam.d)).norm() * 0.5135; Vec r; //摄影机射线 auto clock_start = clock();#pragma omp parallel for schedule(dynamic, 1) private(i) meshTriangles[0].move(15, 0, 0); for (int y = 0; y &lt; h; y++) &#123; UpdateProgress((float)y / HIGHT); unsigned short Xi[3] = &#123; 0, 0, y * y * y &#125;; //设置四个子像素 for (unsigned short x = 0; x &lt; w; x++) &#123; for (int sy = 0, i = (h - y - 1) * w + x; sy &lt; 2; sy++) &#123; for (int sx = 0; sx &lt; 2; sx++, r = Vec()) &#123; for (int s = 0; s &lt; samples; s++) &#123; double r1 = 2 * erand48(Xi); double dx = r1 &lt; 1 ? sqrt(r1) - 1 : 1 - sqrt(2 - r1); double r2 = 2 * erand48(Xi); //std::cout &lt;&lt; r1 &lt;&lt; &quot; &quot; &lt;&lt; r2 &lt;&lt; std::endl; double dy = r2 &lt; 1 ? sqrt(r2) - 1 : 1 - sqrt(2 - r2); Vec sample_direct = cx * (((dx + 0.5 + sx) / 2 + x) / w - 0.5) + cy * (((dy + 0.5 + sy) / 2 + y) / h - 0.5) + cam.d; //std::cout &lt;&lt; r.x &lt;&lt; std::endl; r = r + radiance(Ray(cam.o + sample_direct * 140, sample_direct.norm()), 0, Xi) * (1.0 / samples); //std::cout &lt;&lt; &quot;x:&quot; &lt;&lt; r.x &lt;&lt; &quot;y:&quot; &lt;&lt; r.y &lt;&lt; &quot;, z:&quot; &lt;&lt;r.z &lt;&lt; std::endl; // &#125; //std::cout &lt;&lt; c[i].x &lt;&lt; std::endl; // c[i] = c[i] + Vec(clamp01(r.x), clamp01(r.y), clamp01(r.z)) * 0.25; &#125; &#125; &#125; &#125; FILE* f = fopen(&quot;test.ppm&quot;, &quot;wb&quot;); fprintf(f, &quot;P3\\n%d %d\\n%d\\n&quot;, w, h, 255); for (int i = 0; i &lt; w * h; i++) &#123; fprintf(f, &quot;%d %d %d &quot;, toInt255(c[i].x), toInt255(c[i].y), toInt255(c[i].z)); &#125; fclose(f); glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE); glutInitWindowPosition(100, 100); glutInitWindowSize(w, h); glutCreateWindow(&quot;Path Tracing&quot;); Initial(); glutDisplayFunc(&amp;myDisplay); glutMainLoop(); return 0;&#125;","categories":[{"name":"Games101","slug":"Games101","permalink":"https://whitetail-o.github.io/categories/Games101/"}],"tags":[{"name":"Games101","slug":"Games101","permalink":"https://whitetail-o.github.io/tags/Games101/"},{"name":"图形学","slug":"图形学","permalink":"https://whitetail-o.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"Ray-Tracing","slug":"Ray-Tracing","permalink":"https://whitetail-o.github.io/tags/Ray-Tracing/"}]},{"title":"Games101_10_12 Geometry","slug":"Games101_10_12_Geometry","date":"2022-10-02T08:35:10.000Z","updated":"2023-02-04T06:31:24.720Z","comments":true,"path":"2022/10/02/Games101_10_12_Geometry/","link":"","permalink":"https://whitetail-o.github.io/2022/10/02/Games101_10_12_Geometry/","excerpt":"Lecture 10/11: Geometry 1 2 不可能所有物体都用三角面表示，一些复杂的物体如毛发、水滴等用三角面表示开销极大； a). 几何的表示形式 隐式（Implicit） algebraic surface level sets distance functions … 显式（Explicit） point cloud polygon mesh subdivision, NURBS …","text":"Lecture 10/11: Geometry 1 2 不可能所有物体都用三角面表示，一些复杂的物体如毛发、水滴等用三角面表示开销极大； a). 几何的表示形式 隐式（Implicit） algebraic surface level sets distance functions … 显式（Explicit） point cloud polygon mesh subdivision, NURBS … b). 几何的隐式表示（Implict Representations of Geometry） 基于归类的点 点满足某种特定的关系，但不给你特定的点 e.g. Sphere: 所有三维中的点，满足 $x^2+y^2+z^2=1$； 通用情况：$f(x,y,z)=0$ 缺点： 难以采样（Sampling Can Be Hard，难以得到式子表示的整体形状） 优点： 方便判断点是否在几何体内（Inside/Outside Tests Easy） b.1). Algebraic Surfaces（曲面代数） 难以表达复杂的形状； b.2). Constructive Solid Geometry（CSG, 体素构造表示形式） 对隐式几何体进行布尔运算； b.3). Distance Function（距离函数） 给出各个点到物体的最小距离 Blending Distance Function: 目的：通过混合得到A、B运动的中间状态； 上半部分，blend之后中间1/3是灰的，而理想的结果是左边1/2是黑色，右边1/2是白色 下半部分，对SDF进行混合，再将blend后的结果恢复成shape（找到SDF等于0的情况的所有点），就可得到中间状态的物体； See https://iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm b.4). Level Set Methods（水平集） 封闭方程（DF）很难描述复杂的形状 备选方案：存储近似函数值的网格（Level Set Methods） 通过找到插值为0的位置确定表面； 提供对形状更明确的控制（如纹理）? 应用： Level Sets from Medical Data (CT, MRI, etc. 三维LSM) 物理模拟：如水平集得到各点到液体边界的距离（距离函数混合水滴） See http://physbam.stanford.edu b.5). Fractals(分形) c). 几何的显式表示（“Explicit” Representations of Geometry） 简介： 直接给出所有的点 或者 通过参数映射（via parameter mapping） 参数映射：给出uv，以及uv到三维空间的映射关系，遍历所有的uv就可找到三维空间所有的点； 采样简单 不方便判断点是否在几何体内（Inside/Outside Tests Hard） 隐式、显式各有优缺点，需要根据需求选择最优的表达方式 c.1). Point Cloud c.2). Polygon Mesh 常用的PolygonMesh文件，Wavefront Object File (.obj) v：顶点位置；vt：纹理位置；vn：normal；f：face，顶点索引/纹理索引/法线索引 c.3). Bézier Curve（贝塞尔曲线） 通过点$p_0$ 、$p_1$，且在这两点切线为$t0$、$t1$（切线前带系数，对于三次贝塞尔曲线系数为3） c.3.1). 计算贝塞尔曲线(德卡斯特里奥算法, De Casteljau’s Algorithm) 二次贝塞尔曲线 三次贝塞尔曲线（Cubic Bezier Curve） Anim： c.3.2). 代数形式 推出Bernstein polynomial（伯恩斯坦多项式）： B_{i}^{n}(t)=C_n^i · t^{i}(1-t)^{n-i} C.3.3). 性质 即（对于三次贝塞尔曲线）： $b_0$ 是起点，$b_3$是终点； 切线为$\\mathbf{b}^{\\prime}(0)=3\\left(\\mathbf{b}_{1}-\\mathbf{b}_{0}\\right) ; \\quad \\mathbf{b}^{\\prime}(1)=3\\left(\\mathbf{b}_{3}-\\mathbf{b}_{2}\\right)$ （切线前带系数，对于三次贝塞尔曲线系数为3，通过求导可得） 仿射不变性（对于贝塞尔曲线做仿射变换，只需要对控制点进行变换） 凸包性质； c.3.4). Piecewise Bézier Curves（分段贝塞尔曲线） 使用原因：解决高阶贝塞尔曲线控制点过多的问题； 分段贝塞尔曲线，常是分段立方贝塞尔（Piecewise cubic Bézier），即每一个曲线存在4个控制点； c.3.4.1). 连续性 C0 连续（C表示Continuity），几何连续：$a_n=b_0$ ； 首尾相接，夹角任意； C1 连续，参数连续：$a_n=b_0={1\\over2}(a_{n-1} + b_1)$ ； 切线相等，即一阶导数连续； 3.5). Other types of splines(待深入) In this course We do not cover B-splines and NURBS We also do not cover operations on curves (e.g. increasing/decreasing orders, etc.) To learn more / deeper, you are welcome to refer to Prof. Shi-Min Hu’s course: https://www.bilibili.com/video/av66548502?from=search&amp;seid=65256805876131485 3.6). Bezier Surface Animation: Steven Wittens, Making Things with Maths, http://acko.net 3.6.1). Evaluating Bézier Surfaces Lecture 13 Geometrya). Subdivision 以下是几种常用的细分方法: a.1). Loop Subdivision(Loop是人名) 细分对象：三角面 首先，创造更多的三角面； 第二，改变他们的位置； 具体做法： 将每个三角形细分为四个； 根据权重分配新的顶点位置； 区分新/老顶点，做不同变换； 对于新顶点： $P_{new} = {3\\over8}(A+B)+{1\\over8}(C+D)$ 对于老顶点： $n:$ 顶点的度（图论，与该顶点关联的边的数目，该处即为与该顶点连接的边的数量） $u:$ $3/16$（如果$n=3$），$3/(8n)$ （其他情况） $P_{new} = (1-nu)original_position + u·neighbor_position_sum$ Loop Subdivision Results： 缺点：Loop只能处理三角面； a.2). Catmull-Clark Subdivision 概念： 奇异点（Extraorinary vertex）：度不为4的点； 具体过程： 第一次细分： 每条边取中点，每个面也取其中一点； 第一次细分后，引入（n个，n=非四边形数目）奇异点，非四边形面消失。之后，奇异点不在增加，因此，之后细分只针对四边面； Catmull-Clark Vertex Update Rules (Quad Mesh) Face point: $$f=","categories":[{"name":"Games101","slug":"Games101","permalink":"https://whitetail-o.github.io/categories/Games101/"}],"tags":[{"name":"Games101","slug":"Games101","permalink":"https://whitetail-o.github.io/tags/Games101/"},{"name":"图形学","slug":"图形学","permalink":"https://whitetail-o.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"Games101-7-9 Shading","slug":"Games101_07_09_Shading","date":"2022-10-02T08:25:10.000Z","updated":"2023-02-04T06:31:20.673Z","comments":true,"path":"2022/10/02/Games101_07_09_Shading/","link":"","permalink":"https://whitetail-o.github.io/2022/10/02/Games101_07_09_Shading/","excerpt":"Lecture 07/08 Shading(Illumination, Shading and Graphics Pipeline)a). Definition b). A Simple Shading Model(Blinn-Phong Reflectance Model)b.1). Fundamental Blinn-Phong是一个经验模型，并不是严格基于物理的； 进入视线内的光照一般有以下构成： 高光（Specualr） 漫反射（Diffuse） 环境光（Ambient） 自发光（Emissive） Shading is Local: Compute light reflected toward camera at a specific shading point No shadows will be generated! (shading ≠ shadow) 阴影会由另外的Shadow Caster来着色； b.2). Diffuse Reflection Blinn-Phong中，漫反射的光均匀散射到各个方向； Lambert’s cosine law：接收到的能量与 $l·n$ 成正比例 Light Falloff 漫反射最终的着色： b.3). Specular Term(Blinn-Phong) Intensity depends on view direction 采用半程向量简化计算。采用半程向量$h$与$n$点乘的是Blinn-Phong模型，而采用镜面反射方向$r$和视线方向$v$点乘的是Phong模型； 指数$p$的作用：Increasing p narrows the reflection lobe 效果总览： b.4). Ambient Term","text":"Lecture 07/08 Shading(Illumination, Shading and Graphics Pipeline)a). Definition b). A Simple Shading Model(Blinn-Phong Reflectance Model)b.1). Fundamental Blinn-Phong是一个经验模型，并不是严格基于物理的； 进入视线内的光照一般有以下构成： 高光（Specualr） 漫反射（Diffuse） 环境光（Ambient） 自发光（Emissive） Shading is Local: Compute light reflected toward camera at a specific shading point No shadows will be generated! (shading ≠ shadow) 阴影会由另外的Shadow Caster来着色； b.2). Diffuse Reflection Blinn-Phong中，漫反射的光均匀散射到各个方向； Lambert’s cosine law：接收到的能量与 $l·n$ 成正比例 Light Falloff 漫反射最终的着色： b.3). Specular Term(Blinn-Phong) Intensity depends on view direction 采用半程向量简化计算。采用半程向量$h$与$n$点乘的是Blinn-Phong模型，而采用镜面反射方向$r$和视线方向$v$点乘的是Phong模型； 指数$p$的作用：Increasing p narrows the reflection lobe 效果总览： b.4). Ambient Term c). Shading Frequenciesc.1). Flat shadingc.2). Gouraud shading c.3). Phong shadingc.4). 对比 不一定Phong着色就比Flat优秀。在极高面数的一些情况下，Flat Shading性能开销比Phong Shading小，且呈现效果相差无几； c.5). 定义顶点/像素法线 顶点法线为相邻三角形的加权平均（权重与三角面的面积有关，当然也可简单平均，但效果较加权平均差）； 逐像素的法线通过对顶点法线进行重心插值（Barycentric interpolation）后归一化（normalize）得到； d). Graphics(Real-time Rendering) Pipeline 这段可看冯的入门精要作为简单的补充 MVP矩阵相关的发生在顶点阶段； 光栅化； Shading可在Vertex Processing阶段，也可在Fragment Processing阶段； Texture mapping Shader： 优秀Shader（到时候好好学习一下） Inigo Quilez, https://youtu.be/XuSnLbB1j6E Lecture 08/09 Shading(Texture Mapping) 可见 百人计划-图形1.3-纹理的秘密 作为补充； a). Interpolation Across Triangles: Barycentric Coordinates 重心插值的作用：通过顶点特定的值（normal、Color、Depth、Texture coordinates…），得到三角形内部片元（像素）上平滑过渡的值； 数学基础： 共面需满足的条件： $α+β+γ=1$，如需要点在三角形内，还需满足$α&gt;0,β&gt;0,γ&gt;0$ 重心坐标求法： 由以上易得，重心坐标$\\begin{aligned}(x, y) &amp;=\\frac{1}{3} A+\\frac{1}{3}B+\\frac{1}{3} C\\end{aligned}$ 通用计算公式： Final： 注意：重心并没有投影不变性，因此进行插值需要在三维空间中进行，而不是在屏幕的二维投影上； b). Texture Magnification(需要放大纹理的情况) 对应情况：纹理过小（如距离物体近，而贴图小） 插值方式： Nearest Bilinear Bicubic b.1). Bilinear Interpolation c). Texture Magnification(需要缩小纹理的情况) 对应情况：纹理过大（如距离物体远，而贴图大） 解决思路： 增大采样率（超采样） 高质量，但性能开销大； 减小贴图频率（Mipmap） c.1). Mipmap c.1). 如何确定Mipmap的level（参考百人计划）：c.2). Mipmap之间的过渡 Visualization of Mipmap Level(D rounded to nearest integer level)： Trilinear Interpolation 作法：对相邻两层的Mipmap做Bilinear Interpolation，根据所得的level，对相邻两层进过插值的结果再进行一次插值；（e.g. D=1.6，则对一层和二层分别进行双线性插值后，再进行$lerp(1.6-1, n_1, n_2)$） Final： d). Applications of Texturesd.1). Environment Map 简介： 对于环境光源，我们认为它来自与无限远处，即没有深度意义，不同位置的同一方向受到的环境光源相同（当然，暂不考虑遮挡） Spherical Environment Map： Problem：不是均匀的描述，在极点会存在较大的扭曲； CubeMap： d.2). Bump Mapping 凹凸贴图（视差贴图/法线贴图）计算法线过程： 思路（一维情况，in flatland）： 原始法线 $n(p)=(0,1)$ 在 p 点的导数 $dp=c·[h(p+1)-h(p)]$ （$c$ 是常数，用于缩放导数，改变其影响程度），得出切线 计算法线（垂直于切线） $n(p)=(-dp,1).normalized()$； 思路（in 3D）： 原始法线 $n(p)=(0,0,1)$； 纹理上的点对 $u$ 方向和 $v$ 方向求偏导，得出切线 $dp/du=c1·[h(u+1)-h(u)]$ $dp/dv=c2·[h(v+1)-h(v)]$ 计算法线（垂直于切线） $n(p)=(-dp/du,-dp/dv,1).normalized()$； 以上计算均在切线空间、局部空间计算（具体看冯-入门精要） Displacement mapping（置换/高度贴图）: 需要足够多的三角面（DX中的Dynamic Tessellation，动态曲面细分） 真正地移动了顶点 d.3). 3D Procedural Noise + Solid Modeling Perlin noise d.4). Provide Precomputed Shading 使用Baking的AO等（也可记录其他信息，如SP中的ID、Position、Curvature等）； d.5). 3D Textures and Volume Rendering 体渲染","categories":[{"name":"Games101","slug":"Games101","permalink":"https://whitetail-o.github.io/categories/Games101/"}],"tags":[{"name":"Games101","slug":"Games101","permalink":"https://whitetail-o.github.io/tags/Games101/"},{"name":"图形学","slug":"图形学","permalink":"https://whitetail-o.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"Games101-5-6 Rasterization","slug":"Games101_05_06_Rasterization","date":"2022-10-02T08:20:10.000Z","updated":"2023-02-04T06:31:12.704Z","comments":true,"path":"2022/10/02/Games101_05_06_Rasterization/","link":"","permalink":"https://whitetail-o.github.io/2022/10/02/Games101_05_06_Rasterization/","excerpt":"Lecture 05 Rasterization(Triangles)a). Perspective Projection 如何定义一个frustum： 近平面宽度、高度（得到宽高比） FOV(Field of View) b). Viewport transformation 经过MVP后，模型空间中点变换到标准立方体（canonical cube, x,y,z[-1, 1]）中。之后就需要进行视口变换（Viewport transformation） 定义屏幕空间 OpenGL屏幕空间坐标原点为左下（上图），DX坐标原点为左上 像素位置该像素（方块）左下角的坐标，如左下角像素坐标为$(0, 0)$，但像素中心为$(0.5, 0.5)$ Viewport transformation c). Rasterization Frame Buffer: Memory for a Raster Display 显存中的一块区域 补充：Render texture（详情见Other/Note） 以下以Unity为例： 渲染过程中，贴图最开始在CPU内存，这时的贴图被称为client-side的texture，最后被送到GPU，这时叫server-side的texture； Render texture是将FrameBufferObject连接到一个server-side的texture； 注意：FrameBufferObject不一定只有一个，也不一定连接屏幕； 详情：http://t.csdn.cn/3JHqA Triangles - Fundamental Shape Primitives 无法分割为其他多边形 保证是一个平面 容易区分内部和外部 内部插值方便 Fundament： What Pixel Values Approximate a Triangle? Sampling（采样）：逐像素中心采样，判断像素是否在三角形内 for (int x = 0; x &lt; xmax; ++x) output[x] = f(x); 判断$(x,y)$是否在三角形内：做三次叉乘，看正负符号是否相同，相同则在三角形内； Edge Cases：要么不做处理，要么特殊处理（OpenGL，DX里规定落于左边和上边算三角形中的点，而落于右边和下边的不算“Top-Left Rule“） 光栅化加速 光栅化中，对每一个像素都判断是否在三角形中性能浪费过大。因此，加入Bounding Box（包围盒）来限定需要进行判断的区域 Incremental Triangle Traversal（找到三角形中每一行最左和最右的像素，但实际上没那么容易，是用于细长并旋转的三角形）","text":"Lecture 05 Rasterization(Triangles)a). Perspective Projection 如何定义一个frustum： 近平面宽度、高度（得到宽高比） FOV(Field of View) b). Viewport transformation 经过MVP后，模型空间中点变换到标准立方体（canonical cube, x,y,z[-1, 1]）中。之后就需要进行视口变换（Viewport transformation） 定义屏幕空间 OpenGL屏幕空间坐标原点为左下（上图），DX坐标原点为左上 像素位置该像素（方块）左下角的坐标，如左下角像素坐标为$(0, 0)$，但像素中心为$(0.5, 0.5)$ Viewport transformation c). Rasterization Frame Buffer: Memory for a Raster Display 显存中的一块区域 补充：Render texture（详情见Other/Note） 以下以Unity为例： 渲染过程中，贴图最开始在CPU内存，这时的贴图被称为client-side的texture，最后被送到GPU，这时叫server-side的texture； Render texture是将FrameBufferObject连接到一个server-side的texture； 注意：FrameBufferObject不一定只有一个，也不一定连接屏幕； 详情：http://t.csdn.cn/3JHqA Triangles - Fundamental Shape Primitives 无法分割为其他多边形 保证是一个平面 容易区分内部和外部 内部插值方便 Fundament： What Pixel Values Approximate a Triangle? Sampling（采样）：逐像素中心采样，判断像素是否在三角形内 for (int x = 0; x &lt; xmax; ++x) output[x] = f(x); 判断$(x,y)$是否在三角形内：做三次叉乘，看正负符号是否相同，相同则在三角形内； Edge Cases：要么不做处理，要么特殊处理（OpenGL，DX里规定落于左边和上边算三角形中的点，而落于右边和下边的不算“Top-Left Rule“） 光栅化加速 光栅化中，对每一个像素都判断是否在三角形中性能浪费过大。因此，加入Bounding Box（包围盒）来限定需要进行判断的区域 Incremental Triangle Traversal（找到三角形中每一行最左和最右的像素，但实际上没那么容易，是用于细长并旋转的三角形） Lecture 6: Rasterization 2(Antialiasing and Z-Buffering)a). Sampling Artifacts(Errors / Mistakes / Inaccuracies) in Computer Graphics 由于采样造成的“Artifacts“ 锯齿（ Jaggies）——空间上采样 摩尔纹（Moire）——欠采样图像 车轮错觉（Wagon wheel effect）——时间上采样 …… 造成错误的原因：信号频率高，而采样频率低（可联系奈奎斯特定理：当采样频率大于信号中最高频率的2倍时(fs&gt;2f)，采样之后的数字信号完整地保留了原始信号中的信息） b). Antialiasing Idea:Blurring (Pre-Filtering) Before Sampling 抗锯齿的思路就是在采样前”模糊“； 注意：先模糊，后采样。对应频域上先低通滤波（或其他操作，如卷积、超采样，FSAA那种图像层面的抗锯齿暂不考虑），后采样（卷积定理：时域信号与冲激信号相乘，等于两者对应的频域信号卷积。反之，也成立）； c). Frequency Domainc.1). Fundamental 傅里叶变换 卷积定理：时域中乘积等于频域上卷积，反之也成立。（时域信号与冲激信号相乘，等于两者对应的频域信号卷积。反之，也成立。） Aliases: 在给定的采样率下，无法区分两个不同频率 c.2). Filtering: Getting rid of certain frequency contents K空间：反应图像进过二维傅里叶变换后的结果，越靠中间，频率越小； 出现十字星的原因：把图像看成类似Wrap Mode的Repeat，即重复的图像。使得其四个方向的高频内容增加，形成十字星； Filter（滤波器）： High-pass filter Low-pass filter Filter Out Low and High Frequencies c.3). Convolution Filtering = Convolution (= Averaging) 注意：只是在这里相等，而滤波和卷积概念上不相同； 对信号进行滤波，就是用卷积核和信号做卷积； Point-wise local averaging in a “sliding window” 卷积定理：在空域（时域）做卷积，等于在频域做乘积；反之亦然。 因此，对图像滤波有两种处理方法； Option 1: 在空域上与滤波器（卷积核）做卷积； Option 2: 将图像和滤波器（卷积核）转换到频域（傅里叶变换）； 两者在频域相乘； 将得到的结果重新变换到空域（逆傅里叶变换）； Box Filter 箱式滤波类似于低通滤波 更大的卷积核意味着更低的频率 c.4). Sampling = Repeating Frequency Contents 锯齿=混叠 d). Antialiasing 解决锯齿的选择： 提高采样率 增大冲激信号在频域的距离； 更高分辨率的显示器； 缺点：成本高，且需要很高的分辨率 抗锯齿 让信号在采样（重复，Repeat）前变“窄”，即在采样前过滤掉高频部分 Antialiasing = Limiting, then repeating Solution: Convolve f(x,y) by a 1-pixel box-blur Recall: convolving = filtering = averaging Then sample at every pixel’s center 通过计算像素平均值来抗锯齿 e). SSAA(Super Sampling Antialiasing) 通过将一个像素分割成NxN个像素来进行采样和shading，最后将每个像素点内部所细分的采样点的颜色值全部加起来再求均值，作为该像素点的抗锯齿之后的颜色值 f). MSAA(Multi-Sampling Antialiasing) MSAA是对SSAA的改进。SSAA的计算量大，一个像素中会有多个点进行shading，而MSAA只是计算究竟有几个采样点会被三角形cover，计算颜色的时候只会利用像素中心坐标进行一次shading。 如图中大点所在的像素块，三角形只覆盖了其中的三个点（左下，右上，右下），则该像素的颜色为$75\\%Color_{origin}$，之后，再对像素中心进行采样 注意：MSAA只是近似Blur，而没提高采样率。要注意和SSAA以及高分辨率的区分 在实际中，子像素的划分并不是均匀划分为NxN，而是通过其他更有效的方法，而且有些样本还会得到复用； SSAA中每个像素点有4个子采样点，每个三角形对每个像素点的4个子采样点各着色1次（共4次），再把计算结果根据深度和覆盖信息保存到对应的子采样点，最后对4个采样点取均值作为最终的像素颜色； MSAA中每个像素点有4个子采样点，每个三角形对每个像素点只在中心点着色1次，再把计算结果根据深度和覆盖信息保存到对应的子采样点，最后对4个采样点取均值作为最终的像素颜色； g). Other AA FXAA(Fast Approximate AA) 图像层面上进行处理，是一个后期处理，先得到有锯齿的图像，再通过图像匹配找到有锯齿的边界，之后，替换为没有锯齿的边界； TAA(Temporal AA) 可以联系UE_NOTE 将空域采样点，均匀分布到时域上； h). Z-bufferh.0). Painter’s Algorithm 画家算法： 对三角形进行排序，先画远的，再画近的； 不能解决相互遮挡问题，因此采用Z-buffer h.1). Z-buffer Idea： 储存每个采样（像素）中最小的深度值； 储存深度值到缓存区（buffer）中； 为了简单起见，我们看作z是正数(smaller z -&gt; closer, larger z -&gt; further)； 深度缓存步骤： 初始化深度缓存，将其中每个值初始化为∞ 遍历每个三角形面上的每一个像素点[x,y]，如果该像素点的深度值z，小于Z-buffer[x,y]中的值，则更新zbuffer[x,y]值为该点深度值z，并同时更新该像素点[x,y]的颜色为该三角形面上的该点的颜色。 伪代码： 时间复杂度$O(n)$。Z-buffer并没有进行排序，只是求得最小（深度）值，因此时间复杂度为线性； 三角形的绘制顺序并不影响最终结果（不考虑不透明等情况）；","categories":[{"name":"Games101","slug":"Games101","permalink":"https://whitetail-o.github.io/categories/Games101/"}],"tags":[{"name":"Games101","slug":"Games101","permalink":"https://whitetail-o.github.io/tags/Games101/"},{"name":"图形学","slug":"图形学","permalink":"https://whitetail-o.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"Games101-2-4 Math","slug":"Games101_02_04_Math","date":"2022-10-02T08:15:10.000Z","updated":"2023-02-04T06:30:59.804Z","comments":true,"path":"2022/10/02/Games101_02_04_Math/","link":"","permalink":"https://whitetail-o.github.io/2022/10/02/Games101_02_04_Math/","excerpt":"Lecture 02 Review of Linear Algebraa). Cross Product 判断相对的左右、前后、内外 判断左右：如$ \\vec{a} \\cdot \\vec{b} &gt; 0$那 $\\vec{b}$ 就在 $\\vec{a}$ 的左侧（按图中的右手坐标系） 判断内外：判断 $\\vec{AB}$ 和 $\\vec{AP}$ 的关系，可判断$P$ 点的在 $\\vec{AB}$ 的左侧，同理可判断$P$ 在 $\\vec{BC}$ 和 $\\vec{CA}$ 的左侧，即均在向量同侧。由此，可判断$P$ 点的在 $ABC$ 的内部 b). Orthonormal Coordinate Frames(正交直角坐标系)","text":"Lecture 02 Review of Linear Algebraa). Cross Product 判断相对的左右、前后、内外 判断左右：如$ \\vec{a} \\cdot \\vec{b} &gt; 0$那 $\\vec{b}$ 就在 $\\vec{a}$ 的左侧（按图中的右手坐标系） 判断内外：判断 $\\vec{AB}$ 和 $\\vec{AP}$ 的关系，可判断$P$ 点的在 $\\vec{AB}$ 的左侧，同理可判断$P$ 在 $\\vec{BC}$ 和 $\\vec{CA}$ 的左侧，即均在向量同侧。由此，可判断$P$ 点的在 $ABC$ 的内部 b). Orthonormal Coordinate Frames(正交直角坐标系) Lecture 03 Transformationa). 2D Transformation Scale Matrix Reflection Matrix Shear Matrix(切变矩阵) Rotation matrix(默认原点(0, 0), CCW/逆时针旋转) b). Homogeneous coordinates(齐次坐标) To solve: 平移不是线性变换，无法用2*2矩阵表示（2D） 为什么点和向量的其次项不同？ 向量具有平移不变性，齐次项为0可使其不受$t_x$、$t_y$的影响 考虑向量与点、向量/点之间的运算 point + point得到两点的中点 所有的仿射变换（Affine Transformation）都可以用齐次坐标系表示 复杂变换，如 c). 3D Transformation 三维空间中使用齐次坐标的变换 \\left(\\begin{array}{l} x^{\\prime} \\\\ y^{\\prime} \\\\ z^{\\prime} \\\\ 1 \\end{array}\\right)=\\left(\\begin{array}{lllc} a & b & c & t_{x} \\\\ d & e & f & t_{y} \\\\ g & h & i & t_{z} \\\\ 0 & 0 & 0 & 1 \\end{array}\\right) \\cdot\\left(\\begin{array}{l} x \\\\ y \\\\ z \\\\ 1 \\end{array}\\right) \\left(\\begin{array}{l} x^{\\prime} \\\\ y^{\\prime} \\\\ z^{\\prime} \\\\ 1 \\end{array}\\right)=\\left(\\begin{array}{lllc} 1 & 0 & 0 & t_{x} \\\\ 0 & 1 & 0 & t_{y} \\\\ 0 & 0 & 1 & t_{z} \\\\ 0 & 0 & 0 & 1 \\end{array}\\right) \\cdot\\left(\\begin{array}{lllc} a & b & c & 0 \\\\ d & e & f & 0 \\\\ g & h & i & 0 \\\\ 0 & 0 & 0 & 1 \\end{array}\\right) \\cdot\\left(\\begin{array}{l} x \\\\ y \\\\ z \\\\ 1 \\end{array}\\right)上述矩阵先线性变换再平移，相当于： \\left(\\begin{array}{l}x^{\\prime} \\\\y^{\\prime} \\\\z^{\\prime} \\\\1\\end{array}\\right)=\\left(\\begin{array}{lllc}1 & 0 & 0 & t_{x} \\\\0 & 1 & 0 & t_{y} \\\\0 & 0 & 1 & t_{z} \\\\0 & 0 & 0 & 1\\end{array}\\right) \\cdot\\left(\\begin{array}{lllc}a & b & c & 0 \\\\d & e & f & 0 \\\\g & h & i & 0 \\\\0 & 0 & 0 & 1\\end{array}\\right) \\cdot\\left(\\begin{array}{l}x \\\\y \\\\z \\\\1\\end{array}\\right) 补充知识：正交矩阵 Lecture 04 Transformation Cont.a). 3D变换a.1) Scale、Translation a.2) 3D Rotations 旋转矩阵： 注意绕y轴旋转和其他的区别（$y=cross(z, x)$） 三轴旋转可以表示3D空间的所有旋转变换，例如飞机（Roll、Pitch、Yaw） 罗德里格旋转公式（表示绕任意经过原点轴的任意旋转） 默认旋转轴经过原点 $\\left(\\begin{array}{ccc}0 &amp; -n_{z} &amp; n_{y} \\\\n_{z} &amp; 0 &amp; -n_{x} \\\\-n_{y} &amp; n_{x} &amp; 0\\end{array}\\right)$是叉乘向量的矩阵形式 四元数多是为了旋转之间的插值用的 四元数待课后补充 b). Viewing Transformation 概念：Viewing Transformation（观测矩阵）相当于MVP中的VP View/Camera transformation Projection transformation Orthographic projection Perspective projection b.1) View Transformaiton Difine the camera: View Space: 相机位于原点，上是$Y$，看向$-Z$ 看成所有相机不动，全是其他物体动 $M_{view}$： in math: 直接应用矩阵空间变换 b.2) Projection transformation这里的投影变换中对xyzw都乘了z，因此最后需要齐次除法（透视除法），转换到NDC(Normalized Device Coordinates) b.2.1 Orthographic Projection 简易理解： 注意$[-1, 1]$ 图形学中的做法： 通过平移将立方体中心化 缩放成标准立方体（“canonical” cube） 这里采用右手坐标系，缺点是$f&lt;n$，远的z值小于近的z值 矩阵形式： M_{\\text {ortho }}=\\left[\\begin{array}{cccc} \\frac{2}{r-l} & 0 & 0 & 0 \\\\ 0 & \\frac{2}{t-b} & 0 & 0 \\\\ 0 & 0 & \\frac{2}{n-f} & 0 \\\\ 0 & 0 & 0 & 1 \\end{array}\\right]\\left[\\begin{array}{cccc} 1 & 0 & 0 & -\\frac{r+l}{2} \\\\ 0 & 1 & 0 & -\\frac{t+b}{2} \\\\ 0 & 0 & 1 & -\\frac{n+f}{2} \\\\ 0 & 0 & 0 & 1 \\end{array}\\right] Caveat: （使用右手坐标系）看向 $-Z$ 使得$f&lt;n$，远的z值小于近的z值 这也是为什么OpenGL使用左手坐标系（但也会造成其他问题） b.2.2 Perspective Projection 前置知识： How to do perspective projection 挤压（squish） $M_{\\text {persp } \\rightarrow \\text { ortho }}=\\left(\\begin{array}{cccc}n &amp; 0 &amp; 0 &amp; 0 \\\\0 &amp; n &amp; 0 &amp; 0 \\\\? &amp; ? &amp; ? &amp; ? \\\\0 &amp; 0 &amp; 1 &amp; 0\\end{array}\\right)$ 不知道经过挤压后$z$的变化（即第三行乘以$\\left(\\begin{array}{l}x \\\\y \\\\n \\\\1\\end{array}\\right)$未知），但知道： 在近平面的点不会变化 在远平面的中点不会变化 $z=n$时，$\\left(\\begin{array}{l}x \\\\y \\\\n \\\\1\\end{array}\\right) \\Rightarrow\\left(\\begin{array}{l}x \\\\y \\\\n \\\\1\\end{array}\\right)==\\left(\\begin{array}{c}n x^{n} \\\\n y \\\\n^{2} \\\\n\\end{array}\\right)$ 易得$\\left(\\begin{array}{llll}0 &amp; 0 &amp; A &amp; B\\end{array}\\right)\\left(\\begin{array}{l}x \\\\y \\\\n \\\\1\\end{array}\\right)=n^{2}$ $An+B=n^2$ $z=f$时，对于远平面中点，$\\left(\\begin{array}{l}0 \\\\0 \\\\f \\\\1\\end{array}\\right) \\Rightarrow\\left(\\begin{array}{l}0 \\\\0 \\\\f \\\\1\\end{array}\\right)==\\left(\\begin{array}{c}0 \\\\0 \\\\f^{2} \\\\f\\end{array}\\right)$ 易得$\\left(\\begin{array}{llll}0 &amp; 0 &amp; A &amp; B\\end{array}\\right)\\left(\\begin{array}{l}0 \\\\0 \\\\f \\\\1\\end{array}\\right)=f^{2}$ $Af+B=f^2$ 得$A=n+f$，$B=-nf$ $M_{\\text {persp } \\rightarrow \\text { ortho }}=\\left(\\begin{array}{cccc}n &amp; 0 &amp; 0 &amp; 0 \\\\0 &amp; n &amp; 0 &amp; 0 \\\\0 &amp; 0 &amp; n+f &amp; -nf \\\\0 &amp; 0 &amp; 1 &amp; 0\\end{array}\\right)$ 之后进行平行投影的变换，得 $\\mathbf{M}_{\\text {per }}=\\left[\\begin{array}{cccc}\\frac{2 n}{r-l} &amp; 0 &amp; \\frac{l+r}{l-r} &amp; 0 \\\\0 &amp; \\frac{2 n}{t-b} &amp; \\frac{b+t}{b-t} &amp; 0 \\\\0 &amp; 0 &amp; \\frac{f+n}{n-f} &amp; \\frac{2 f n}{f-n} \\\\0 &amp; 0 &amp; 1 &amp; 0\\end{array}\\right]$ 【补充】 作业1中用到的绕任意轴旋转： 步骤： 将旋转轴平移至原点 将旋转轴旋转至YOZ平面 将旋转轴旋转至于Z轴重合 绕Z轴旋转θ度 执行步骤3的逆过程 执行步骤2的逆过程 执行步骤1的逆过程 如果旋转轴是过原点的，那么第一步和最后一步的平移操作可以省略，也就是把中间五个矩阵连乘起来，再转置一下，得到下面的绕任意轴旋转的矩阵 \\left[\\begin{array}{cccc} a^{2}+\\left(1-a^{2}\\right) \\cos \\theta & a b(1-\\cos \\theta)+\\operatorname{csin} \\theta & a c(1-\\cos \\theta)-b \\sin \\theta & 0 \\\\ a b(1-\\cos \\theta)-c \\sin \\theta & b^{2}+\\left(1-b^{2}\\right) \\cos \\theta & b c(1-\\cos \\theta)+a \\sin \\theta & 0 \\\\ a c(1-\\cos \\theta)+b \\sin \\theta & b c(1-\\cos \\theta)-a \\sin \\theta & c^{2}+\\left(1-c^{2}\\right) \\cos \\theta & 0 \\\\ 0 & 0 & 0 & 1 \\end{array}\\right]","categories":[{"name":"Games101","slug":"Games101","permalink":"https://whitetail-o.github.io/categories/Games101/"}],"tags":[{"name":"Games101","slug":"Games101","permalink":"https://whitetail-o.github.io/tags/Games101/"},{"name":"图形学","slug":"图形学","permalink":"https://whitetail-o.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]}],"categories":[{"name":"Q&A","slug":"Q-A","permalink":"https://whitetail-o.github.io/categories/Q-A/"},{"name":"Games202","slug":"Games202","permalink":"https://whitetail-o.github.io/categories/Games202/"},{"name":"Todo","slug":"Todo","permalink":"https://whitetail-o.github.io/categories/Todo/"},{"name":"百人计划","slug":"百人计划","permalink":"https://whitetail-o.github.io/categories/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/"},{"name":"Games101","slug":"Games101","permalink":"https://whitetail-o.github.io/categories/Games101/"}],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://whitetail-o.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"Q&A","slug":"Q-A","permalink":"https://whitetail-o.github.io/tags/Q-A/"},{"name":"Games202","slug":"Games202","permalink":"https://whitetail-o.github.io/tags/Games202/"},{"name":"Ray-Tracing","slug":"Ray-Tracing","permalink":"https://whitetail-o.github.io/tags/Ray-Tracing/"},{"name":"Denoise","slug":"Denoise","permalink":"https://whitetail-o.github.io/tags/Denoise/"},{"name":"Materials","slug":"Materials","permalink":"https://whitetail-o.github.io/tags/Materials/"},{"name":"PBR","slug":"PBR","permalink":"https://whitetail-o.github.io/tags/PBR/"},{"name":"NPR","slug":"NPR","permalink":"https://whitetail-o.github.io/tags/NPR/"},{"name":"GI","slug":"GI","permalink":"https://whitetail-o.github.io/tags/GI/"},{"name":"Todo","slug":"Todo","permalink":"https://whitetail-o.github.io/tags/Todo/"},{"name":"论文复现","slug":"论文复现","permalink":"https://whitetail-o.github.io/tags/%E8%AE%BA%E6%96%87%E5%A4%8D%E7%8E%B0/"},{"name":"百人计划","slug":"百人计划","permalink":"https://whitetail-o.github.io/tags/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/"},{"name":"美术","slug":"美术","permalink":"https://whitetail-o.github.io/tags/%E7%BE%8E%E6%9C%AF/"},{"name":"模型制作流程","slug":"模型制作流程","permalink":"https://whitetail-o.github.io/tags/%E6%A8%A1%E5%9E%8B%E5%88%B6%E4%BD%9C%E6%B5%81%E7%A8%8B/"},{"name":"美术理论","slug":"美术理论","permalink":"https://whitetail-o.github.io/tags/%E7%BE%8E%E6%9C%AF%E7%90%86%E8%AE%BA/"},{"name":"IBL","slug":"IBL","permalink":"https://whitetail-o.github.io/tags/IBL/"},{"name":"Shadow","slug":"Shadow","permalink":"https://whitetail-o.github.io/tags/Shadow/"},{"name":"Games101","slug":"Games101","permalink":"https://whitetail-o.github.io/tags/Games101/"},{"name":"Animation","slug":"Animation","permalink":"https://whitetail-o.github.io/tags/Animation/"}]}