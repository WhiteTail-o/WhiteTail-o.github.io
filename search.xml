<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Games101-2-4 Math</title>
    <url>/2022/10/02/Games101_02_04_Math/</url>
    <content><![CDATA[<h1 id="Lecture-02-Review-of-Linear-Algebra"><a href="#Lecture-02-Review-of-Linear-Algebra" class="headerlink" title="Lecture 02 Review of Linear Algebra"></a>Lecture 02 Review of Linear Algebra</h1><h2 id="a-Cross-Product"><a href="#a-Cross-Product" class="headerlink" title="a). Cross Product"></a>a). Cross Product</h2><p><img src="/2022/10/02/Games101_02_04_Math/cross.png" alt="cross"></p>
<ul>
<li><p>判断相对的左右、前后、内外</p>
<p><img src="/2022/10/02/Games101_02_04_Math/cross.png" alt="cross"></p>
</li>
<li><p><strong>判断左右：</strong>如$ \vec{a} \cdot \vec{b} &gt; 0$那 $\vec{b}$ 就在 $\vec{a}$ 的左侧（按图中的右手坐标系）</p>
</li>
<li><p><strong>判断内外：</strong>判断 $\vec{AB}$  和 $\vec{AP}$ 的关系，可判断$P$ 点的在 $\vec{AB}$ 的左侧，同理可判断$P$ 在 $\vec{BC}$ 和 $\vec{CA}$ 的左侧，即均在向量<strong>同侧</strong>。由此，可判断$P$ 点的在 $ABC$ 的内部</p>
</li>
</ul>
<h2 id="b-Orthonormal-Coordinate-Frames-正交直角坐标系"><a href="#b-Orthonormal-Coordinate-Frames-正交直角坐标系" class="headerlink" title="b). Orthonormal Coordinate Frames(正交直角坐标系)"></a>b). Orthonormal Coordinate Frames(正交直角坐标系)</h2><p><img src="/2022/10/02/Games101_02_04_Math/OCF.png" alt="OCF"></p>
<h1 id="Lecture-03-Transformation"><a href="#Lecture-03-Transformation" class="headerlink" title="Lecture 03 Transformation"></a>Lecture 03 Transformation</h1><h2 id="a-2D-Transformation"><a href="#a-2D-Transformation" class="headerlink" title="a). 2D Transformation"></a>a). 2D Transformation</h2><ul>
<li><p><strong>Scale Matrix</strong> </p>
</li>
<li><p><strong>Reflection Matrix</strong></p>
</li>
<li><p><strong>Shear Matrix(切变矩阵)</strong></p>
<p><img src="/2022/10/02/Games101_02_04_Math/ShearMatrix.png" alt="ShearMatrix"></p>
</li>
<li><p><strong>Rotation matrix(默认原点(0, 0), CCW/逆时针旋转)</strong></p>
<p><img src="/2022/10/02/Games101_02_04_Math/RotationMatrix.png" alt="RotationMatrix"></p>
</li>
</ul>
<h2 id="b-Homogeneous-coordinates-齐次坐标"><a href="#b-Homogeneous-coordinates-齐次坐标" class="headerlink" title="b). Homogeneous coordinates(齐次坐标)"></a>b). Homogeneous coordinates(齐次坐标)</h2><ul>
<li><p><strong>To solve:</strong> 平移不是线性变换，无法用2*2矩阵表示（2D）</p>
</li>
<li><p><img src="/2022/10/02/Games101_02_04_Math/HomogenousCoord.png" alt="HomogenousCoord"></p>
<ul>
<li><strong>为什么点和向量的其次项不同？</strong><ol>
<li>向量具有平移不变性，齐次项为0可使其不受$t_x$、$t_y$的影响</li>
<li>考虑向量与点、向量/点之间的运算<img src="/2022/10/02/Games101_02_04_Math/HomogenousCoord01.png" alt="HomogenousCoord01"><ul>
<li>point + point得到<strong>两点的中点</strong></li>
</ul>
</li>
</ol>
</li>
<li>所有的<strong>仿射变换（Affine Transformation）</strong>都可以用<strong>齐次坐标系</strong>表示<img src="/2022/10/02/Games101_02_04_Math/AT2HC.png" alt="AT2HC"></li>
</ul>
</li>
<li><p><strong>复杂变换</strong>，如</p>
<p><img src="/2022/10/02/Games101_02_04_Math/ComplexTransforms.png" alt="ComplexTransforms"></p>
</li>
</ul>
<h2 id="c-3D-Transformation"><a href="#c-3D-Transformation" class="headerlink" title="c). 3D Transformation"></a>c). 3D Transformation</h2><p><img src="/2022/10/02/Games101_02_04_Math/3D_Transformations.png" alt="3D_Transformations"></p>
<ul>
<li>三维空间中使用齐次坐标的变换</li>
</ul>
<script type="math/tex; mode=display">
\left(\begin{array}{l}
x^{\prime} \\
y^{\prime} \\
z^{\prime} \\
1
\end{array}\right)=\left(\begin{array}{lllc}
a & b & c & t_{x} \\
d & e & f & t_{y} \\
g & h & i & t_{z} \\
0 & 0 & 0 & 1
\end{array}\right) \cdot\left(\begin{array}{l}
x \\
y \\
z \\
1
\end{array}\right)</script><script type="math/tex; mode=display">
\left(\begin{array}{l}
x^{\prime} \\
y^{\prime} \\
z^{\prime} \\
1
\end{array}\right)=\left(\begin{array}{lllc}
1 & 0 & 0 & t_{x} \\
0 & 1 & 0 & t_{y} \\
0 & 0 & 1 & t_{z} \\
0 & 0 & 0 & 1
\end{array}\right) \cdot\left(\begin{array}{lllc}
a & b & c & 0 \\
d & e & f & 0 \\
g & h & i & 0 \\
0 & 0 & 0 & 1
\end{array}\right) \cdot\left(\begin{array}{l}
x \\
y \\
z \\
1
\end{array}\right)</script><p><strong>上述矩阵先线性变换再平移</strong>，相当于：</p>
<script type="math/tex; mode=display">
\left(\begin{array}{l}x^{\prime} \\y^{\prime} \\z^{\prime} \\1\end{array}\right)=\left(\begin{array}{lllc}1 & 0 & 0 & t_{x} \\0 & 1 & 0 & t_{y} \\0 & 0 & 1 & t_{z} \\0 & 0 & 0 & 1\end{array}\right) \cdot\left(\begin{array}{lllc}a & b & c & 0 \\d & e & f & 0 \\g & h & i & 0 \\0 & 0 & 0 & 1\end{array}\right) \cdot\left(\begin{array}{l}x \\y \\z \\1\end{array}\right)</script><hr>
<ul>
<li>补充知识：正交矩阵</li>
</ul>
<h1 id="Lecture-04-Transformation-Cont"><a href="#Lecture-04-Transformation-Cont" class="headerlink" title="Lecture 04 Transformation Cont."></a>Lecture 04 Transformation Cont.</h1><h2 id="a-3D变换"><a href="#a-3D变换" class="headerlink" title="a). 3D变换"></a>a). 3D变换</h2><h3 id="a-1-Scale、Translation"><a href="#a-1-Scale、Translation" class="headerlink" title="a.1) Scale、Translation"></a>a.1) Scale、Translation</h3><p><img src="/2022/10/02/Games101_02_04_Math/3d01.png" alt="3d01"></p>
<h3 id="a-2-3D-Rotations"><a href="#a-2-3D-Rotations" class="headerlink" title="a.2) 3D Rotations"></a>a.2) 3D Rotations</h3><ul>
<li><p><strong>旋转矩阵：</strong></p>
<p><img src="/2022/10/02/Games101_02_04_Math/3d_rotation.png" alt="3d_rotation"></p>
<ul>
<li><p><strong>注意绕y轴旋转和其他的区别</strong>（$y=cross(z, x)$）</p>
</li>
<li><p>三轴旋转可以表示3D空间的所有旋转变换，例如飞机（<strong>Roll、Pitch、Yaw</strong>）</p>
<p><img src="/2022/10/02/Games101_02_04_Math/RPY.png" alt="RPY"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>罗德里格旋转公式</strong>（表示绕任意<strong>经过原点</strong>轴的任意旋转）</p>
<p><img src="/2022/10/02/Games101_02_04_Math/Rodrigues_Rotation.png" alt="Rodrigues_Rotation"></p>
<ul>
<li>默认旋转轴经过原点</li>
<li>$\left(\begin{array}{ccc}<br>0 &amp; -n_{z} &amp; n_{y} \\<br>n_{z} &amp; 0 &amp; -n_{x} \\<br>-n_{y} &amp; n_{x} &amp; 0<br>\end{array}\right)$是叉乘向量的矩阵形式</li>
<li>四元数多是为了旋转之间的插值用的</li>
</ul>
</li>
<li><font color="red">四元数待课后补充</font>



</li>
</ul>
<h2 id="b-Viewing-Transformation"><a href="#b-Viewing-Transformation" class="headerlink" title="b). Viewing Transformation"></a>b). Viewing Transformation</h2><ul>
<li><strong>概念：</strong>Viewing Transformation（观测矩阵）相当于MVP中的VP<ul>
<li>View/Camera transformation</li>
<li>Projection transformation<ul>
<li>Orthographic projection</li>
<li>Perspective projection</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="b-1-View-Transformaiton"><a href="#b-1-View-Transformaiton" class="headerlink" title="b.1) View Transformaiton"></a>b.1) View Transformaiton</h3><ul>
<li><p><img src="/2022/10/02/Games101_02_04_Math/MVP_VP.png" alt="MVP_VP"></p>
</li>
<li><p><strong>Difine the camera:</strong></p>
<p><img src="/2022/10/02/Games101_02_04_Math/Difine_cam.png" alt="Difine_cam"></p>
</li>
<li><p><strong>View Space:</strong></p>
<ul>
<li>相机位于原点，上是$Y$，看向$-Z$</li>
<li>看成所有相机不动，全是其他物体动</li>
</ul>
</li>
</ul>
<ul>
<li>$M_{view}$：<ul>
<li>in math:<ul>
<li><img src="/2022/10/02/Games101_02_04_Math/M_in_math01.png" alt="M_in_math01"></li>
<li><img src="/2022/10/02/Games101_02_04_Math/M_in_math02.png" alt="M_in_math02"></li>
<li>直接应用矩阵空间变换</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="b-2-Projection-transformation"><a href="#b-2-Projection-transformation" class="headerlink" title="b.2) Projection transformation"></a>b.2) Projection transformation</h3><p><strong>这里的投影变换中对xyzw都乘了z，因此最后需要齐次除法（透视除法），转换到NDC(Normalized Device Coordinates)</strong></p>
<h4 id="b-2-1-Orthographic-Projection"><a href="#b-2-1-Orthographic-Projection" class="headerlink" title="b.2.1 Orthographic Projection"></a>b.2.1 <strong>Orthographic Projection</strong></h4><ul>
<li><p><strong>简易理解：</strong><img src="/2022/10/02/Games101_02_04_Math/Orthographic Projection.png" alt="Orthographic Projection"></p>
<ul>
<li>注意$[-1, 1]$</li>
</ul>
</li>
<li><p><strong>图形学中的做法：</strong><img src="/2022/10/02/Games101_02_04_Math/Orthographic Projection In general.png" alt="Orthographic Projection In general"></p>
<ul>
<li>通过平移将立方体中心化</li>
<li>缩放成标准立方体（“canonical” cube）</li>
<li>这里采用右手坐标系，缺点是$f&lt;n$，远的z值小于近的z值</li>
</ul>
</li>
<li><p><strong>矩阵形式：</strong></p>
<script type="math/tex; mode=display">
M_{\text {ortho }}=\left[\begin{array}{cccc}
\frac{2}{r-l} & 0 & 0 & 0 \\
0 & \frac{2}{t-b} & 0 & 0 \\
0 & 0 & \frac{2}{n-f} & 0 \\
0 & 0 & 0 & 1
\end{array}\right]\left[\begin{array}{cccc}
1 & 0 & 0 & -\frac{r+l}{2} \\
0 & 1 & 0 & -\frac{t+b}{2} \\
0 & 0 & 1 & -\frac{n+f}{2} \\
0 & 0 & 0 & 1
\end{array}\right]</script></li>
<li><p><strong><font color="red">Caveat:</font></strong></p>
<ul>
<li>（使用右手坐标系）看向 $-Z$ 使得$f&lt;n$，远的z值小于近的z值</li>
<li>这也是为什么OpenGL使用左手坐标系（但也会造成其他问题）</li>
</ul>
</li>
</ul>
<h4 id="b-2-2-Perspective-Projection"><a href="#b-2-2-Perspective-Projection" class="headerlink" title="b.2.2 Perspective Projection"></a>b.2.2 Perspective Projection</h4><ul>
<li><p><strong>前置知识：</strong><img src="/2022/10/02/Games101_02_04_Math/Recall_P_M.png" alt="Recall_P_M"></p>
</li>
<li><p><strong>How to do perspective projection</strong></p>
<p><img src="/2022/10/02/Games101_02_04_Math/how_to_perspective_projection.png" alt="how_to_perspective_projection"></p>
</li>
<li><p><strong>挤压（squish）</strong></p>
<p><img src="/2022/10/02/Games101_02_04_Math/squish.png" alt="squish"></p>
<p><img src="/2022/10/02/Games101_02_04_Math/squish02.png" alt="squish02"></p>
<ul>
<li>$M_{\text {persp } \rightarrow \text { ortho }}=\left(\begin{array}{cccc}<br>n &amp; 0 &amp; 0 &amp; 0 \\<br>0 &amp; n &amp; 0 &amp; 0 \\<br>? &amp; ? &amp; ? &amp; ? \\<br>0 &amp; 0 &amp; 1 &amp; 0<br>\end{array}\right)$</li>
<li>不知道经过挤压后$z$的变化（即第三行乘以$\left(\begin{array}{l}<br>x \\<br>y \\<br>n \\<br>1<br>\end{array}\right)$未知），但知道：<ul>
<li>在近平面的点不会变化</li>
<li>在远平面的中点不会变化</li>
</ul>
</li>
<li>$z=n$时，$\left(\begin{array}{l}<br>x \\<br>y \\<br>n \\<br>1<br>\end{array}\right) \Rightarrow\left(\begin{array}{l}<br>x \\<br>y \\<br>n \\<br>1<br>\end{array}\right)==\left(\begin{array}{c}<br>n x^{n} \\<br>n y \\<br>n^{2} \\<br>n<br>\end{array}\right)$<ul>
<li>易得$\left(\begin{array}{llll}<br>0 &amp; 0 &amp; A &amp; B<br>\end{array}\right)\left(\begin{array}{l}<br>x \\<br>y \\<br>n \\<br>1<br>\end{array}\right)=n^{2}$</li>
<li>$An+B=n^2$</li>
</ul>
</li>
<li>$z=f$时，对于远平面中点，$\left(\begin{array}{l}<br>0 \\<br>0 \\<br>f \\<br>1<br>\end{array}\right) \Rightarrow\left(\begin{array}{l}<br>0 \\<br>0 \\<br>f \\<br>1<br>\end{array}\right)==\left(\begin{array}{c}<br>0 \\<br>0 \\<br>f^{2} \\<br>f<br>\end{array}\right)$<ul>
<li>易得$\left(\begin{array}{llll}<br>0 &amp; 0 &amp; A &amp; B<br>\end{array}\right)\left(\begin{array}{l}<br>0 \\<br>0 \\<br>f \\<br>1<br>\end{array}\right)=f^{2}$</li>
<li>$Af+B=f^2$</li>
</ul>
</li>
<li><p>得$A=n+f$，$B=-nf$</p>
</li>
<li><p>$M_{\text {persp } \rightarrow \text { ortho }}=\left(\begin{array}{cccc}<br>n &amp; 0 &amp; 0 &amp; 0 \\<br>0 &amp; n &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; n+f &amp; -nf \\<br>0 &amp; 0 &amp; 1 &amp; 0<br>\end{array}\right)$</p>
</li>
<li><p>之后进行平行投影的变换，得</p>
<p>$\mathbf{M}_{\text {per }}=\left[\begin{array}{cccc}<br>\frac{2 n}{r-l} &amp; 0 &amp; \frac{l+r}{l-r} &amp; 0 \\<br>0 &amp; \frac{2 n}{t-b} &amp; \frac{b+t}{b-t} &amp; 0 \\<br>0 &amp; 0 &amp; \frac{f+n}{n-f} &amp; \frac{2 f n}{f-n} \\<br>0 &amp; 0 &amp; 1 &amp; 0<br>\end{array}\right]$</p>
</li>
</ul>
</li>
</ul>
<hr>
<p>【补充】</p>
<p>作业1中用到的<a href="https://www.cnblogs.com/graphics/archive/2012/08/10/2627458.html">绕任意轴旋转</a>：</p>
<p><img src="/2022/10/02/Games101_02_04_Math/rotation.jpg" alt="rotation"></p>
<ul>
<li><strong>步骤：</strong><ol>
<li>将旋转轴平移至原点</li>
<li>将旋转轴旋转至YOZ平面</li>
<li>将旋转轴旋转至于Z轴重合</li>
<li>绕Z轴旋转θ度</li>
<li>执行步骤3的逆过程</li>
<li>执行步骤2的逆过程</li>
<li>执行步骤1的逆过程</li>
</ol>
</li>
</ul>
<p><img src="/2022/10/02/Games101_02_04_Math/rotation02.jpg" alt="rotation02"></p>
<p>如果旋转轴是过原点的，那么第一步和最后一步的平移操作可以省略，也就是把中间五个矩阵连乘起来，再转置一下，得到下面的绕任意轴旋转的矩阵</p>
<script type="math/tex; mode=display">
\left[\begin{array}{cccc}
a^{2}+\left(1-a^{2}\right) \cos \theta & a b(1-\cos \theta)+\operatorname{csin} \theta & a c(1-\cos \theta)-b \sin \theta & 0 \\
a b(1-\cos \theta)-c \sin \theta & b^{2}+\left(1-b^{2}\right) \cos \theta & b c(1-\cos \theta)+a \sin \theta & 0 \\
a c(1-\cos \theta)+b \sin \theta & b c(1-\cos \theta)-a \sin \theta & c^{2}+\left(1-c^{2}\right) \cos \theta & 0 \\
0 & 0 & 0 & 1
\end{array}\right]</script>]]></content>
      <categories>
        <category>Games101</category>
      </categories>
      <tags>
        <tag>Games101</tag>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>Games101-5-6 Rasterization</title>
    <url>/2022/10/02/Games101_05_06_Rasterization/</url>
    <content><![CDATA[<h1 id="Lecture-05-Rasterization-Triangles"><a href="#Lecture-05-Rasterization-Triangles" class="headerlink" title="Lecture 05 Rasterization(Triangles)"></a>Lecture 05 Rasterization(Triangles)</h1><h2 id="a-Perspective-Projection"><a href="#a-Perspective-Projection" class="headerlink" title="a). Perspective Projection"></a>a). Perspective Projection</h2><ul>
<li><p>如何定义一个<strong>frustum</strong>：</p>
<p><img src="/2022/10/02/Games101_05_06_Rasterization/Frustum.png" alt="Frustum"></p>
<ul>
<li>近平面宽度、高度（得到宽高比）</li>
<li>FOV(Field of View)</li>
</ul>
</li>
</ul>
<h2 id="b-Viewport-transformation"><a href="#b-Viewport-transformation" class="headerlink" title="b). Viewport transformation"></a>b). Viewport transformation</h2><ul>
<li><p>经过MVP后，模型空间中点变换到标准立方体（canonical cube, x,y,z[-1, 1]）中。之后就需要进行视口变换（Viewport transformation）</p>
</li>
<li><p><strong>定义屏幕空间</strong></p>
<p><img src="/2022/10/02/Games101_05_06_Rasterization/Difine_the_screen_space.png" alt="Difine_the_screen_space"></p>
<ul>
<li>OpenGL屏幕空间坐标原点为左下（上图），DX坐标原点为左上</li>
<li>像素位置该像素（方块）左下角的坐标，如左下角像素坐标为$(0, 0)$，但像素中心为$(0.5, 0.5)$</li>
</ul>
</li>
<li><p><strong>Viewport transformation</strong></p>
<p><img src="/2022/10/02/Games101_05_06_Rasterization/ScreenSpace_transformation.png" alt="ScreenSpace_transformation"></p>
</li>
</ul>
<h2 id="c-Rasterization"><a href="#c-Rasterization" class="headerlink" title="c). Rasterization"></a>c). Rasterization</h2><ul>
<li><p><strong>Frame Buffer</strong>: Memory for a Raster Display</p>
<ul>
<li><p>显存中的一块区域</p>
</li>
<li><p>补充：Render texture（详情见Other/Note）</p>
<ul>
<li><blockquote>
<p>以下以Unity为例：</p>
<p>渲染过程中，贴图最开始在CPU内存，这时的贴图被称为client-side的texture，最后被送到GPU，这时叫server-side的texture；</p>
<p>Render texture是将FrameBufferObject连接到一个server-side的texture；</p>
<ul>
<li>注意：FrameBufferObject不一定只有一个，也不一定连接屏幕；</li>
</ul>
<p>详情：<a href="http://t.csdn.cn/3JHqA">http://t.csdn.cn/3JHqA</a></p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>Triangles - Fundamental Shape Primitives</strong></p>
<ul>
<li>无法分割为其他多边形</li>
<li>保证是一个平面</li>
<li>容易区分内部和外部</li>
<li>内部插值方便</li>
<li><img src="/2022/10/02/Games101_05_06_Rasterization/Triangles.png" alt="Triangles"></li>
</ul>
</li>
<li><p><strong>Fundament：</strong> <em>What Pixel Values Approximate a Triangle?<img src="/2022/10/02/Games101_05_06_Rasterization/T2PV.png" alt="T2PV"></em></p>
<ul>
<li><p>Sampling（采样）：逐像素中心采样，判断像素是否在三角形内</p>
<ul>
<li><pre><code>for (int x = 0; x &lt; xmax; ++x)
 output[x] = f(x);
</code></pre></li>
<li><p><img src="/2022/10/02/Games101_05_06_Rasterization/if_PinT.png" alt="if_PinT"></p>
</li>
</ul>
</li>
<li><p><strong>判断$(x,y)$是否在三角形内：</strong>做三次叉乘，看正负符号是否相同，相同则在三角形内；</p>
</li>
<li><p>Edge Cases：要么不做处理，要么特殊处理（OpenGL，DX里规定落于左边和上边算三角形中的点，而落于右边和下边的不算<strong>“<em>Top</em>-<em>Left</em> <em>Rule</em>“</strong>）<img src="/2022/10/02/Games101_05_06_Rasterization/Top_left_rule.png" alt="Top_left_rule"></p>
</li>
</ul>
</li>
<li><p><strong>光栅化加速</strong></p>
<ul>
<li>光栅化中，对每一个像素都判断是否在三角形中性能浪费过大。因此，加入<strong>Bounding Box（包围盒）</strong>来限定需要进行判断的区域<img src="/2022/10/02/Games101_05_06_Rasterization/BoundingBox.png" alt="BoundingBox"></li>
<li>Incremental Triangle Traversal（找到三角形中每一行最左和最右的像素，但实际上没那么容易，是用于细长并旋转的三角形）<img src="/2022/10/02/Games101_05_06_Rasterization/Incremental_Triangle_Traversal.png" alt="Incremental_Triangle_Traversal"></li>
</ul>
</li>
</ul>
<h1 id="Lecture-6-Rasterization-2-Antialiasing-and-Z-Buffering"><a href="#Lecture-6-Rasterization-2-Antialiasing-and-Z-Buffering" class="headerlink" title="Lecture 6: Rasterization 2(Antialiasing and Z-Buffering)"></a>Lecture 6: Rasterization 2(Antialiasing and Z-Buffering)</h1><h2 id="a-Sampling-Artifacts-Errors-Mistakes-Inaccuracies-in-Computer-Graphics"><a href="#a-Sampling-Artifacts-Errors-Mistakes-Inaccuracies-in-Computer-Graphics" class="headerlink" title="a). Sampling Artifacts(Errors / Mistakes / Inaccuracies) in Computer Graphics"></a>a). Sampling Artifacts(Errors / Mistakes / Inaccuracies) in Computer Graphics</h2><ul>
<li>由于采样造成的“Artifacts“<ul>
<li>锯齿（ <em>Jaggies</em>）——空间上采样</li>
<li>摩尔纹（<em>Moire</em>）——欠采样图像</li>
<li>车轮错觉（<em>Wagon wheel effect</em>）——时间上采样</li>
<li>……</li>
</ul>
</li>
<li><strong>造成错误的原因：</strong>信号频率高，而采样频率低（可联系<strong>奈奎斯特定理：</strong>当采样频率大于信号中最高频率的2倍时(fs&gt;2f)，采样之后的数字信号完整地保留了原始信号中的信息）</li>
</ul>
<h2 id="b-Antialiasing-Idea-Blurring-Pre-Filtering-Before-Sampling"><a href="#b-Antialiasing-Idea-Blurring-Pre-Filtering-Before-Sampling" class="headerlink" title="b). Antialiasing Idea:Blurring (Pre-Filtering) Before Sampling"></a>b). Antialiasing Idea:Blurring (Pre-Filtering) Before Sampling</h2><ul>
<li><p>抗锯齿的思路就是在采样前”模糊“；</p>
<p><img src="/2022/10/02/Games101_05_06_Rasterization/AS.png" alt="AS"></p>
<ul>
<li><strong>注意：</strong>先模糊，后采样。对应频域上先低通滤波（或其他操作，如卷积、超采样，FSAA那种图像层面的抗锯齿暂不考虑），后采样（<strong>卷积定理：</strong>时域信号与冲激信号相乘，等于两者对应的频域信号卷积。反之，也成立）；</li>
</ul>
</li>
</ul>
<h2 id="c-Frequency-Domain"><a href="#c-Frequency-Domain" class="headerlink" title="c). Frequency Domain"></a>c). Frequency Domain</h2><h3 id="c-1-Fundamental"><a href="#c-1-Fundamental" class="headerlink" title="c.1). Fundamental"></a>c.1). Fundamental</h3><ul>
<li><p>傅里叶变换</p>
</li>
<li><p><strong>卷积定理：</strong>时域中乘积等于频域上卷积，反之也成立。（时域信号与冲激信号相乘，等于两者对应的频域信号卷积。反之，也成立。）</p>
</li>
<li><p><strong>Aliases:</strong> 在给定的采样率下，无法区分两个不同频率<img src="/2022/10/02/Games101_05_06_Rasterization/Aliases.png" alt="Aliases"></p>
</li>
</ul>
<h3 id="c-2-Filtering-Getting-rid-of-certain-frequency-contents"><a href="#c-2-Filtering-Getting-rid-of-certain-frequency-contents" class="headerlink" title="c.2). Filtering: Getting rid of certain frequency contents"></a>c.2). Filtering: Getting rid of certain frequency contents</h3><ul>
<li>K空间：反应图像进过二维傅里叶变换后的结果，越靠中间，频率越小；<img src="/2022/10/02/Games101_05_06_Rasterization/K_space.png" alt="K_space"><ul>
<li>出现十字星的原因：把图像看成类似Wrap Mode的Repeat，即重复的图像。使得其四个方向的高频内容增加，形成十字星；</li>
</ul>
</li>
<li><strong>Filter（滤波器）：</strong><ul>
<li><strong>High-pass filter</strong><img src="/2022/10/02/Games101_05_06_Rasterization/High_pass filter.png" alt="High_pass filter"></li>
<li><strong>Low-pass filter</strong><img src="/2022/10/02/Games101_05_06_Rasterization/Low_pass_filter.png" alt="Low_pass_filter"></li>
<li>Filter Out Low and High Frequencies<img src="/2022/10/02/Games101_05_06_Rasterization/F_Low_and_high.png" alt="F_Low_and_high"></li>
</ul>
</li>
</ul>
<h3 id="c-3-Convolution"><a href="#c-3-Convolution" class="headerlink" title="c.3). Convolution"></a>c.3). Convolution</h3><ul>
<li><strong>Filtering = Convolution (= Averaging)</strong><ul>
<li>注意：只是在这里相等，而滤波和卷积概念上不相同；</li>
</ul>
</li>
<li><strong>对信号进行滤波，就是用卷积核和信号做卷积；</strong><ul>
<li>Point-wise local averaging in a “sliding window”<img src="/2022/10/02/Games101_05_06_Rasterization/convolution.png" alt="convolution"></li>
</ul>
</li>
</ul>
<ul>
<li><strong>卷积定理：</strong>在空域（时域）做卷积，等于在频域做乘积；反之亦然。<ul>
<li>因此，对图像滤波有两种处理方法；<ul>
<li><strong>Option 1: </strong>在空域上与滤波器（卷积核）做卷积；</li>
<li><strong>Option 2: </strong><ol>
<li>将图像和滤波器（卷积核）转换到频域（傅里叶变换）；</li>
<li>两者在频域相乘；</li>
<li>将得到的结果重新变换到空域（逆傅里叶变换）；<img src="/2022/10/02/Games101_05_06_Rasterization/Convolution_Theorem.png" alt="Convolution_Theorem"></li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>Box Filter</strong><img src="/2022/10/02/Games101_05_06_Rasterization/BoxFilter.png" alt="BoxFilter"><ul>
<li>箱式滤波类似于低通滤波<img src="/2022/10/02/Games101_05_06_Rasterization/BoxF_LP.png" alt="BoxF_LP"></li>
<li>更大的卷积核意味着更低的频率<img src="/2022/10/02/Games101_05_06_Rasterization/WiderFK.png" alt="WiderFK"></li>
</ul>
</li>
</ul>
<h3 id="c-4-Sampling-Repeating-Frequency-Contents"><a href="#c-4-Sampling-Repeating-Frequency-Contents" class="headerlink" title="c.4). Sampling = Repeating Frequency Contents"></a>c.4). Sampling = Repeating Frequency Contents</h3><p><img src="/2022/10/02/Games101_05_06_Rasterization/Sampling.png" alt="Sampling"></p>
<ul>
<li>锯齿=混叠<img src="/2022/10/02/Games101_05_06_Rasterization/MixedFrequencyContents.png" alt="MixedFrequencyContents"></li>
</ul>
<h2 id="d-Antialiasing"><a href="#d-Antialiasing" class="headerlink" title="d). Antialiasing"></a>d). Antialiasing</h2><ul>
<li>解决锯齿的选择：<ul>
<li>提高采样率<ul>
<li>增大冲激信号在频域的距离；</li>
<li>更高分辨率的显示器；</li>
<li>缺点：成本高，且需要很高的分辨率</li>
</ul>
</li>
<li><strong>抗锯齿</strong><ul>
<li>让信号在采样（重复，Repeat）前变“窄”，即<strong>在采样前过滤掉高频部分</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>Antialiasing = Limiting, then repeating</strong><img src="/2022/10/02/Games101_05_06_Rasterization/AA.png" alt="AA"></li>
<li><img src="/2022/10/02/Games101_05_06_Rasterization/Pre-Filter.png" alt="Pre-Filter"><ul>
<li>Solution: <ul>
<li><strong>Convolve</strong> f(x,y) by a <strong>1-pixel box-blur</strong><ul>
<li>Recall: convolving = filtering = averaging </li>
</ul>
</li>
<li><strong>Then sample</strong> at every pixel’s center</li>
</ul>
</li>
</ul>
</li>
<li><strong>通过计算像素平均值来抗锯齿</strong><img src="/2022/10/02/Games101_05_06_Rasterization/Avertage_Pixel_Value.png" alt="Avertage_Pixel_Value"></li>
</ul>
<h2 id="e-SSAA-Super-Sampling-Antialiasing"><a href="#e-SSAA-Super-Sampling-Antialiasing" class="headerlink" title="e). SSAA(Super Sampling Antialiasing)"></a>e). SSAA(Super Sampling Antialiasing)</h2><ul>
<li>通过将一个像素分割成NxN个像素来进行采样和shading，最后将每个像素点内部所细分的采样点的颜色值全部加起来再求均值，作为该像素点的抗锯齿之后的颜色值<img src="/2022/10/02/Games101_05_06_Rasterization/SSAA.png" alt="SSAA"></li>
</ul>
<h2 id="f-MSAA-Multi-Sampling-Antialiasing"><a href="#f-MSAA-Multi-Sampling-Antialiasing" class="headerlink" title="f). MSAA(Multi-Sampling Antialiasing)"></a>f). MSAA(Multi-Sampling Antialiasing)</h2><ul>
<li>MSAA是对SSAA的改进。SSAA的计算量大，一个像素中会有多个点进行shading，而MSAA只是计算究竟有几个采样点会被三角形cover，计算颜色的时候只会利用像素中心坐标进行一次shading。<img src="/2022/10/02/Games101_05_06_Rasterization/MSAA.png" alt="MSAA"></li>
<li>如图中大点所在的像素块，三角形只覆盖了其中的三个点（左下，右上，右下），则该像素的颜色为$75\%Color_{origin}$，<strong>之后，再对像素中心进行采样</strong></li>
<li><strong>注意</strong>：MSAA只是近似Blur，而没提高采样率。要注意和SSAA以及高分辨率的区分</li>
<li><strong>在实际中</strong>，子像素的划分并不是均匀划分为NxN，而是通过其他更有效的方法，而且有些样本还会得到复用；</li>
</ul>
<blockquote>
<ul>
<li><strong>SSAA中每个像素点有4个子采样点，每个三角形对每个像素点的4个子采样点各着色1次（共4次）</strong>，再把计算结果根据深度和覆盖信息保存到对应的子采样点，最后对4个采样点取均值作为最终的像素颜色；</li>
<li><strong>MSAA中每个像素点有4个子采样点，每个三角形对每个像素点只在中心点着色1次</strong>，再把计算结果根据深度和覆盖信息保存到对应的子采样点，最后对4个采样点取均值作为最终的像素颜色；</li>
</ul>
</blockquote>
<h2 id="g-Other-AA"><a href="#g-Other-AA" class="headerlink" title="g). Other AA"></a>g). Other AA</h2><ul>
<li><strong>FXAA(Fast Approximate AA)</strong><ul>
<li><strong>图像层面</strong>上进行处理，是一个后期处理，先得到有锯齿的图像，再通过图像匹配找到有锯齿的边界，之后，替换为没有锯齿的边界；</li>
</ul>
</li>
<li><strong>TAA(Temporal AA)</strong><ul>
<li>可以联系UE_NOTE</li>
<li>将空域采样点，均匀分布到时域上；</li>
</ul>
</li>
</ul>
<h2 id="h-Z-buffer"><a href="#h-Z-buffer" class="headerlink" title="h). Z-buffer"></a>h). Z-buffer</h2><h3 id="h-0-Painter’s-Algorithm"><a href="#h-0-Painter’s-Algorithm" class="headerlink" title="h.0). Painter’s Algorithm"></a>h.0). Painter’s Algorithm</h3><ul>
<li>画家算法：<ul>
<li>对三角形进行排序，先画远的，再画近的；</li>
<li>不能解决相互遮挡问题，因此采用Z-buffer<img src="/2022/10/02/Games101_05_06_Rasterization/Painters_Algorithm.png" alt="Painters_Algorithm"></li>
</ul>
</li>
</ul>
<h3 id="h-1-Z-buffer"><a href="#h-1-Z-buffer" class="headerlink" title="h.1). Z-buffer"></a>h.1). Z-buffer</h3><ul>
<li><strong>Idea：</strong><ul>
<li>储存<strong>每个采样（像素）</strong>中最小的深度值；</li>
<li>储存深度值到缓存区（buffer）中；</li>
</ul>
</li>
<li>为了简单起见，我们看作z是正数(smaller z -&gt; closer, larger z -&gt; further)；<img src="/2022/10/02/Games101_05_06_Rasterization/Z-Buffer.png" alt="Z-Buffer"></li>
<li>深度缓存步骤：<ol>
<li><strong>初始化深度缓存，将其中每个值初始化为∞</strong></li>
<li><strong>遍历每个三角形面上的每一个像素点[x,y]，如果该像素点的深度值z，小于Z-buffer[x,y]中的值，则更新zbuffer[x,y]值为该点深度值z，并同时更新该像素点[x,y]的颜色为该三角形面上的该点的颜色。</strong><ul>
<li>伪代码：<img src="/2022/10/02/Games101_05_06_Rasterization/PCode.png" alt="PCode"></li>
</ul>
</li>
</ol>
</li>
</ul>
<p><img src="/2022/10/02/Games101_05_06_Rasterization/Z-Buffer_Algorithm.png" alt="Z-Buffer_Algorithm"></p>
<ul>
<li>时间复杂度$O(n)$。Z-buffer并没有进行排序，只是求得最小（深度）值，因此时间复杂度为线性；</li>
<li>三角形的绘制顺序并不影响最终结果（不考虑不透明等情况）；</li>
</ul>
]]></content>
      <categories>
        <category>Games101</category>
      </categories>
      <tags>
        <tag>Games101</tag>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>Games101-7-9 Shading</title>
    <url>/2022/10/02/Games101_07_09_Shading/</url>
    <content><![CDATA[<h1 id="Lecture-07-08-Shading-Illumination-Shading-and-Graphics-Pipeline"><a href="#Lecture-07-08-Shading-Illumination-Shading-and-Graphics-Pipeline" class="headerlink" title="Lecture 07/08 Shading(Illumination, Shading and Graphics Pipeline)"></a>Lecture 07/08 Shading(Illumination, Shading and Graphics Pipeline)</h1><h2 id="a-Definition"><a href="#a-Definition" class="headerlink" title="a). Definition"></a>a). Definition</h2><p><img src="/2022/10/02/Games101_07_09_Shading/Shading_Definition.png" alt="Shading_Definition"></p>
<h2 id="b-A-Simple-Shading-Model-Blinn-Phong-Reflectance-Model"><a href="#b-A-Simple-Shading-Model-Blinn-Phong-Reflectance-Model" class="headerlink" title="b). A Simple Shading Model(Blinn-Phong Reflectance Model)"></a>b). A Simple Shading Model(Blinn-Phong Reflectance Model)</h2><h3 id="b-1-Fundamental"><a href="#b-1-Fundamental" class="headerlink" title="b.1). Fundamental"></a>b.1). Fundamental</h3><ul>
<li><p>Blinn-Phong是一个<strong>经验模型</strong>，并不是严格基于物理的；</p>
</li>
<li><p><strong>进入视线内的光照一般有以下构成：</strong></p>
<ul>
<li>高光（Specualr）</li>
<li>漫反射（Diffuse）</li>
<li>环境光（Ambient）</li>
<li>自发光（Emissive）</li>
</ul>
</li>
<li><p><strong>Shading is Local: </strong>Compute light reflected toward camera at a <font color="red"><strong>specific shading point</strong></font><img src="/2022/10/02/Games101_07_09_Shading/ShadingInput.png" alt="ShadingInput"></p>
<ul>
<li><p>No shadows will be generated! <strong>(shading ≠ shadow)</strong> </p>
<ul>
<li>阴影会由另外的Shadow Caster来着色；</li>
</ul>
<p><img src="/2022/10/02/Games101_07_09_Shading/NoShadow.png" alt="NoShadow"></p>
</li>
</ul>
</li>
</ul>
<h3 id="b-2-Diffuse-Reflection"><a href="#b-2-Diffuse-Reflection" class="headerlink" title="b.2). Diffuse Reflection"></a>b.2). Diffuse Reflection</h3><ul>
<li>Blinn-Phong中，漫反射的光均匀散射到各个方向；<img src="/2022/10/02/Games101_07_09_Shading/Blinn-Phong_Diffuse.png" alt="Blinn-Phong_Diffuse"></li>
<li><p><strong>Lambert’s cosine law</strong>：接收到的能量与 $l·n$ 成正比例<img src="/2022/10/02/Games101_07_09_Shading/Lambert_cos_law.png" alt="Lambert_cos_law"></p>
</li>
<li><p><strong>Light Falloff</strong><img src="/2022/10/02/Games101_07_09_Shading/LightFalloff.png" alt="LightFalloff"></p>
</li>
<li><p><strong>漫反射最终的着色：</strong><img src="/2022/10/02/Games101_07_09_Shading/LambertDiffuseShading.png" alt="LambertDiffuseShading"><img src="/2022/10/02/Games101_07_09_Shading/Diffuse_kd.png" alt="Diffuse_kd"></p>
</li>
</ul>
<h3 id="b-3-Specular-Term-Blinn-Phong"><a href="#b-3-Specular-Term-Blinn-Phong" class="headerlink" title="b.3). Specular Term(Blinn-Phong)"></a>b.3). Specular Term(Blinn-Phong)</h3><ul>
<li><p>Intensity <strong>depends</strong> on view direction</p>
<p><img src="/2022/10/02/Games101_07_09_Shading/Specular.png" alt="Specular" style="zoom: 33%;"></p>
</li>
<li><p><img src="/2022/10/02/Games101_07_09_Shading/Blinn-Phong_Half_vector.png" alt="Blinn-Phong_Half_vector"></p>
<ul>
<li>采用半程向量简化计算。采用半程向量$h$与$n$点乘的是Blinn-Phong模型，而采用镜面反射方向$r$和视线方向$v$点乘的是Phong模型；</li>
<li><strong>指数$p$的作用：</strong>Increasing p narrows the reflection lobe<img src="/2022/10/02/Games101_07_09_Shading/Specular_Power.png" alt="Specular_Power"></li>
<li>效果总览：<img src="/2022/10/02/Games101_07_09_Shading/Specular_Term.png" alt="Specular_Term"></li>
</ul>
</li>
</ul>
<h3 id="b-4-Ambient-Term"><a href="#b-4-Ambient-Term" class="headerlink" title="b.4). Ambient Term"></a>b.4). Ambient Term</h3><p><img src="/2022/10/02/Games101_07_09_Shading/AmbientTerm.png" alt="AmbientTerm"></p>
<p><img src="/2022/10/02/Games101_07_09_Shading/Blinn-Phong.png" alt="Blinn-Phong"></p>
<h2 id="c-Shading-Frequencies"><a href="#c-Shading-Frequencies" class="headerlink" title="c). Shading Frequencies"></a>c). Shading Frequencies</h2><h3 id="c-1-Flat-shading"><a href="#c-1-Flat-shading" class="headerlink" title="c.1). Flat shading"></a>c.1). Flat shading<img src="/2022/10/02/Games101_07_09_Shading/FlatShading.png" alt="FlatShading"></h3><h3 id="c-2-Gouraud-shading"><a href="#c-2-Gouraud-shading" class="headerlink" title="c.2). Gouraud shading "></a>c.2). Gouraud shading <img src="/2022/10/02/Games101_07_09_Shading/GouraudShading.png" alt="GouraudShading"></h3><h3 id="c-3-Phong-shading"><a href="#c-3-Phong-shading" class="headerlink" title="c.3). Phong shading"></a>c.3). Phong shading<img src="/2022/10/02/Games101_07_09_Shading/PhongShading.png" alt="PhongShading"></h3><h3 id="c-4-对比"><a href="#c-4-对比" class="headerlink" title="c.4). 对比"></a>c.4). 对比</h3><p><img src="/2022/10/02/Games101_07_09_Shading/ShadingFreq.png" alt="ShadingFreq"></p>
<ul>
<li>不一定Phong着色就比Flat优秀。在极高面数的一些情况下，Flat Shading性能开销比Phong Shading小，且呈现效果相差无几；</li>
</ul>
<h3 id="c-5-定义顶点-像素法线"><a href="#c-5-定义顶点-像素法线" class="headerlink" title="c.5). 定义顶点/像素法线"></a>c.5). 定义顶点/像素法线</h3><ul>
<li><p><strong><font color="red">顶点法线</font>为相邻三角形的加权平均</strong>（<strong>权重与三角面的面积有关</strong>，当然也可简单平均，但效果较加权平均差）；<img src="/2022/10/02/Games101_07_09_Shading/VectorsNormal.png" alt="VectorsNormal"></p>
</li>
<li><p><strong><font color="red">逐像素的法线</font>通过对顶点法线进行<font color="red">重心插值（Barycentric interpolation）</font>后归一化（normalize）得到；</strong><img src="/2022/10/02/Games101_07_09_Shading/PixelNormal.png" alt="PixelNormal"></p>
</li>
</ul>
<h2 id="d-Graphics-Real-time-Rendering-Pipeline"><a href="#d-Graphics-Real-time-Rendering-Pipeline" class="headerlink" title="d). Graphics(Real-time Rendering) Pipeline"></a>d). Graphics(Real-time Rendering) Pipeline</h2><ul>
<li>这段可看冯的入门精要作为简单的补充</li>
</ul>
<p><img src="/2022/10/02/Games101_07_09_Shading/GraphicsPipeline.png" alt="GraphicsPipeline"></p>
<ul>
<li><p>MVP矩阵相关的发生在顶点阶段；<img src="/2022/10/02/Games101_07_09_Shading/PipelineVertex.png" alt="PipelineVertex"></p>
</li>
<li><p>光栅化；<img src="/2022/10/02/Games101_07_09_Shading/Rasterization_in_pp.png" alt="Rasterization_in_pp"></p>
</li>
<li><p><img src="/2022/10/02/Games101_07_09_Shading/Frag.png" alt="Frag"></p>
</li>
<li><p>Shading可在Vertex Processing阶段，也可在Fragment Processing阶段；<img src="/2022/10/02/Games101_07_09_Shading/Shading_in_PP.png" alt="Shading_in_PP"></p>
</li>
<li><p>Texture mapping<img src="/2022/10/02/Games101_07_09_Shading/TexMapping.png" alt="TexMapping"></p>
</li>
<li><p>Shader：<img src="/2022/10/02/Games101_07_09_Shading/ShaderEX.png" alt="ShaderEX"></p>
</li>
<li><p>优秀Shader（到时候好好学习一下）<img src="/2022/10/02/Games101_07_09_Shading/Example.png" alt="Example"></p>
<ul>
<li>Inigo Quilez, <a href="https://youtu.be/XuSnLbB1j6E">https://youtu.be/XuSnLbB1j6E</a></li>
</ul>
</li>
</ul>
<h1 id="Lecture-08-09-Shading-Texture-Mapping"><a href="#Lecture-08-09-Shading-Texture-Mapping" class="headerlink" title="Lecture 08/09 Shading(Texture Mapping)"></a>Lecture 08/09 Shading(Texture Mapping)</h1><ul>
<li>可见 <a href="..\..\百人计划\图形\01\Note.md">百人计划-图形1.3-纹理的秘密</a> 作为补充；</li>
</ul>
<h2 id="a-Interpolation-Across-Triangles-Barycentric-Coordinates"><a href="#a-Interpolation-Across-Triangles-Barycentric-Coordinates" class="headerlink" title="a). Interpolation Across Triangles: Barycentric Coordinates"></a>a). Interpolation Across Triangles: Barycentric Coordinates</h2><ul>
<li><p><strong>重心插值的作用：</strong>通过<strong>顶点</strong>特定的值（normal、Color、Depth、Texture coordinates…），得到三角形内部<strong>片元（像素）</strong>上平滑过渡的值；</p>
</li>
<li><p><strong>数学基础：</strong></p>
<ul>
<li>共面需满足的条件：<ul>
<li>$α+β+γ=1$，如需要点在三角形内，还需满足$α&gt;0,β&gt;0,γ&gt;0$<img src="/2022/10/02/Games101_07_09_Shading/Barycentiric_inMath.png" alt="Barycentiric_inMath"></li>
</ul>
</li>
<li>重心坐标求法：<img src="/2022/10/02/Games101_07_09_Shading/Barycentiric_inMath02.png" alt="Barycentiric_inMath02"></li>
<li>由以上易得，重心坐标$\begin{aligned}(x, y) &amp;=\frac{1}{3} A+\frac{1}{3}B+\frac{1}{3} C\end{aligned}$<img src="/2022/10/02/Games101_07_09_Shading/Barycentiric_inMath03.png" alt="Barycentiric_inMath03"></li>
<li>通用计算公式：<img src="/2022/10/02/Games101_07_09_Shading/Barycentiric_inMath04.png" alt="Barycentiric_inMath04"></li>
<li><strong>Final：</strong><img src="/2022/10/02/Games101_07_09_Shading/Barycentiric_inMath05.png" alt="Barycentiric_inMath05"><ul>
<li><strong><font color="red">注意：</font></strong>重心并没有投影不变性，因此进行插值需要在三维空间中进行，而不是在屏幕的二维投影上；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="b-Texture-Magnification-需要放大纹理的情况"><a href="#b-Texture-Magnification-需要放大纹理的情况" class="headerlink" title="b). Texture Magnification(需要放大纹理的情况)"></a>b). Texture Magnification(需要放大纹理的情况)</h2><ul>
<li>对应情况：纹理过小（如距离物体近，而贴图小）</li>
<li><strong>插值方式：</strong><ul>
<li>Nearest</li>
<li>Bilinear</li>
<li>Bicubic</li>
</ul>
</li>
</ul>
<h3 id="b-1-Bilinear-Interpolation"><a href="#b-1-Bilinear-Interpolation" class="headerlink" title="b.1). Bilinear Interpolation"></a>b.1). Bilinear Interpolation</h3><p><img src="/2022/10/02/Games101_07_09_Shading/BilinearInterpolation.png" alt="BilinearInterpolation"></p>
<h2 id="c-Texture-Magnification-需要缩小纹理的情况"><a href="#c-Texture-Magnification-需要缩小纹理的情况" class="headerlink" title="c).  Texture Magnification(需要缩小纹理的情况)"></a>c).  Texture Magnification(需要缩小纹理的情况)</h2><ul>
<li><p>对应情况：纹理过大（如距离物体远，而贴图大）<img src="/2022/10/02/Games101_07_09_Shading/TexturePS.png" alt="TexturePS"><img src="/2022/10/02/Games101_07_09_Shading/TexturePS02.png" alt="TexturePS02"></p>
</li>
<li><p><strong>解决思路：</strong></p>
<ul>
<li>增大采样率（超采样）<ul>
<li>高质量，但性能开销大；</li>
</ul>
</li>
<li>减小贴图频率（<strong>Mipmap</strong>）</li>
</ul>
</li>
</ul>
<h3 id="c-1-Mipmap"><a href="#c-1-Mipmap" class="headerlink" title="c.1). Mipmap"></a>c.1). Mipmap</h3><p>  <img src="/2022/10/02/Games101_07_09_Shading/Mipmap.png" alt="Mipmap"><img src="/2022/10/02/Games101_07_09_Shading/Mipmap02.png" alt="Mipmap02"></p>
<h3 id="c-1-如何确定Mipmap的level（参考百人计划）："><a href="#c-1-如何确定Mipmap的level（参考百人计划）：" class="headerlink" title="c.1). 如何确定Mipmap的level（参考百人计划）："></a>c.1). 如何确定Mipmap的level（参考百人计划）：<img src="/2022/10/02/Games101_07_09_Shading/mipmap_level.png" alt="mipmap_level"><img src="/2022/10/02/Games101_07_09_Shading/mipmap_level02.png" alt="mipmap_level02"></h3><h3 id="c-2-Mipmap之间的过渡"><a href="#c-2-Mipmap之间的过渡" class="headerlink" title="c.2). Mipmap之间的过渡"></a>c.2). Mipmap之间的过渡</h3><ul>
<li><p>Visualization of Mipmap Level(D rounded to nearest integer level)：<img src="/2022/10/02/Games101_07_09_Shading/Visualization_of_MipmapLevel.png" alt="Visualization_of_MipmapLevel"></p>
</li>
<li><p><strong><font color="red">Trilinear Interpolation</font></strong></p>
<ul>
<li><strong>作法：</strong>对相邻两层的Mipmap做Bilinear Interpolation，根据所得的level，对相邻两层进过插值的结果再进行一次插值；（e.g. D=1.6，则对一层和二层分别进行双线性插值后，再进行$lerp(1.6-1, n_1, n_2)$）<img src="/2022/10/02/Games101_07_09_Shading/TrilinearInterpolation.png" alt="TrilinearInterpolation"></li>
<li>Final：<img src="/2022/10/02/Games101_07_09_Shading/Visualization_of_MipmapLevel02.png" alt="Visualization_of_MipmapLevel02"></li>
</ul>
</li>
</ul>
<h2 id="d-Applications-of-Textures"><a href="#d-Applications-of-Textures" class="headerlink" title="d). Applications of Textures"></a>d). Applications of Textures</h2><h3 id="d-1-Environment-Map"><a href="#d-1-Environment-Map" class="headerlink" title="d.1). Environment Map"></a>d.1). Environment Map</h3><ul>
<li><strong>简介：</strong><img src="/2022/10/02/Games101_07_09_Shading/EnvironmentMap.png" alt="EnvironmentMap"><ul>
<li>对于环境光源，我们认为它来自与无限远处，<strong>即没有深度意义，不同位置的同一方向受到的环境光源相同</strong>（当然，暂不考虑遮挡）</li>
</ul>
</li>
<li><strong>Spherical Environment Map：</strong><img src="/2022/10/02/Games101_07_09_Shading/SphericalEnvironmentMap.png" alt="SphericalEnvironmentMap"><ul>
<li><strong>Problem：</strong>不是均匀的描述，在极点会存在较大的扭曲；<img src="/2022/10/02/Games101_07_09_Shading/SphericalMap_Problem.png" alt="SphericalMap_Problem"></li>
</ul>
</li>
</ul>
<ul>
<li><strong>CubeMap：</strong><img src="/2022/10/02/Games101_07_09_Shading/CubeMap00.png" alt="CubeMap00"><img src="/2022/10/02/Games101_07_09_Shading/CubeMap.png" alt="CubeMap"></li>
</ul>
<h3 id="d-2-Bump-Mapping"><a href="#d-2-Bump-Mapping" class="headerlink" title="d.2). Bump Mapping"></a>d.2). Bump Mapping</h3><p><img src="/2022/10/02/Games101_07_09_Shading/BumpMap01.png" alt="BumpMap01"></p>
<p><img src="/2022/10/02/Games101_07_09_Shading/BumpMap02.png" alt="BumpMap02"></p>
<ul>
<li><p><strong>凹凸贴图（视差贴图/法线贴图）计算法线过程：</strong></p>
<ul>
<li><p><strong>思路（一维情况，in flatland）：</strong></p>
<ul>
<li>原始法线 $n(p)=(0,1)$</li>
<li>在 p 点的导数 $dp=c·[h(p+1)-h(p)]$ （$c$ 是常数，用于缩放导数，改变其影响程度），得出切线</li>
<li>计算法线（垂直于切线） $n(p)=(-dp,1).normalized()$；</li>
</ul>
<p><img src="/2022/10/02/Games101_07_09_Shading/perturbNormal.png" alt="perturbNormal"></p>
</li>
<li><p><strong>思路（in 3D）：</strong></p>
<ul>
<li>原始法线 $n(p)=(0,0,1)$；</li>
<li>纹理上的点对 $u$ 方向和 $v$ 方向求偏导，得出切线<ul>
<li>$dp/du=c1·[h(u+1)-h(u)]$</li>
<li>$dp/dv=c2·[h(v+1)-h(v)]$</li>
</ul>
</li>
<li>计算法线（垂直于切线） $n(p)=(-dp/du,-dp/dv,1).normalized()$；</li>
</ul>
</li>
<li><p>以上计算均在<strong>切线空间、局部空间</strong>计算（具体看冯-入门精要）</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>Displacement mapping（置换/高度贴图）:</strong></p>
<ul>
<li>需要足够多的三角面（DX中的Dynamic Tessellation，动态曲面细分）</li>
<li>真正地<strong>移动了顶点</strong></li>
</ul>
<p><img src="/2022/10/02/Games101_07_09_Shading/Bump_vs_Displacement.png" alt="Bump_vs_Displacement"></p>
</li>
</ul>
<h3 id="d-3-3D-Procedural-Noise-Solid-Modeling"><a href="#d-3-3D-Procedural-Noise-Solid-Modeling" class="headerlink" title="d.3). 3D Procedural Noise + Solid Modeling"></a>d.3). 3D Procedural Noise + Solid Modeling</h3><p><img src="/2022/10/02/Games101_07_09_Shading/3DProceduralNoise.png" alt="3DProceduralNoise"></p>
<ul>
<li>Perlin noise</li>
</ul>
<h3 id="d-4-Provide-Precomputed-Shading"><a href="#d-4-Provide-Precomputed-Shading" class="headerlink" title="d.4). Provide Precomputed Shading"></a>d.4). Provide Precomputed Shading</h3><p><img src="/2022/10/02/Games101_07_09_Shading/ProvidePrecomputedShading.png" alt="ProvidePrecomputedShading"></p>
<ul>
<li>使用Baking的AO等（也可记录其他信息，如SP中的ID、Position、Curvature等）；</li>
</ul>
<h3 id="d-5-3D-Textures-and-Volume-Rendering"><a href="#d-5-3D-Textures-and-Volume-Rendering" class="headerlink" title="d.5). 3D Textures and Volume Rendering"></a>d.5). 3D Textures and Volume Rendering</h3><ul>
<li>体渲染</li>
</ul>
<p><img src="/2022/10/02/Games101_07_09_Shading/3DTexturesAndVolumeRendering.png" alt="3DTexturesAndVolumeRendering"></p>
]]></content>
      <categories>
        <category>Games101</category>
      </categories>
      <tags>
        <tag>Games101</tag>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>Games101-13-16 RayTracing</title>
    <url>/2022/10/03/Games101_13_16_RayTracing/</url>
    <content><![CDATA[<h1 id="Lecture-13-Ray-Tracing"><a href="#Lecture-13-Ray-Tracing" class="headerlink" title="Lecture 13 Ray Tracing"></a>Lecture 13 Ray Tracing</h1><h2 id="a-vs-Rasterization"><a href="#a-vs-Rasterization" class="headerlink" title="a). vs. Rasterization"></a>a). vs. Rasterization</h2><ul>
<li><p>光栅化难以表现<strong>全局（global）</strong>效果，如</p>
<ul>
<li>（软）阴影（Soft shadows）</li>
<li>光线反弹<strong>超过一次</strong>（Glossy reflection）</li>
<li>Indirect illumination（间接光照）</li>
</ul>
<p><img src="/2022/10/03/Games101_13_16_RayTracing/vs.Rsaterization.png" alt="vs.Rsaterization"></p>
</li>
<li><p>Rasterization is fast, but quality is relatively low；</p>
</li>
</ul>
<p><img src="/2022/10/03/Games101_13_16_RayTracing/RayTracing00.png" alt="RayTracing00"></p>
<h2 id="b-Basic-Ray-Tracing-Algorithm"><a href="#b-Basic-Ray-Tracing-Algorithm" class="headerlink" title="b.). Basic Ray-Tracing Algorithm"></a>b.). Basic Ray-Tracing Algorithm</h2><ul>
<li><p><strong>光追中光线的性质：</strong></p>
<ol>
<li>光是沿直线传播的；</li>
<li>光相交时，并不产生干扰；</li>
<li>光从光源出发，传播到眼睛（由于光路可逆，也可是光线从眼睛出发，传播到光源）</li>
</ol>
<p><img src="/2022/10/03/Games101_13_16_RayTracing/EmissionTheory.png" alt="EmissionTheory"></p>
</li>
</ul>
<h3 id="b-1-Ray-Casting"><a href="#b-1-Ray-Casting" class="headerlink" title="b.1). Ray Casting"></a>b.1). Ray Casting</h3><ul>
<li><p><strong>做法：</strong></p>
<ol>
<li>Generate an image by <strong>casting one ray per pixel</strong>;（生成从眼睛出发的光线）</li>
<li>Check for shadows by <strong>sending a ray to the light</strong>;（检查光线投射点是否可传播到光源）</li>
</ol>
</li>
<li><div align="center"> <img src="/2022/10/03/Games101_13_16_RayTracing/CastingRay.png" height="300px" alt="CastingRay"> <img src="/2022/10/03/Games101_13_16_RayTracing/CastingRay01.png" height="300px" alt="CastingRay01"> </div>

<ul>
<li>光线由眼睛出发，可不再使用深度缓存；</li>
<li>投射点到光源发射<strong>Shadow Ray</strong>，查看该点是否在阴影里（是否对光源可见）；</li>
</ul>
</li>
</ul>
<h2 id="c-Whitted-Style-Ray-Tracing-Recursive-递归"><a href="#c-Whitted-Style-Ray-Tracing-Recursive-递归" class="headerlink" title="c). Whitted-Style Ray Tracing(Recursive, 递归)"></a>c). Whitted-Style Ray Tracing(Recursive, 递归)</h2><p><img src="/2022/10/03/Games101_13_16_RayTracing/RecursiveRayTracing.png" alt="RecursiveRayTracing"></p>
<ul>
<li><strong>过程：</strong><ul>
<li><strong>生成眼睛到像素a的光线（Primary ray）</strong>，打到第一个与光线<strong>相交</strong>的点；</li>
<li>形成<strong>反射（镜面反射）</strong>和<strong>折射</strong>的光线（<strong>Secondary rays</strong>，之后的都是Secondary rays）；</li>
<li>对每条光线与object的交点做到光源的光线（<strong>Shadow rays</strong>）；</li>
<li>将所有Shadow rays未被阻挡的光线的着色结果相加，即为像素a的着色结果；</li>
</ul>
</li>
</ul>
<h3 id="c-1-Ray-Surface-Intersection（求交点）"><a href="#c-1-Ray-Surface-Intersection（求交点）" class="headerlink" title="c.1). Ray-Surface Intersection（求交点）"></a>c.1). Ray-Surface Intersection（求交点）</h3><h4 id="c-1-1-与球形相交："><a href="#c-1-1-与球形相交：" class="headerlink" title="c.1.1). 与球形相交："></a>c.1.1). 与球形相交：</h4><div align="center"> <img src="/2022/10/03/Games101_13_16_RayTracing/RayIntersectionWithSphere.png" height="300px" alt="RayIntersectionWithSphere"> <img src="/2022/10/03/Games101_13_16_RayTracing/RayIntersectionWithSphere01.png" height="300px" alt="CastingRay01"> </div>

<ul>
<li><strong>推广：</strong>与隐式表面相交<img src="/2022/10/03/Games101_13_16_RayTracing/RayIntersectionWithImplicitSurface.png" alt="RayIntersectionWithImplicitSurface"></li>
</ul>
<h4 id="c-1-2-与三角形求交："><a href="#c-1-2-与三角形求交：" class="headerlink" title="c.1.2). 与三角形求交："></a>c.1.2). 与三角形求交：</h4><p><img src="/2022/10/03/Games101_13_16_RayTracing/RayIntersectionWithTriangleMesh.png" alt="RayIntersectionWithTriangleMesh"></p>
<ul>
<li><p><strong>几何上：</strong>判断内外；</p>
<ul>
<li>空间内任意一点为起点做一光线，若该光线与object（封闭）交点数为奇数，则该点在object内；若交点数为奇数，则该点在object外；（缠绕数的奇-偶原则）</li>
</ul>
</li>
<li><p><strong>计算过程：</strong></p>
<ul>
<li><div align="center"> <img src="/2022/10/03/Games101_13_16_RayTracing/PlaneEquation.png" height="300px" alt="PlaneEquation"> <img src="/2022/10/03/Games101_13_16_RayTracing/PlaneEquation01.png" height="300px" alt="PlaneEquation01"> </div>
</li>
<li><p>即 $r(t)=o+td,0\leq t &lt; \infty$ 和 $(p-p’)·N=0$ 联立求 $t$；</p>
</li>
<li><p>之后求得点P是否在三角形内；</p>
</li>
</ul>
</li>
<li><p><strong>Möller Trumbore Algorithm</strong></p>
<ul>
<li>按传统求解，求出 $t$ 后，还需要判断 P 点是否在三角形内，较为繁琐，因此提出<strong>Möller Trumbore Algorithm</strong></li>
<li><img src="/2022/10/03/Games101_13_16_RayTracing/MollerTrumboreAlgorithm.png" alt="MollerTrumboreAlgorithm"><ul>
<li>射线$r(t)=O+tD$ ，与由<strong>重心坐标</strong>表示的三角形上的点 $P$ 求解（三个式子，三个未知量，根据克拉默必定有解）；</li>
<li>求得交点后，可通过重心坐标得知该点是否在三角形外；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="c-2-Acclerating-Ray-Surface-Intersection"><a href="#c-2-Acclerating-Ray-Surface-Intersection" class="headerlink" title="c.2). Acclerating Ray-Surface Intersection"></a>c.2). Acclerating Ray-Surface Intersection</h3><ul>
<li><strong>原因：</strong>当需要求得光线最近的交点时，需要遍历场景所有三角面，速度慢，需要加速；</li>
</ul>
<h4 id="c-2-1-Axis-Aligned-Bounding-Box-AABB，轴对齐包围盒"><a href="#c-2-1-Axis-Aligned-Bounding-Box-AABB，轴对齐包围盒" class="headerlink" title="c.2.1). Axis-Aligned Bounding Box(AABB，轴对齐包围盒)"></a>c.2.1). Axis-Aligned Bounding Box(AABB，轴对齐包围盒)</h4><ul>
<li><p><strong>Bounding Volumes</strong></p>
<ul>
<li><strong>思想：</strong><font color="red">当物体不与包围体积相交时，更不可能和物体相交</font>；</li>
</ul>
<p><img src="/2022/10/03/Games101_13_16_RayTracing/BoundingVolumes.png" alt="BoundingVolumes"></p>
</li>
<li><p><strong>Bounding Box（AABB for example）：</strong></p>
<ul>
<li><strong>理解：</strong>盒子是3对对立的面的交集；</li>
<li><strong>Axis-Aligned Bounding Box(AABB)</strong><img src="/2022/10/03/Games101_13_16_RayTracing/AABB_BoundingBox.png" alt="AABB_BoundingBox"><ul>
<li><strong>AABB包围盒的面总在xy/xz/yz平面；</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>光线与AABB求交：</strong></p>
<ul>
<li>2D情况下（3D同理）<img src="/2022/10/03/Games101_13_16_RayTracing/RayIntersection_with_AABB.png" alt="RayIntersection_with_AABB"></li>
<li><strong>思想：</strong><ul>
<li>光线进入Box：<strong>只有</strong>当光线进入<strong>所有</strong>的对立面；</li>
<li>光线出Box：<strong>只要</strong>光线出射<strong>一个</strong>对立面；</li>
<li>对于3D的Box，$t_{enter}=max\{t_{min}\},t_{exit}=min\{t_{max}\}$；</li>
<li>如果 $t_{enter}&lt;t_{exit}$，则光线经过Box；</li>
</ul>
</li>
<li>对于 $t_{enter}$ 和 $t_{exit}$ 正负情况的考虑：<ul>
<li>$t_{exit}&lt;0$：不相交（Box在光线后边）</li>
<li>$t_{exit}&lt;0$ and $t_{enter}&lt;0$：光线起点在盒子里，一定相交</li>
<li>当且仅当 $t_{enter}&lt;t_{exit}\quad\&amp;\&amp;\quad t_{exit}\geq0$，光线与AABB相交；</li>
</ul>
</li>
</ul>
</li>
<li>为什么使用AABB：求交方便；<img src="/2022/10/03/Games101_13_16_RayTracing/AA_reason.png" alt="AA_reason"></li>
</ul>
<h1 id="Lecture-14-amp-15-Ray-Tracing-Acceleration-amp-Radiometry-Light-Transport-amp-Global-Illumination"><a href="#Lecture-14-amp-15-Ray-Tracing-Acceleration-amp-Radiometry-Light-Transport-amp-Global-Illumination" class="headerlink" title="Lecture 14&amp;15 Ray Tracing(Acceleration &amp; Radiometry; Light Transport &amp; Global Illumination)"></a>Lecture 14&amp;15 Ray Tracing(Acceleration &amp; Radiometry; Light Transport &amp; Global Illumination)</h1><h2 id="a-Uniform-Spatial-Partitions（统一空间分区）"><a href="#a-Uniform-Spatial-Partitions（统一空间分区）" class="headerlink" title="a). Uniform Spatial Partitions（统一空间分区）"></a>a). Uniform Spatial Partitions（统一空间分区）</h2><p><img src="/2022/10/03/Games101_13_16_RayTracing/UniformSpatialPartitions00.png" alt="UniformSpatialPartitions00"></p>
<p><img src="/2022/10/03/Games101_13_16_RayTracing/UniformSpatialPartitions.png" alt="UniformSpatialPartitions"></p>
<ul>
<li><p>Heuristic:</p>
<ul>
<li>#cells = C * #objs </li>
<li>C ≈ 27 in 3D</li>
</ul>
</li>
<li><p><strong>缺陷：</strong></p>
<ul>
<li>格子大小相同，浪费空间；</li>
<li>对于空间分布不均匀的场景容易造成“Teapot in a stadium” problem，浪费性能；</li>
</ul>
</li>
</ul>
<h2 id="b-Spatial-Partition"><a href="#b-Spatial-Partition" class="headerlink" title="b). Spatial Partition"></a>b). Spatial Partition</h2><ul>
<li>常见的空间划分的类型：<img src="/2022/10/03/Games101_13_16_RayTracing/SpatialPartitioningEx.png" alt="SpatialPartitioningEx"><ul>
<li>Oct-Tree（3维中是八叉树，2维中是四叉树；$2^n$叉树，n=维度）<ul>
<li>受维度影响；</li>
</ul>
</li>
<li><strong>KD-Tree</strong>；<ul>
<li>每次只划分一次，如果是三维则按x，y，z方向循环划分；</li>
</ul>
</li>
<li>BSP-Tree</li>
</ul>
</li>
</ul>
<h4 id="b-1-KD-Tree"><a href="#b-1-KD-Tree" class="headerlink" title="b.1). KD-Tree"></a>b.1). KD-Tree</h4><p><img src="/2022/10/03/Games101_13_16_RayTracing/KD_Tree_Pre_Processing.png" alt="KD_Tree_Pre_Processing"></p>
<ul>
<li><strong>预处理：</strong>对空间进行划分，对于子空间每次只划分一次（1、2、3划分省略）；<ul>
<li>树节点（Internal node）的数据结构：<ul>
<li><strong>划分轴：</strong>x-, y- , or z-axis;</li>
<li>划分位置：分割平面沿轴的坐标；（？）</li>
<li>子节点；</li>
<li><strong>不存储object</strong>；</li>
</ul>
</li>
<li><strong>叶子节点数据结构：</strong><ul>
<li>object的列表</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2022/10/03/Games101_13_16_RayTracing/KD_Tree_Traversing.png" alt="KD_Tree_Traversing"></p>
<ul>
<li><strong>过程：</strong><ul>
<li>光线和<strong>叶子节点1</strong>（为方便把$1$暂看作叶子节点，尽管个节点应该继续划分，$2,3$同理）相交，判断光线和$1$中储存的object是否相交（无相加，继续）；</li>
<li>……</li>
<li>光线和<strong>叶子节点3</strong>相交，判断光线和$1$中储存的object是否相交，相交，记录$t_{hit}$；</li>
</ul>
</li>
<li><strong>缺点：</strong><ol>
<li>预处理的过程中，物体（三角形）和网格求交难；<ul>
<li>如三角形和Box求交，有可能是一个小Box穿过三角形（被三角形“包裹”）</li>
</ul>
</li>
<li>同一个Object可能储存在多个叶子节点中；</li>
</ol>
</li>
</ul>
<h2 id="c-Bounding-Volume-Hierarchy-BVH"><a href="#c-Bounding-Volume-Hierarchy-BVH" class="headerlink" title="c). Bounding Volume Hierarchy (BVH)"></a>c). Bounding Volume Hierarchy (BVH)</h2><p><img src="/2022/10/03/Games101_13_16_RayTracing/BVH.png" alt="BVH"></p>
<ul>
<li><strong>特征：</strong>先将object分为两组，再重新计算包围盒，使得同一个obejct只会在一个叶子节点中出现；（但会造成Bounding Box空间的冗余）</li>
<li><strong>过程：</strong><ul>
<li>找到包围盒；</li>
<li>递归地将物体的集分为两个子集；</li>
<li><strong>重新计算</strong>子集的包围盒；</li>
<li>满足条件时停止；</li>
<li>储存objects到对应的叶子节点；</li>
</ul>
</li>
<li><strong>划分子节点：</strong><ul>
<li>选择一个维度去划分；</li>
<li>Heuristic #1: 选择最长的轴去划分；</li>
<li>Heuristic #2: 选择中间的object的位置去划分；（快速选择算法）</li>
</ul>
</li>
<li><strong>BVHs的数据结构：</strong><ul>
<li><strong>非叶子节点：</strong><ul>
<li>Bounding box</li>
<li>Children: pointer to child nodes</li>
</ul>
</li>
<li><strong>叶子节点：</strong><ul>
<li>Bounding box</li>
<li>List of objects</li>
</ul>
</li>
<li>Nodes represent subset of primitives in scene</li>
</ul>
</li>
<li><p><strong>BVH Traversal:</strong><img src="/2022/10/03/Games101_13_16_RayTracing/BVH_P_Code.png" alt="BVH_P_Code"></p>
</li>
<li><p><strong><font color="red">空间划分和物体划分:</font></strong><img src="/2022/10/03/Games101_13_16_RayTracing/SpatialvsObjectPartitions.png" alt="SpatialvsObjectPartitions"></p>
</li>
</ul>
<h2 id="d-Radiometry"><a href="#d-Radiometry" class="headerlink" title="d). Radiometry"></a>d). Radiometry</h2><h3 id="d-1-Radiant-Energy-and-Flux-Power"><a href="#d-1-Radiant-Energy-and-Flux-Power" class="headerlink" title="d.1). Radiant Energy and Flux(Power)"></a>d.1). Radiant Energy and Flux(Power)</h3><ul>
<li>Radiant Energy(辐射能量):<ul>
<li>Definition: Radiant energy is the energy of electromagnetic radiation. It is measured in units of joules, and denoted by the symbol: </li>
</ul>
</li>
</ul>
<script type="math/tex; mode=display">
Q[J=Joule]</script><ul>
<li><p>Flux(辐射通量):</p>
<ul>
<li>Definition: Radiant flux (power) is the energy emitted, reflected, transmitted or received, per unit time.</li>
</ul>
<script type="math/tex; mode=display">
\Phi \equiv \frac{\mathrm{d} Q}{\mathrm{~d} t}[\mathrm{~W}=\mathrm{Watt}][\operatorname{lm}=\text {lumen}]</script></li>
</ul>
<ul>
<li>Important Light Measurements of Interest<img src="/2022/10/03/Games101_13_16_RayTracing/RIR.png" alt="RIR"></li>
</ul>
<h3 id="d-2-Radiant-Intensity-辐射强度"><a href="#d-2-Radiant-Intensity-辐射强度" class="headerlink" title="d.2). Radiant Intensity(辐射强度)"></a>d.2). Radiant Intensity(辐射强度)</h3><ul>
<li><strong>定义</strong>：单位立体角上，产生的、反射的、接收的<strong>辐射通量</strong>。符号：<strong>I</strong>；单位：<strong>瓦特/sr、lm/sr、candela、cd</strong>。 <strong>立体角</strong>(solid angle)是有方向的，所以辐射强度是一个方向有关的属性</li>
</ul>
<p><img src="/2022/10/03/Games101_13_16_RayTracing/RadiantIntensity.png" alt="RadiantIntensity"></p>
<h4 id="d-2-1-Solid-angle"><a href="#d-2-1-Solid-angle" class="headerlink" title="d.2.1). Solid angle"></a>d.2.1). Solid angle</h4><ul>
<li><strong>角度（2D）：</strong> 弧长除以半径；<ul>
<li>$\theta={l\over r}$</li>
</ul>
</li>
<li><strong>立体角：</strong>立体角面积除以半径的平方<img src="/2022/10/03/Games101_13_16_RayTracing/SolidAngle.png" alt="SolidAngle"><ul>
<li>$\Omega=\frac{A}{r^{2}}$</li>
<li>球体的立体角为$4\pi$</li>
</ul>
</li>
</ul>
<h4 id="d-2-2-计算过程"><a href="#d-2-2-计算过程" class="headerlink" title="d.2.2). 计算过程"></a>d.2.2). 计算过程</h4><ul>
<li><p>立体角微分：</p>
<ul>
<li><div align="center"> <img src="/2022/10/03/Games101_13_16_RayTracing/SolidAngle_D01.png" height="300px" alt="SolidAngle_D01"> <img src="/2022/10/03/Games101_13_16_RayTracing/SolidAngle_D02.png" height="300px" alt="SolidAngle_D02"> </div>
</li>
<li><p><strong>二重积分</strong>计算，总的立体角 = 球面上无数个单位立体角的加和，即∫∫sinθdθdφ<br>积分限也比较好理解：θ：0 → π，一个半圆弧， φ：0 → 2π，用半圆转一整圈得到球面</p>
</li>
</ul>
</li>
<li><p><strong>通常把ω当做方向向量来理解，这样比较好描述intensity</strong><img src="/2022/10/03/Games101_13_16_RayTracing/W_dirVect.png" alt="W_dirVect" style="zoom: 25%;"></p>
</li>
<li><p><strong>如果点光源向三维空间中均匀的辐射出能量，怎么描述强度？</strong><img src="/2022/10/03/Games101_13_16_RayTracing/Isotropic.png" alt="Isotropic" style="zoom:25%;"></p>
<p><strong>I = Φ / 4π</strong><br><strong>Φ</strong>：点光源单位时间内，向三维空间中辐射出的能量<br><strong>4π</strong>：整个三维空间的总立体角<br>其比值就是单位立体角上的辐射通量</p>
</li>
</ul>
<h4 id="d-2-3-Irradiance-辐照度"><a href="#d-2-3-Irradiance-辐照度" class="headerlink" title="d.2.3). Irradiance(辐照度)"></a>d.2.3). Irradiance(辐照度)</h4><ul>
<li><p><strong>定义：</strong>每单位面积（与光线垂直，Lambert’s Cosine Law）的能量<img src="/2022/10/03/Games101_13_16_RayTracing/Irradiance.png" alt="Irradiance"></p>
</li>
<li><p><strong>Lambert’s Cosine Law</strong><img src="/2022/10/03/Games101_13_16_RayTracing/LambertsCosLaw.png" alt="LambertsCosLaw"></p>
<ul>
<li>e.g. 太阳高度角造成四季变化</li>
</ul>
</li>
<li><img src="/2022/10/03/Games101_13_16_RayTracing/IrradianceFalloff.png" alt="IrradianceFalloff"><ul>
<li>随半径变大，Irradiacne变小，而radiant intensity不变；</li>
</ul>
</li>
</ul>
<h4 id="d-2-4-Radiance-辐亮度"><a href="#d-2-4-Radiance-辐亮度" class="headerlink" title="d.2.4). Radiance(辐亮度)"></a>d.2.4). Radiance(辐亮度)</h4><ul>
<li><p>介绍：</p>
<ul>
<li>Radiance是和光线有关的量；</li>
<li>渲染就是在计算radiance；</li>
</ul>
</li>
<li><p>单位：The <strong>radiance</strong>(luminance) is  the power emitted.  reflected, transmitted or receivedd by a surface, <font color="red">per unit solid angle</font>, <font color="blue">per projected unit area</font>.<img src="/2022/10/03/Games101_13_16_RayTracing/Radiance.png" alt="Radiance"></p>
</li>
<li><p><strong>理解：</strong></p>
<ul>
<li><p>Radiance定义：power <font color="red">per unit solid angle</font>, <font color="blue">per projected unit area</font>.</p>
</li>
<li><p>Irradiance: power per projected unit area</p>
</li>
<li><p>Intensity: power per solid angle </p>
<ul>
<li><p>So:</p>
<p>Radiance: Irradiance per solid angle</p>
<p>​    <strong>- Incident  Radiance</strong></p>
<p>Radiance: Intensity per projected unit area</p>
<p>​    <strong>- Exiting Radiance</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Incident  Radiance: </strong>The <font color="red">irradiance</font> per unit <font color="red">solid angle</font>  <font color="blue">arriving at the surface</font><img src="/2022/10/03/Games101_13_16_RayTracing/IncidentRadiance.png" alt="IncidentRadiance"></p>
<ul>
<li>即 $\omega$ 方向的光线对于 $dA$ 的贡献；</li>
</ul>
</li>
<li><strong>Exiting Radiance: </strong>The <font color="red">intensity</font> per unit <font color="red">projected area</font>  <font color="blue">leaving the surface</font><img src="/2022/10/03/Games101_13_16_RayTracing/ExitingRadiance.png" alt="ExitingRadiance"><ul>
<li>即面积光 $dA$ ，对 $\omega$ 出射方向的贡献；</li>
</ul>
</li>
<li><strong>Irradiance vs. Radiance</strong><img src="/2022/10/03/Games101_13_16_RayTracing/IrradianceVS_radiance.png" alt="IrradianceVS_radiance"><ul>
<li>Irradiance和Radiance的区别在于方向性；</li>
<li>图中，$dA$ 的辐照度 $E(p)$ 为各方向（半圆）对 $dA$ 的贡献。$dA$ 的Radiance $L_i(p,w)$ 为入射方向 $d\omega$ 对 $dA$ 的贡献；</li>
<li>即，Irradiance $E(p)$ 是 radiance $L_i(p,w)$ 对于各个立体角的积分，$L_i(p,\omega)$ 是 $E(p)$ 方向 $\omega$ 的积分；</li>
</ul>
</li>
</ul>
<h2 id="c-BRDF-Bidirectional-Reflectance-Distribution-Function"><a href="#c-BRDF-Bidirectional-Reflectance-Distribution-Function" class="headerlink" title="c). BRDF(Bidirectional Reflectance Distribution Function)"></a>c). BRDF(Bidirectional Reflectance Distribution Function)</h2><p><strong>Ver Games101</strong></p>
<ul>
<li><strong>过程：</strong>光线照射到一点（$p$），该点吸收能量，再辐射出去；</li>
<li><strong>定义：</strong><img src="/2022/10/03/Games101_13_16_RayTracing/BRDF.png" alt="BRDF"><ul>
<li>分母：${\omega}_i$ 方向入射的radiance $L_i(x,{\omega}_i)$，被一点吸收后，辐射往各个方向的Irradiance $E_i({\omega}_i)$；</li>
<li>分子：$E_i({\omega}_i)$，对 ${\omega}_r$ 方向radiance的贡献  $L_r(x,{\omega}_r)$</li>
</ul>
</li>
</ul>
<p><strong>Ver self:</strong></p>
<ul>
<li><strong>定义：</strong>BRDF（双向反射分布函数, bidirectional reflective distribution function）， 是指当一束光从某个方向( $\vec l$ )照射到某个点($p$)上时，在某个方向上( $\vec v$ )的<code>出射辐射通量</code>占总的<code>入射辐射通量</code>的比例</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/21376124">基于物理着色：BRDF - Maple的文章 - 知乎</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/380752802">关于brdf的两件小事 - Dua的文章 - 知乎</a></p>
<ul>
<li><p>可以理解对于某一微小（对立体角）出射光线<strong>ωi</strong>，某一微小入射光线<strong>ωj</strong>对其radiance的贡献；</p>
</li>
<li><p>也可以理解成某一微小入射光线<strong>ωj</strong>，弹射到某一方向的微小立体角<strong>ωi</strong>的光线强度的比值；</p>
</li>
<li><p>由于为了方便测量，不定义为radiance相除（即如果按照我们一开始对入射方向 <img src="https://www.zhihu.com/equation?tex=%5Cvec%7Bl%7D" alt="[公式]"> 微分的方式定义brdf，那么科学家们只需要使用一个极小的光源从 <img src="https://www.zhihu.com/equation?tex=%5Cvec%7Bl%7D" alt="[公式]"> 方向入射到点p，就可以测得brdf的值。但是如果定义为radiance相除，就很难输入一个填充立体角刚好等于1的光源。)正常单位为：</p>
<script type="math/tex; mode=display">
{1\over{sr}}</script></li>
</ul>
<h2 id="d-Rendering-equation"><a href="#d-Rendering-equation" class="headerlink" title="d). Rendering equation"></a>d). Rendering equation</h2><h3 id="d-1-简介"><a href="#d-1-简介" class="headerlink" title="d.1). 简介"></a>d.1). 简介</h3><ul>
<li><strong>The Reflection Equation</strong><img src="/2022/10/03/Games101_13_16_RayTracing/TheReflectionEquation.png" alt="TheReflectionEquation"><ul>
<li>$f_r(p,w_i,w_r)$ 为该点的BRDF</li>
</ul>
</li>
<li><img src="/2022/10/03/Games101_13_16_RayTracing/TheReflectionEquation02.png" alt="TheReflectionEquation02"><ul>
<li><strong>问题：</strong><ol>
<li>incoming radiance 不止来源于光源，也来源于其他反射（递归）；</li>
<li>未考虑自发光情况（加入自发光项，变为渲染方程）</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong><font color="red">The Rendering Equation</font></strong><img src="/2022/10/03/Games101_13_16_RayTracing/RenderingEquation.png" alt="RenderingEquation"><ul>
<li>加入了自发光项 $L_e(p,{\omega}_o)$</li>
<li>考虑多次反射</li>
<li><strong>注意：</strong>该方程假定所有方向都是<strong><font color="red">朝外</font></strong>的；</li>
<li>$H^2$ 和 $\Omega$ 表示半球的积分域；</li>
</ul>
</li>
</ul>
<h3 id="d-2-理解"><a href="#d-2-理解" class="headerlink" title="d.2). 理解"></a>d.2). 理解</h3><ul>
<li><strong>Reflection  Equation:</strong><img src="/2022/10/03/Games101_13_16_RayTracing/ReflectionEquation.png" alt="ReflectionEquation"><ul>
<li>反射的Radiance是各个方向光源对出射方向Radiance贡献的积分；</li>
<li>未考虑光线多次弹射</li>
</ul>
</li>
<li><strong>Rendering Equation:</strong><img src="/2022/10/03/Games101_13_16_RayTracing/RenderingEquation_und.png" alt="RenderingEquation_und"><ul>
<li>考虑多次弹射，即其他物体反射的光线也会对出射方向 ${\omega}_r$ 的Radiance做出贡献；</li>
<li>对于渲染方程，只有 $L_r(x,{\omega}_r)$ 和 $L_r(x’,-{\omega}_i)$ 是未知的；</li>
</ul>
</li>
</ul>
<ul>
<li><strong>简化渲染方程：</strong><ul>
<li>Rendering Equation as Integral Equation<img src="/2022/10/03/Games101_13_16_RayTracing/RenderEq_asIntegralEq.png" alt="RenderEq_asIntegralEq"></li>
<li>Linear Operator Equation<img src="/2022/10/03/Games101_13_16_RayTracing/RE_linearOp.png" alt="RE_linearOp"><ul>
<li>$E$ 环境中自发光对应向量，$L$ Radiance对应的向量；</li>
<li>$K$  反射算子（矩阵）</li>
</ul>
</li>
</ul>
</li>
<li>对于Rendering Equation的线性形式，我们可以用以下式子逼近（类似泰勒展开）：<img src="/2022/10/03/Games101_13_16_RayTracing/Appro_RE_linear.png" alt="Appro_RE_linear"></li>
</ul>
<ul>
<li><h2 id="Rendering-Equation的线性形式对于光追的启示："><a href="#Rendering-Equation的线性形式对于光追的启示：" class="headerlink" title="Rendering Equation的线性形式对于光追的启示："></a><strong>Rendering Equation的线性形式对于光追的启示：</strong><img src="/2022/10/03/Games101_13_16_RayTracing/RayTracing_byREQL.png" alt="RayTracing_byREQL"></h2><ul>
<li>$E$ 为自发光，$KE$ 为 直接光照（即弹射一次），$K^2E$ 为间接光照（弹射两次）</li>
<li>全局光照（Global illumination, GI）：直接光照+间接光照</li>
<li>基础的光栅化只做了自发光和直接光照，即 $E$ 和 $KE$</li>
</ul>
</li>
</ul>
<ul>
<li><p>对比</p>
<div align="center"> <img src="/2022/10/03/Games101_13_16_RayTracing/Comp_DI.png" height="400px" alt="Comp_DI"> <img src="/2022/10/03/Games101_13_16_RayTracing/Comp_GI_2bounce.png" height="400px" alt="Comp_GI_2bounce"> </div>

<div align="center"> <img src="/2022/10/03/Games101_13_16_RayTracing/Comp_GI_4bounce.png" height="400px" alt="Comp_GI_4bounce"> <img src="/2022/10/03/Games101_13_16_RayTracing/Comp_GI_16bounce.png" height="400px" alt="Comp_GI_16bounce"> </div>

<ul>
<li>上方玻璃灯：两次弹射时，光线从摄影机出发不能从玻璃罩中射出，因此其为黑色。而四次弹射时，光线从摄影机出发可以从玻璃罩中射出；</li>
<li>当bounce数目增大时，亮度会趋于一个值，而不会无限增大；</li>
</ul>
</li>
</ul>
<h2 id="e-Probability"><a href="#e-Probability" class="headerlink" title="e). Probability"></a>e). Probability</h2><p><img src="/2022/10/03/Games101_13_16_RayTracing/PDF.png" alt="PDF"></p>
<p><img src="/2022/10/03/Games101_13_16_RayTracing/ExpectedValue.png" alt="ExpectedValue"></p>
<h1 id="Lecture-16-Ray-Tracing-4-Monte-Carlo-Path-Tracing"><a href="#Lecture-16-Ray-Tracing-4-Monte-Carlo-Path-Tracing" class="headerlink" title="Lecture 16 Ray Tracing 4 (Monte Carlo Path Tracing)"></a>Lecture 16 Ray Tracing 4 (Monte Carlo Path Tracing)</h1><h2 id="a-Monte-Carlo-Integration"><a href="#a-Monte-Carlo-Integration" class="headerlink" title="a). Monte Carlo Integration"></a>a). Monte Carlo Integration</h2><ul>
<li><p><strong>使用原因：</strong>一些函数过于复杂，因此对于特定积分域，不求不定积分，只求其积分的结果。（一种<strong>数值</strong>方法）</p>
</li>
<li><p><strong>过程：</strong>对函数的随机样本进行平均来估计函数的数值；</p>
<p><img src="/2022/10/03/Games101_13_16_RayTracing/MonteCarlo00.png" alt="MonteCarlo00"></p>
<ul>
<li><p><img src="/2022/10/03/Games101_13_16_RayTracing/MonteCarlo01.png" alt="MonteCarlo01"></p>
<ul>
<li>除以 $p(x_i)$ 是一种加权，因为对于积分域上样本的采样可能是<strong>不均匀随机采样</strong></li>
</ul>
</li>
<li><p><strong>均匀采样的情况：</strong></p>
<table frame="void">
    <tr>
    <td><center><img src="/2022/10/03/Games101_13_16_RayTracing/MonteCarlo_Uniform.png" alt="MonteCarlo_Uniform" height="200"></center></td>
    <td><center><img src="/2022/10/03/Games101_13_16_RayTracing/MonteCarlo_Uniform02.png" alt="MonteCarlo_Uniform02" height="200"></center></td>
    </tr>
</table>
</li>
<li><p>Some notes：</p>
<ol>
<li>采样越多，方差越小</li>
<li>如在$x$上积分，要采样$x$</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="b-Paht-Tracing"><a href="#b-Paht-Tracing" class="headerlink" title="b). Paht Tracing"></a>b). Paht Tracing</h2><h3 id="b-1-vs-Whitted-Style-Ray-Tracing"><a href="#b-1-vs-Whitted-Style-Ray-Tracing" class="headerlink" title="b.1). vs Whitted-Style Ray Tracing"></a>b.1). vs Whitted-Style Ray Tracing</h3><ul>
<li><p><strong>Whitted-Style Ray Tracing</strong></p>
<ul>
<li><p>遇到光滑物体会只会 反射/折射（择一进行）</p>
<ul>
<li><p>无法表现Glossy reflection</p>
<p><img src="/2022/10/03/Games101_13_16_RayTracing/WS_Glossy.png" alt="WS_Glossy"></p>
</li>
</ul>
</li>
<li><p>遇到漫反射物体停止弹射</p>
<ul>
<li>没有Color Blooding(eg.direct illumination)，考虑不到漫反射物体之间的光线传播</li>
</ul>
<p><img src="/2022/10/03/Games101_13_16_RayTracing/WS_Diffuse.png" alt="WS_Diffuse"></p>
</li>
</ul>
</li>
<li><p>But the <strong>rendering equation</strong> is correct</p>
<script type="math/tex; mode=display">
L_{o}\left(p, \omega_{o}\right)=L_{e}\left(p, \omega_{o}\right)+\int_{\Omega^{+}} L_{i}\left(p, \omega_{i}\right) f_{r}\left(p, \omega_{i}, \omega_{o}\right)\left(n \cdot \omega_{i}\right) \mathrm{d} \omega_{i}</script><ul>
<li>需要做的：<ol>
<li>解决半球域的定积分<ul>
<li>蒙特卡洛积分</li>
</ul>
</li>
<li>递归</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="b-2-A-Simple-Monte-Carlo-Solution-Direct-illumination"><a href="#b-2-A-Simple-Monte-Carlo-Solution-Direct-illumination" class="headerlink" title="b.2). A Simple Monte Carlo Solution(Direct illumination)"></a>b.2). A Simple Monte Carlo Solution(Direct illumination)</h3><ul>
<li><p>渲染一个<strong>Pixel（Point）</strong>，<em>当前</em> 之考虑<strong>直接光照</strong></p>
<p><img src="/2022/10/03/Games101_13_16_RayTracing/MC_Soulution_DI.png" alt="MC_Soulution_DI"></p>
<ul>
<li><p>当 $\omega_i$ 与light相交时，计算该方向的radiance；与Box相交时，则该方向的radiance=0；</p>
<table frame="void">
    <tr>
    <td><center><img src="/2022/10/03/Games101_13_16_RayTracing/MC_Soulution_DI_Fx.png" alt="MC_Soulution_DI_Fx" height="200"></center></td>
    <td><center><img src="/2022/10/03/Games101_13_16_RayTracing/MC_Soulution_DI_Fx_G.png" alt="MC_Soulution_DI_Fx_G" height="200"></center></td>
    </tr>
</table>
</li>
</ul>
</li>
<li><p><strong>P-Code</strong></p>
<p><img src="/2022/10/03/Games101_13_16_RayTracing/MC_Pcode.png" alt="MC_Pcode"></p>
</li>
</ul>
<h3 id="b-3-Global-illumination-加入递归"><a href="#b-3-Global-illumination-加入递归" class="headerlink" title="b.3). Global illumination(加入递归)"></a>b.3). Global illumination(加入递归)</h3><h4 id="b-3-1-GI-and-problems"><a href="#b-3-1-GI-and-problems" class="headerlink" title="b.3.1). GI and problems"></a>b.3.1). GI and problems</h4><ul>
<li><p><strong>P-Code</strong></p>
<p><img src="/2022/10/03/Games101_13_16_RayTracing/MC_GI.png" alt="MC_GI"></p>
<ul>
<li><p><strong>Problem1:</strong> Explosion of #rays as #bounces go up</p>
<p><img src="/2022/10/03/Games101_13_16_RayTracing/MC_GI_P1.png" alt="MC_GI_P1"></p>
<ul>
<li><p><strong>解决方法：</strong> <font color="red">N=1</font>（N=1即Path Tracing，Distributed Ray Tracing if N != 1）</p>
<ul>
<li><p>N=1会造成较多的Noise，因此采用Subpixel，即每个像素内多次采样（Samples per pixel, SPP）</p>
<p><img src="/2022/10/03/Games101_13_16_RayTracing/MC_GI_SPP.png" alt="MC_GI_SPP"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Problem2:</strong> 递归不会停止</p>
<ul>
<li><p>现实世界中，光线的弹射次数是无限的</p>
</li>
<li><p>简单地，<strong>减少弹射次数 == 减少能量</strong>；</p>
</li>
<li><p><strong>解决方法：</strong> Russian Roulette(RR, 俄罗斯轮盘赌)</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="b-3-2-Russian-Roulette-RR-俄罗斯轮盘赌"><a href="#b-3-2-Russian-Roulette-RR-俄罗斯轮盘赌" class="headerlink" title="b.3.2). Russian Roulette(RR, 俄罗斯轮盘赌)"></a>b.3.2). Russian Roulette(RR, 俄罗斯轮盘赌)</h4><p><img src="/2022/10/03/Games101_13_16_RayTracing/RR.png" alt="RR"></p>
<ul>
<li><p>先前一点的着色结果是 $L_o$，引入RR后</p>
<ul>
<li>With probability $P$, shoot a ray and return the <strong>shading result divided by P: <font color="red">Lo / P</font></strong></li>
<li>With probability $1-P$, don’t shoot a ray and you’ll get <strong><font color="red">0</font></strong></li>
</ul>
</li>
<li><p>由此可得出数学期望 $E=P \cdot\left(\frac{L_{o}}{p}\right)+(1-P) \cdot 0=L_{o}$</p>
<p><img src="/2022/10/03/Games101_13_16_RayTracing/RR_Pcode.png" alt="RR_Pcode"></p>
</li>
</ul>
<h4 id="b-3-3-优化"><a href="#b-3-3-优化" class="headerlink" title="b.3.3). 优化"></a>b.3.3). 优化</h4><ul>
<li><p>计算直接光照时，如对点P向各个方向均匀采样，当光源小时，直接光照的贡献会小，造成较多的噪声；</p>
<p><img src="/2022/10/03/Games101_13_16_RayTracing/MC_Wasted.png" alt="MC_Wasted"></p>
</li>
<li><p><strong>解决方法：</strong> 换元，使渲染方程对光源面积 $A$ 进行积分，<strong>pdf = 1/A</strong></p>
<p><img src="/2022/10/03/Games101_13_16_RayTracing/MC_dA01.png" alt="MC_dA01"></p>
<script type="math/tex; mode=display">
d \omega=\frac{d A \cos \theta^{\prime}}{\left\|x^{\prime}-x\right\|^{2}}

(Note:  \theta^{\prime} , not  \theta  )</script><ul>
<li>立体角可以看前面辐射度量学的部分</li>
</ul>
</li>
<li><p><img src="/2022/10/03/Games101_13_16_RayTracing/MC_dA02.png" alt="MC_dA02"></p>
</li>
<li><p><strong>过程：</strong>（直接光照，间接光照分开计算）</p>
<ol>
<li><font color="blue">light source</font> (<strong>direct</strong>, no need to have RR)</li>
<li><font color="orange">other reflectors</font> (<strong>indirect</strong>, ues RR)</li>
</ol>
</li>
<li><p><strong>P-Code</strong>（未考虑遮挡）</p>
<p><img src="/2022/10/03/Games101_13_16_RayTracing/MC_优化_Pcode.png" alt="MC_优化_Pcode"></p>
</li>
<li><p><strong>遮挡</strong><img src="/2022/10/03/Games101_13_16_RayTracing/MC_优化_Pcode02.png" alt="MC_优化_Pcode02"></p>
</li>
</ul>
<hr>
<p>附上上学期做的光追（借鉴smallpt）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* 采用Monte Carlo Path Tracing</span><br><span class="line">* 漫反射采用的是Lambert</span><br><span class="line">* 定义了三角面片和球体，其中三角面片可多片合成一个对象，</span><br><span class="line">* 与三角面片求交则使用克拉默法则，而基于此做条件上的修改就可构建平行四边形，因此将平行四边形也归入三角面片</span><br><span class="line">* 用平行四边形代替两个三角面片在适用且数量较多的情况下可显著提高运算效率</span><br><span class="line">* 球体求交运算量小于三角面片，因此墙壁通过大半径的球体构建</span><br><span class="line">*</span><br><span class="line">* 由于想要表现出计算过程，许多数学运算未化简，运算效率不高</span><br><span class="line">* 由于未使用BVH等方式约束，三角面片较为影响性能</span><br><span class="line">* 目前场景除墙面外中有两个球体（镜面反射以及玻璃），以及一个立方体，通过6个三角面片（平行四边形）构成</span><br><span class="line">*</span><br><span class="line">* 由于为了提高运算效率，本程序中使用的蒙特卡洛采样方向约束在朝向其他对象的方向（射线在必定与其他对象相交的范围内随机），</span><br><span class="line">* 但三角面片的约束范围较复杂，因此不支持将三角面片定义为光源</span><br><span class="line">*</span><br><span class="line">* 虽会增加噪声，为了运算效率，除了最大迭代次数，还引入经处理可使radiance的数学期望与原值相同的Russian Roulette，开始RR的次数为最大迭代次数除以2</span><br><span class="line">* </span><br><span class="line">* 由于运算量大，采样默认设置为1，如想提高运行效率可删除掉三角面片</span><br><span class="line">* </span><br><span class="line">* 绘制通过glut</span><br><span class="line">* 程序输出为ppm格式图片</span><br><span class="line">**/</span><br><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;gl/glut.h&gt;</span><br><span class="line"></span><br><span class="line">#define DEPTH_MAX 10	//最大迭代次数</span><br><span class="line">#define WIDTH 512</span><br><span class="line">#define HIGHT 385</span><br><span class="line"></span><br><span class="line">double M_PI = 3.1415926535;</span><br><span class="line"></span><br><span class="line">double erand48(unsigned short xsubi[3]) &#123;</span><br><span class="line">	return (double)rand() / (double)RAND_MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Vec &#123;</span><br><span class="line">	double x, y, z;</span><br><span class="line">	Vec(double _x = 0, double _y = 0, double _z = 0) &#123; x = _x; y = _y; z = _z; &#125;;</span><br><span class="line"></span><br><span class="line">	Vec operator+(const Vec&amp; b) const &#123; return Vec(x + b.x, y + b.y, z + b.z); &#125;;	//加</span><br><span class="line"></span><br><span class="line">	Vec operator-(const Vec&amp; b) const &#123; return Vec(x - b.x, y - b.y, z - b.z); &#125;	//减</span><br><span class="line"></span><br><span class="line">	Vec operator*(double b) const &#123; return Vec(x * b, y * b, z * b); &#125;;	//数乘</span><br><span class="line"></span><br><span class="line">	Vec mult(const Vec&amp; b) const &#123; return Vec(x * b.x, y * b.y, z * b.z); &#125;	//数乘</span><br><span class="line"></span><br><span class="line">	Vec&amp; norm() &#123; return *this = *this * (1 / sqrt(x * x + y * y + z * z)); &#125;	//单位向量</span><br><span class="line"></span><br><span class="line">	double dot(const Vec&amp; b) const &#123; return x * b.x + y * b.y + z * b.z; &#125;	//点乘</span><br><span class="line"></span><br><span class="line">	Vec cross(const Vec&amp; b) const &#123; return Vec(y * b.z - z * b.y, z * b.x - x * b.z, x * b.y - y * b.x); &#125;	//叉乘</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Ray &#123;</span><br><span class="line">	Vec o, d;</span><br><span class="line">	Ray(Vec _o, Vec _d) : o(_o), d(_d) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">enum Refl_t &#123;	//反射类型</span><br><span class="line">	DIFF,</span><br><span class="line">	SPEC,</span><br><span class="line">	REFR</span><br><span class="line">&#125;;</span><br><span class="line">struct MeshTriangle &#123;	// 三角面片</span><br><span class="line">	const Vec* verts;	// 顶点</span><br><span class="line">	const int* vertsIndex;	//顶点排序</span><br><span class="line">	const int numTris;	// 三角形数量</span><br><span class="line">	Vec* vertices;</span><br><span class="line">	Vec e, c;	// emission, color</span><br><span class="line">	Refl_t refl;</span><br><span class="line">	int isTriangle;</span><br><span class="line"></span><br><span class="line">	//顶点， 顶点列表（决定构建顺序以及法线正负）， 三角面片数量， emission, color， 材质， 是否是三角形（或平行四边形）</span><br><span class="line">	MeshTriangle(const Vec* _verts, const int* _vertsIndex, const int _numTris, Vec _e, Vec _c, Refl_t _refl, int _isTriangle = 1) :</span><br><span class="line">		verts(_verts), vertsIndex(_vertsIndex), numTris(_numTris), e(_e), c(_c), refl(_refl), isTriangle(_isTriangle)</span><br><span class="line">	&#123;</span><br><span class="line">		vertices = new Vec[3 * numTris];</span><br><span class="line">		for (int i = 0; i &lt; numTris; i++) &#123;</span><br><span class="line">			for (int n = 0; n &lt; 3; n++) &#123;</span><br><span class="line">				vertices[3 * i + n] = verts[vertsIndex[3 * i + n]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void move(int x, int y, int z) &#123;	// 方便调试</span><br><span class="line">		for (int i = 0; i &lt; 3 * numTris; i++) &#123;</span><br><span class="line">			vertices[i] = vertices[i] + Vec(x, y, z);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	double intersect(const Ray&amp; r, Vec&amp; n) const &#123;	// n返回法线</span><br><span class="line">		double tnear = 1e20;</span><br><span class="line">		double tnear_out;</span><br><span class="line">		//std::cout &lt;&lt; numTris &lt;&lt; std::endl;	//</span><br><span class="line">		Vec temp_normal;</span><br><span class="line">		double temp = 1e20;</span><br><span class="line">		bool flag = false;</span><br><span class="line">		for (int i = 0; i &lt; numTris; i++) &#123;</span><br><span class="line">			Vec&amp; v0 = vertices[3 * i];</span><br><span class="line">			Vec&amp; v1 = vertices[3 * i + 1];</span><br><span class="line">			Vec&amp; v2 = vertices[3 * i + 2];</span><br><span class="line">			/*std::cout &lt;&lt; &quot;x:&quot; &lt;&lt; v0.x &lt;&lt; &quot;y:&quot; &lt;&lt; v0.y &lt;&lt; &quot;, z:&quot; &lt;&lt; v0.z &lt;&lt; std::endl;</span><br><span class="line">			std::cout &lt;&lt; &quot;x:&quot; &lt;&lt; v1.x &lt;&lt; &quot;y:&quot; &lt;&lt; v1.y &lt;&lt; &quot;, z:&quot; &lt;&lt; v1.z &lt;&lt; std::endl;</span><br><span class="line">			std::cout &lt;&lt; &quot;x:&quot; &lt;&lt; v2.x &lt;&lt; &quot;y:&quot; &lt;&lt; v2.y &lt;&lt; &quot;, z:&quot; &lt;&lt; v2.z &lt;&lt; std::endl;*/</span><br><span class="line">			Vec E1 = v1 - v0;</span><br><span class="line">			Vec E2 = v2 - v0;</span><br><span class="line"></span><br><span class="line">			n = E1.cross(E2).norm();	//三角形法线</span><br><span class="line">			Vec S = r.o - v0;</span><br><span class="line">			Vec S1 = (r.d).cross(E2);</span><br><span class="line">			Vec S2 = S.cross(E1);</span><br><span class="line">			//tnear为时间 沿着三角形方向 t的为正</span><br><span class="line">			//u,v 为重心坐标前的参数 都得为非负的还得小于1</span><br><span class="line">			double S1E1 = S1.dot(E1);</span><br><span class="line"></span><br><span class="line">			tnear = 1.0f / S1E1 * S2.dot(E2);</span><br><span class="line">			double u = 1.0f / S1E1 * S1.dot(S);</span><br><span class="line">			double v = 1.0f / S1E1 * S2.dot(r.d);</span><br><span class="line">			double k = 1 - u - v;</span><br><span class="line"></span><br><span class="line">			bool judge;</span><br><span class="line">			if (isTriangle) &#123;</span><br><span class="line">				judge = tnear &gt; 0 &amp;&amp; v &gt;= 0 &amp;&amp; v &lt;= 1 &amp;&amp; u &gt;= 0 &amp;&amp; u &lt;= 1 &amp;&amp; k &gt;= 0;</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				judge = tnear &gt; 0 &amp;&amp; v &gt;= 0 &amp;&amp; v &lt;= 1 &amp;&amp; u &gt;= 0 &amp;&amp; u &lt;= 1;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			if (judge) &#123;	//不加k &gt;= 0 可构建平行四边形</span><br><span class="line">				if (!flag) &#123;</span><br><span class="line">					tnear_out = tnear;</span><br><span class="line">					temp_normal = n;</span><br><span class="line">					flag = true;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				if (tnear &lt; tnear_out) &#123;</span><br><span class="line">					tnear_out = tnear;</span><br><span class="line">					temp_normal = n;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (flag) &#123;</span><br><span class="line">			n = temp_normal;</span><br><span class="line"></span><br><span class="line">			//std::cout &lt;&lt; tnear_out &lt;&lt; std::endl;</span><br><span class="line">			return (tnear_out &lt; 1e20 &amp;&amp; tnear_out &gt; 0) ? tnear_out : 0;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~MeshTriangle() &#123;</span><br><span class="line">		delete[] vertices;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Sphere &#123;</span><br><span class="line">	double rad;	// radius</span><br><span class="line">	Vec p, e, c;	// position, emission, color</span><br><span class="line">	Refl_t refl;</span><br><span class="line"></span><br><span class="line">	Sphere(double _rad, Vec _p, Vec _e, Vec _c, Refl_t _refl) :</span><br><span class="line">		rad(_rad), p(_p), e(_e), c(_c), refl(_refl) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	double intersect(const Ray&amp; r) const &#123;</span><br><span class="line">		Vec op = p - r.o;</span><br><span class="line">		double t, eps = 1e-4;</span><br><span class="line">		double b_12 = op.dot(r.d);		// -b / 2</span><br><span class="line">		double det_14 = b_12 * b_12 - op.dot(op) + rad * rad;	// det / 4</span><br><span class="line">		double det_14_sqrt = sqrt(det_14);</span><br><span class="line">		return (t = b_12 - det_14_sqrt) &gt; eps ? t : ((t = b_12 + det_14_sqrt) &gt; eps ? t : 0);</span><br><span class="line">		//if (det_14 &lt; 0) &#123;</span><br><span class="line">		//	return 0;</span><br><span class="line">		//&#125;</span><br><span class="line">		//else &#123;</span><br><span class="line">		//	t = b_12 - det_14_sqrt;</span><br><span class="line">		//	if (t &gt; eps) return t;	//考虑到浮点数的缺陷</span><br><span class="line"></span><br><span class="line">		//	t = b_12 + det_14_sqrt;</span><br><span class="line">		//	if (t &gt; eps) return t;</span><br><span class="line"></span><br><span class="line">		//	return 0;	//交点为反向延长线，不考虑</span><br><span class="line">		//&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Sphere spheres[] = &#123;//Scene: radius, position, emission, color, material</span><br><span class="line">	Sphere(1e5, Vec(1e5 + 1,40.8,81.6),  Vec(),Vec(.75,.25,.25),DIFF),//Left</span><br><span class="line">	Sphere(1e5, Vec(-1e5 + 99,40.8,81.6),Vec(),Vec(.25,.25,.75),DIFF),//Rght</span><br><span class="line">	Sphere(1e5, Vec(50,40.8, 1e5),       Vec(),Vec(.75,.75,.75),DIFF),//Back</span><br><span class="line">	Sphere(1e5, Vec(50,40.8,-1e5 + 170), Vec(),Vec(.25,.25,.25), DIFF),//Frnt</span><br><span class="line">	Sphere(1e5, Vec(50, 1e5, 81.6),      Vec(),Vec(.75,.75,.75),DIFF),//Botm</span><br><span class="line">	Sphere(1e5, Vec(50,-1e5 + 81.6,81.6),Vec(),Vec(.75,.75,.75),DIFF),//Top</span><br><span class="line">	Sphere(12,Vec(27,12.5,47),         Vec(),Vec(1,1,1) * .999, SPEC),//Mirr</span><br><span class="line">	Sphere(16.5,Vec(73,16.5,78),         Vec(),Vec(1,1,1) * .999, REFR),//Glas</span><br><span class="line">	Sphere(1.5, Vec(50,81.6 - 16.5,81.6),Vec(4,4,4) * 100,  Vec(), DIFF)  //Lite</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Vec verts[8] = &#123;	//vertices</span><br><span class="line">	Vec(26, 0, 95),</span><br><span class="line">	Vec(41, 0, 90),</span><br><span class="line">	Vec(31, 0, 110),</span><br><span class="line">	Vec(46, 0, 105),</span><br><span class="line">	Vec(26, 40, 95),</span><br><span class="line">	Vec(41, 40, 90),</span><br><span class="line">	Vec(31, 40, 110),</span><br><span class="line">	Vec(46, 40, 105),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int vertsIndex[18] = &#123; 0, 4, 1,		// 顺序影响法线方向</span><br><span class="line">					1, 5, 3,</span><br><span class="line">					3, 7, 2,</span><br><span class="line">					2, 6, 0,</span><br><span class="line">					6, 7, 4,</span><br><span class="line">					2, 0, 3,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//int vertsIndex[36] = &#123; 0, 4, 1,		// 顺序影响法线方向</span><br><span class="line">//					1, 4, 5,</span><br><span class="line">//					1, 5, 7,</span><br><span class="line">//					1, 7, 3,</span><br><span class="line">//					3, 7, 6,</span><br><span class="line">//					3, 6, 2,</span><br><span class="line">//					2, 6, 0,</span><br><span class="line">//					0, 6, 4,</span><br><span class="line">//					6, 7, 4,</span><br><span class="line">//					7, 5, 4,</span><br><span class="line">//					2, 0, 3,</span><br><span class="line">//					3, 0, 1,</span><br><span class="line">//					&#125;;</span><br><span class="line"></span><br><span class="line">MeshTriangle meshTriangles[] = &#123;</span><br><span class="line">	MeshTriangle(verts, vertsIndex, 6, Vec(), Vec(.25, .75, .25), DIFF, 0),</span><br><span class="line">&#125;;	//vertices, vertsIndex, numTris, emission, color, material</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int numSphere = sizeof(spheres) / sizeof(Sphere);</span><br><span class="line">int numMeshTriangle = sizeof(meshTriangles) / sizeof(MeshTriangle);</span><br><span class="line"></span><br><span class="line">inline double clamp01(double x) &#123;	//截断到01</span><br><span class="line">	return x &lt; 0 ? 0 : (x &gt; 1 ? 1 : x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline double gamma(double x, float n = 2.2) &#123;</span><br><span class="line">	return pow(clamp01(x), 1 / n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline int toInt255(double x) &#123;	//gamma取2.2, 四舍五入</span><br><span class="line">	return int(gamma(x) * 255 + .5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void UpdateProgress(float progress)	//进度提醒</span><br><span class="line">&#123;</span><br><span class="line">	int barWidth = 70;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; &quot;[&quot;;</span><br><span class="line">	int pos = barWidth * progress;</span><br><span class="line">	for (int i = 0; i &lt; barWidth; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		if (i &lt; pos)</span><br><span class="line">			std::cout &lt;&lt; &quot;=&quot;;</span><br><span class="line">		else if (i == pos)</span><br><span class="line">			std::cout &lt;&lt; &quot;&gt;&quot;;</span><br><span class="line">		else</span><br><span class="line">			std::cout &lt;&lt; &quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//三位小数</span><br><span class="line">	std::cout &lt;&lt; &quot;] &quot; &lt;&lt; std::setiosflags(std::ios::fixed) &lt;&lt; std::setiosflags(std::ios::right) &lt;&lt; std::setprecision(3) &lt;&lt; float(progress * 100.0) &lt;&lt; &quot; %\r&quot;;</span><br><span class="line">	std::cout.flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline bool intersect(const Ray&amp; r, double&amp; t, int&amp; id, Vec&amp; normal) &#123;	//t最短的相交, n 返回法线</span><br><span class="line">	double n = sizeof(spheres) / sizeof(Sphere) + numMeshTriangle;</span><br><span class="line">	double d;</span><br><span class="line">	double inf = t = 1e20;</span><br><span class="line">	for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">		//std::cout &lt;&lt; i &lt;&lt; std::endl;	//</span><br><span class="line">		if (i &lt; numSphere) &#123;</span><br><span class="line">			if ((d = spheres[i].intersect(r)) &amp;&amp; d &lt; t) &#123;	// 注意：不自交（真坑啊。。。）</span><br><span class="line">				t = d;</span><br><span class="line">				id = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			d = meshTriangles[i - numSphere].intersect(r, normal);</span><br><span class="line">			if (d &amp;&amp; d &lt; t) &#123;</span><br><span class="line">				//std::cout &lt;&lt; d &lt;&lt; std::endl;</span><br><span class="line">				t = d;</span><br><span class="line">				id = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return t &lt; inf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Xi:随机种子	E：whether to include emissive color</span><br><span class="line">Vec radiance(const Ray&amp; r, int depth, unsigned short* Xi, int E = 1) &#123;</span><br><span class="line">	double t;	//与交点距离</span><br><span class="line">	int id = 0;</span><br><span class="line">	Vec temp_n;</span><br><span class="line">	if (!intersect(r, t, id, temp_n)) &#123;		//id &gt;= numSphere说明是三角面片</span><br><span class="line">		return Vec();	//miss</span><br><span class="line">	&#125;</span><br><span class="line">	//std::cout &lt;&lt; id &lt;&lt; std::endl;	//</span><br><span class="line"></span><br><span class="line">	Vec x = r.o + r.d * t;// Ray hit point</span><br><span class="line">	Vec n;	//normal(射线经过obj内部后,n为负数)</span><br><span class="line">	Vec f;</span><br><span class="line">	Refl_t obj_refl;</span><br><span class="line">	Vec obj_e;</span><br><span class="line">	if (id &lt; numSphere) &#123;</span><br><span class="line">		const Sphere&amp; obj = spheres[id];</span><br><span class="line">		n = (x - obj.p).norm();</span><br><span class="line">		f = obj.c;</span><br><span class="line">		obj_refl = obj.refl;</span><br><span class="line">		obj_e = obj.e;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		//std::cout &lt;&lt; id &lt;&lt; std::endl;</span><br><span class="line">		//if (x.x == 36) std::cout &lt;&lt; &quot;x:&quot; &lt;&lt; x.x &lt;&lt; &quot;y:&quot; &lt;&lt; x.y &lt;&lt; &quot;, z:&quot; &lt;&lt; x.z &lt;&lt; std::endl;</span><br><span class="line">		const MeshTriangle&amp; obj = meshTriangles[id - numSphere];</span><br><span class="line">		n = temp_n.norm();</span><br><span class="line">		f = obj.c;</span><br><span class="line">		obj_refl = obj.refl;</span><br><span class="line">		obj_e = obj.e;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (depth &gt; DEPTH_MAX) &#123;</span><br><span class="line"></span><br><span class="line">		return Vec();</span><br><span class="line">	&#125;</span><br><span class="line">	//Vec n = (x - obj.p).norm();	// sphere normal(射线经过obj内部后,n为负数)</span><br><span class="line">	Vec n_real = n.dot(r.d) &lt; 0 ? n : n * -1;	//sphere normal</span><br><span class="line">	//std::cout &lt;&lt; &quot;x:&quot; &lt;&lt; f.x &lt;&lt; &quot;y:&quot; &lt;&lt; f.y &lt;&lt; &quot;, z:&quot; &lt;&lt; f.z &lt;&lt; std::endl;	//</span><br><span class="line"></span><br><span class="line">	//用rgb最大值作为Russian Roulette不终止的概率p</span><br><span class="line">	//RR适用因为p * Li * (1/p) + 0 * (1-p) = Li，即数学期望等于Li</span><br><span class="line">	double p = f.x &gt; f.y &amp;&amp; f.x &gt; f.z ? f.x : f.y &gt; f.z ? f.y : f.z;</span><br><span class="line"></span><br><span class="line">	if (++depth &gt; int(DEPTH_MAX / 2) || !p) if (erand48(Xi) &lt; p) f = f * (1.0 / p); else return obj_e * E;</span><br><span class="line"></span><br><span class="line">	//std::cout &lt;&lt; &quot;miss&quot; &lt;&lt; std::endl;</span><br><span class="line">	if (obj_refl == DIFF) &#123;</span><br><span class="line">		//std::cout &lt;&lt; &quot;DIFF&quot; &lt;&lt; std::endl;	//</span><br><span class="line">		//采用Lambert，出射方向任意，以极坐标的方式构建随机弹射光线方向</span><br><span class="line">		double r1 = 2 * M_PI * erand48(Xi);</span><br><span class="line">		double r2 = erand48(Xi);</span><br><span class="line">		double r2_sqrt = sqrt(r2);</span><br><span class="line"></span><br><span class="line">		//标准正交系</span><br><span class="line">		Vec w = n_real;</span><br><span class="line">		Vec u = ((fabs(w.x) &gt; 0.1 ? Vec(0, 1) : Vec(1)).cross(w)).norm();</span><br><span class="line">		Vec v = w.cross(u);</span><br><span class="line">		Vec d = (u * cos(r1) * r2_sqrt + v * sin(r1) * r2_sqrt + w * sqrt(1 - r2)).norm();	//Ray direction, 即path tracing， N=1的那条射线</span><br><span class="line"></span><br><span class="line">		Vec e;</span><br><span class="line">		for (int i = 0; i &lt; numSphere; i++) &#123;</span><br><span class="line">			const Sphere&amp; s = spheres[i];</span><br><span class="line">			if ((s.e.x &lt;= 0 &amp;&amp; s.e.y &lt;= 0 &amp;&amp; s.e.z &lt;= 0) || i &gt;= numSphere) continue;	//skip no radiance</span><br><span class="line"></span><br><span class="line">			Vec sw = s.p - x, su = ((fabs(sw.x) &gt; 0.1 ? Vec(0, 1) : Vec(1)).cross(sw)).norm(), sv = sw.cross(su);</span><br><span class="line"></span><br><span class="line">			//x发出射向id=i的范围内随机方向的采样射线</span><br><span class="line">			double cos_a_max = sqrt(1 - s.rad * s.rad / (x - s.p).dot(x - s.p));</span><br><span class="line">			double eps1 = erand48(Xi), eps2 = erand48(Xi);</span><br><span class="line">			//double cos_a = 1 - eps1*(1. - cos_a_max);</span><br><span class="line">			double cos_a = 1 - eps1 + eps1 * cos_a_max;</span><br><span class="line">			double sin_a = sqrt(1 - cos_a * cos_a);</span><br><span class="line">			double phi = 2 * M_PI * eps2;</span><br><span class="line">			Vec l = su * cos(phi) * sin_a + sv * sin(phi) * sin_a + sw * cos_a;</span><br><span class="line">			l.norm();</span><br><span class="line"></span><br><span class="line">			// Note: </span><br><span class="line">			// 根据Monte Carlo Integration得到相应形式的渲染方程(反射率方程)</span><br><span class="line">			// Lo(p,wo) = (1/N)*∑(i~n) &#123;(Li(p,wi)*fr(p,wi,wo)*(n*wi)) / pdf&#125;</span><br><span class="line">			// Lo:入射radiance, p:单位半球球心, wo:入射方向（微小立体角）</span><br><span class="line">			// N:取样数（光线数）, Li wi略</span><br><span class="line">			// fr:BRDF, n:法线方向</span><br><span class="line">			// pdf: 分布函数</span><br><span class="line">			// 由于采用的是path tracing N取1, Lo(p,wo) = (Li(p,wi)*fr(p,wi,wo)*(n*wi)) / pdf</span><br><span class="line">			// 当采用Lambert漫反射的BRDF可推导出为1/pi</span><br><span class="line">			// 对半球均匀采样时，pdf=1/单位半圆面积，但射线的方向是在于法线的夹角最大是a_max, 采样的区域被限定</span><br><span class="line">			// 球形对角度A(法线方向与某一点的夹角)积分， 得S = ſ 2 * pi * r*r sinA dA = abs(2 * pi * r * r * cosA), r=1</span><br><span class="line">			// 易得pdf = 1 / 球部分表面积 = 1 / (2 * pi * r * r(1-cos_a_max)) = 1 / (2 * pi * (1-cos_a_max))</span><br><span class="line">			// Lo(p,wo) = (Li(p,wi)*fr(p,wi,wo)*(n*wi)) / pdf = Li(p,wi) * (1 / pi) * cos_a * (2 * pi * (1 - cos_a_max))</span><br><span class="line">			Vec temp1;</span><br><span class="line">			if (intersect(Ray(x, l), t, id, temp1) &amp;&amp; id == i) &#123;</span><br><span class="line">				double omega = 2 * M_PI * (1 - cos_a_max);</span><br><span class="line">				e = e + f.mult(s.e * l.dot(n_real) * omega) * (1 / M_PI);</span><br><span class="line">				//std::cout &lt;&lt; e.x &lt;&lt; std::endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//std::cout &lt;&lt; f.x &lt;&lt; std::endl;</span><br><span class="line">		return obj_e * E + e + f.mult(radiance(Ray(x, d), depth, Xi, 0));	//TEST:E暂时设置为0</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	else if (obj_refl == SPEC) &#123;</span><br><span class="line">		//std::cout &lt;&lt; &quot;SPEC&quot; &lt;&lt; std::endl;	//</span><br><span class="line">		return obj_e + f.mult(radiance(Ray(x, r.d - n * 2 * n.dot(r.d)), depth, Xi));</span><br><span class="line">	&#125;</span><br><span class="line">	else if (obj_refl == REFR) &#123;</span><br><span class="line">		//std::cout &lt;&lt; &quot;REFR&quot; &lt;&lt; std::endl;</span><br><span class="line">		Ray reflRay(x, r.d - n * 2 * n.dot(r.d));</span><br><span class="line">		bool into = n.dot(n_real) &gt; 0;</span><br><span class="line">		double nc = 1;//真空</span><br><span class="line">		double nt = 1.5;//玻璃</span><br><span class="line">		double nnt = into ? nc / nt : nt / nc;</span><br><span class="line">		double ddn = r.d.dot(n_real);</span><br><span class="line">		double cos2_t = 1 - nnt * nnt * (1 - ddn * ddn);	//2是平方</span><br><span class="line"></span><br><span class="line">		if (cos2_t &lt; 0) &#123;	//没有折射，发生全反射</span><br><span class="line">			return obj_e + f.mult(radiance(reflRay, depth, Xi));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Vec tdir = (r.d * nnt - n * ((into ? 1 : -1) * (ddn * nnt + sqrt(cos2_t)))).norm();</span><br><span class="line">		//考虑到计算量，采用近似算法</span><br><span class="line">		double a = nt - nc, b = nt + nc, R0 = a * a / (b * b), c = 1 - (into ? -ddn : tdir.dot(n));</span><br><span class="line">		double Re = R0 + (1 - R0) * c * c * c * c * c, Tr = 1 - Re, P = 0.25 + 0.5 * Re, RP = Re / P, TP = Tr / (1 - P);</span><br><span class="line"></span><br><span class="line">		if (depth &gt; 2) &#123;</span><br><span class="line">			if (erand48(Xi) &lt; P) &#123;	// RR</span><br><span class="line">				return obj_e + f.mult(radiance(reflRay, depth, Xi) * RP);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				return obj_e + f.mult(radiance(Ray(x, tdir), depth, Xi) * TP);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			return obj_e + f.mult(radiance(reflRay, depth, Xi) * Re + radiance(Ray(x, tdir), depth, Xi) * Tr);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vec* c = new Vec[WIDTH * HIGHT];	//图像缓存</span><br><span class="line"></span><br><span class="line">void Initial(void)</span><br><span class="line">&#123;</span><br><span class="line">	glClearColor(1.0f, 1.0f, 1.0f, 1.0f);</span><br><span class="line">	glMatrixMode(GL_PROJECTION);</span><br><span class="line">	int width = glutGet(GLUT_WINDOW_WIDTH);</span><br><span class="line">	int height = glutGet(GLUT_WINDOW_HEIGHT);</span><br><span class="line">	gluOrtho2D(0.0, width, 0.0, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myDisplay(void) &#123;</span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">	glPointSize(1);</span><br><span class="line">	for (int y = 0; y &lt; HIGHT; y++) &#123;</span><br><span class="line">		for (int x = 0; x &lt; WIDTH; x++) &#123;</span><br><span class="line">			int n = (HIGHT - y - 1) * WIDTH + x;</span><br><span class="line">			glColor3f(gamma(c[n].x), gamma(c[n].y), gamma(c[n].z));</span><br><span class="line">			glBegin(GL_POINTS);</span><br><span class="line">			glVertex2f(x, y);</span><br><span class="line">			glEnd();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	glFlush();</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">	int w = WIDTH, h = HIGHT;</span><br><span class="line">	int samples = 1;	//设置每subpixel采样数</span><br><span class="line">	//设置 camera</span><br><span class="line">	Ray cam(Vec(50, 52, 295.6), Vec(0, -0.042612, -1).norm());</span><br><span class="line">	Vec cx = Vec(w * 0.5135 / h);	//视场角</span><br><span class="line">	Vec cy = (cx.cross(cam.d)).norm() * 0.5135;</span><br><span class="line"></span><br><span class="line">	Vec r;	//摄影机射线</span><br><span class="line">	auto clock_start = clock();</span><br><span class="line">#pragma omp parallel for schedule(dynamic, 1) private(i)</span><br><span class="line"></span><br><span class="line">	meshTriangles[0].move(15, 0, 0);</span><br><span class="line">	for (int y = 0; y &lt; h; y++) &#123;</span><br><span class="line">		UpdateProgress((float)y / HIGHT);</span><br><span class="line">		unsigned short Xi[3] = &#123; 0, 0, y * y * y &#125;;</span><br><span class="line">		//设置四个子像素</span><br><span class="line">		for (unsigned short x = 0; x &lt; w; x++) &#123;</span><br><span class="line">			for (int sy = 0, i = (h - y - 1) * w + x; sy &lt; 2; sy++) &#123;</span><br><span class="line">				for (int sx = 0; sx &lt; 2; sx++, r = Vec()) &#123;</span><br><span class="line">					for (int s = 0; s &lt; samples; s++) &#123;</span><br><span class="line">						double r1 = 2 * erand48(Xi);</span><br><span class="line">						double dx = r1 &lt; 1 ? sqrt(r1) - 1 : 1 - sqrt(2 - r1);</span><br><span class="line">						double r2 = 2 * erand48(Xi);</span><br><span class="line">						//std::cout &lt;&lt; r1 &lt;&lt; &quot; &quot; &lt;&lt; r2 &lt;&lt; std::endl;</span><br><span class="line">						double dy = r2 &lt; 1 ? sqrt(r2) - 1 : 1 - sqrt(2 - r2);</span><br><span class="line">						Vec sample_direct = cx * (((dx + 0.5 + sx) / 2 + x) / w - 0.5)</span><br><span class="line">							+ cy * (((dy + 0.5 + sy) / 2 + y) / h - 0.5) + cam.d;</span><br><span class="line"></span><br><span class="line">						//std::cout &lt;&lt; r.x &lt;&lt; std::endl;</span><br><span class="line">						r = r + radiance(Ray(cam.o + sample_direct * 140, sample_direct.norm()), 0, Xi) * (1.0 / samples);</span><br><span class="line">						//std::cout &lt;&lt; &quot;x:&quot; &lt;&lt; r.x &lt;&lt; &quot;y:&quot; &lt;&lt; r.y &lt;&lt; &quot;, z:&quot; &lt;&lt;r.z &lt;&lt; std::endl;	//</span><br><span class="line">					&#125;</span><br><span class="line">					//std::cout &lt;&lt; c[i].x &lt;&lt; std::endl;	//</span><br><span class="line">					c[i] = c[i] + Vec(clamp01(r.x), clamp01(r.y), clamp01(r.z)) * 0.25;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	FILE* f = fopen(&quot;test.ppm&quot;, &quot;wb&quot;);</span><br><span class="line">	fprintf(f, &quot;P3\n%d %d\n%d\n&quot;, w, h, 255);</span><br><span class="line">	for (int i = 0; i &lt; w * h; i++) &#123;</span><br><span class="line">		fprintf(f, &quot;%d %d %d &quot;, toInt255(c[i].x), toInt255(c[i].y), toInt255(c[i].z));</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(f);</span><br><span class="line">	</span><br><span class="line">	glutInit(&amp;argc, argv);</span><br><span class="line">	glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE);</span><br><span class="line">	glutInitWindowPosition(100, 100);</span><br><span class="line">	glutInitWindowSize(w, h);</span><br><span class="line">	glutCreateWindow(&quot;Path Tracing&quot;);</span><br><span class="line"></span><br><span class="line">	Initial();</span><br><span class="line">	glutDisplayFunc(&amp;myDisplay);</span><br><span class="line">	glutMainLoop();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Games101</category>
      </categories>
      <tags>
        <tag>Games101</tag>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>Games101_19_20 Cameras Lenses and Light Fileds</title>
    <url>/2022/10/03/Games101_19_20_Cameras_Lenses_LightFileds/</url>
    <content><![CDATA[<h1 id="Lecture19"><a href="#Lecture19" class="headerlink" title="Lecture19"></a>Lecture19</h1><ul>
<li><p>讲相机的，老本行笔记直接看别人的吧；</p>
<p><a href="http://t.csdn.cn/4gODC">http://t.csdn.cn/4gODC</a></p>
</li>
</ul>
<h2 id="b-Light-Field-Lumingraph-光场"><a href="#b-Light-Field-Lumingraph-光场" class="headerlink" title="b). Light Field / Lumingraph(光场)"></a>b). Light Field / Lumingraph(光场)</h2><table frame="void">
    <tr>
    <td><center><img src="/2022/10/03/Games101_19_20_Cameras_Lenses_LightFileds/LF_000.png" alt="LF_000" height="250"></center></td>
    <td><center><img src="/2022/10/03/Games101_19_20_Cameras_Lenses_LightFileds/LF_001.png" alt="LF_001" height="250"></center></td>
    </tr>
</table>

<ul>
<li>两者看到的光线信息完全相同，那人眼中的世界就完全相同；</li>
</ul>
<h3 id="b-1-The-Plenoptic-Function-全光函数"><a href="#b-1-The-Plenoptic-Function-全光函数" class="headerlink" title="b.1). The Plenoptic Function(全光函数)"></a>b.1). The Plenoptic Function(全光函数)</h3><p><img src="/2022/10/03/Games101_19_20_Cameras_Lenses_LightFileds/PlenopticFunc.png" alt="PlenopticFunc"></p>
<ul>
<li>现实世界可以用一个七维的全光函数进行描述，记录了任意时间，不同位置的不同方向接收光的波长</li>
<li>参数：<ul>
<li>$\theta$ ：方位角</li>
<li>$\phi$：俯仰角</li>
<li>$\lambda$：波长</li>
<li>$t$：时间</li>
<li>$V_X，V_Y,V_Z$：位置</li>
</ul>
</li>
</ul>
<h3 id="b-2-Light-Field"><a href="#b-2-Light-Field" class="headerlink" title="b.2). Light Field"></a>b.2). Light Field</h3><p><strong>光场</strong>则可以认为是记录了任何一个点所接收的任何一个方向的irradiance。</p>
<ul>
<li>可用四维函数表示，二维描述位置，二维描述方向</li>
<li>光线可由两个点定义，因此这四维可改写成s,t,u,v。即两个平面上的位置； </li>
</ul>
<p><img src="/2022/10/03/Games101_19_20_Cameras_Lenses_LightFileds/LF_2Plane.png" alt="LF_2Plane"></p>
<ul>
<li><p>由此得出，描述一个物体的光场，只需要记录其包围盒上四维的全光函数即可</p>
<p><img src="/2022/10/03/Games101_19_20_Cameras_Lenses_LightFileds/PF_Thing.png" alt="PF_Thing"></p>
</li>
<li><p>从uv平面看向st平面，得到的是这个物体从各个方向看的相应的图像；</p>
</li>
<li><p>而从st看向uv，则得到的是这个物体在这个方向的irradiance的集合（不是合起来，而是类似二维数组的集合）即<strong>radiance</strong></p>
<p><img src="/2022/10/03/Games101_19_20_Cameras_Lenses_LightFileds/uvst.png" alt="uvst"></p>
</li>
<li><p><strong>st到uv</strong></p>
<p><img src="/2022/10/03/Games101_19_20_Cameras_Lenses_LightFileds/st2uv.png" alt="st2uv"></p>
<ul>
<li>记录不同方向的光线radiance（注意和拜耳阵列的区分，这里三色只是代表不同方向）</li>
</ul>
</li>
</ul>
<h3 id="b-3-Light-Field-Camera"><a href="#b-3-Light-Field-Camera" class="headerlink" title="b.3). Light Field Camera"></a>b.3). Light Field Camera</h3><p><img src="/2022/10/03/Games101_19_20_Cameras_Lenses_LightFileds/LF_camera.png" alt="LF_camera"></p>
<ul>
<li><p>支持先拍照，后期动态调焦、光圈等</p>
<p><img src="/2022/10/03/Games101_19_20_Cameras_Lenses_LightFileds/st2uv2.png" alt="st2uv2"></p>
</li>
</ul>
<h1 id="Lecture20"><a href="#Lecture20" class="headerlink" title="Lecture20"></a>Lecture20</h1>]]></content>
      <categories>
        <category>Games101</category>
      </categories>
      <tags>
        <tag>Games101</tag>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>Games101_10_12 Geometry</title>
    <url>/2022/10/02/Games101_10_12_Geometry/</url>
    <content><![CDATA[<h1 id="Lecture-10-11-Geometry-1-2"><a href="#Lecture-10-11-Geometry-1-2" class="headerlink" title="Lecture 10/11: Geometry 1 2"></a>Lecture 10/11: Geometry 1 2</h1><ul>
<li>不可能所有物体都用三角面表示，一些复杂的物体如毛发、水滴等用三角面表示开销极大；</li>
</ul>
<h2 id="a-几何的表示形式"><a href="#a-几何的表示形式" class="headerlink" title="a). 几何的表示形式"></a>a). 几何的表示形式</h2><ul>
<li>隐式（Implicit）<ul>
<li>algebraic surface</li>
<li>level sets</li>
<li>distance functions</li>
<li>…</li>
</ul>
</li>
<li>显式（Explicit）<ul>
<li>point cloud</li>
<li>polygon mesh</li>
<li>subdivision, NURBS</li>
<li>…</li>
</ul>
</li>
</ul>
<h2 id="b-几何的隐式表示（Implict-Representations-of-Geometry）"><a href="#b-几何的隐式表示（Implict-Representations-of-Geometry）" class="headerlink" title="b). 几何的隐式表示（Implict Representations of Geometry）"></a>b). 几何的隐式表示（Implict Representations of Geometry）</h2><ul>
<li><strong>基于归类的点</strong><ul>
<li>点满足某种特定的关系，但不给你特定的点<ul>
<li>e.g. <strong>Sphere:</strong> 所有三维中的点，满足 $x^2+y^2+z^2=1$；</li>
</ul>
</li>
<li><strong>通用情况：</strong>$f(x,y,z)=0$<img src="/2022/10/02/Games101_10_12_Geometry/Geo_Implicit.png" alt="Geo_Implicit"></li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>难以采样（Sampling Can Be Hard，难以得到式子表示的整体形状）<img src="/2022/10/02/Games101_10_12_Geometry/Implicit_B.png" alt="Implicit_B"></li>
</ul>
</li>
<li><strong>优点：</strong><ul>
<li>方便判断点是否在几何体内（Inside/Outside Tests Easy）<img src="/2022/10/02/Games101_10_12_Geometry/Implicit_G.png" alt="Implicit_G"></li>
</ul>
</li>
</ul>
<h3 id="b-1-Algebraic-Surfaces（曲面代数）"><a href="#b-1-Algebraic-Surfaces（曲面代数）" class="headerlink" title="b.1). Algebraic Surfaces（曲面代数）"></a>b.1). Algebraic Surfaces（曲面代数）</h3><p><img src="/2022/10/02/Games101_10_12_Geometry/AlgebraicSurfaces.png" alt="AlgebraicSurfaces"></p>
<ul>
<li>难以表达复杂的形状；</li>
</ul>
<h3 id="b-2-Constructive-Solid-Geometry（CSG-体素构造表示形式）"><a href="#b-2-Constructive-Solid-Geometry（CSG-体素构造表示形式）" class="headerlink" title="b.2). Constructive Solid Geometry（CSG, 体素构造表示形式）"></a>b.2). Constructive Solid Geometry（CSG, 体素构造表示形式）</h3><ul>
<li>对隐式几何体进行布尔运算；<img src="/2022/10/02/Games101_10_12_Geometry/CSG.png" alt="CSG"></li>
</ul>
<h3 id="b-3-Distance-Function（距离函数）"><a href="#b-3-Distance-Function（距离函数）" class="headerlink" title="b.3). Distance Function（距离函数）"></a>b.3). Distance Function（距离函数）</h3><p><img src="/2022/10/02/Games101_10_12_Geometry/DistanceFunctions.png" alt="DistanceFunctions"></p>
<ul>
<li><strong>给出各个点到物体的最小距离</strong></li>
</ul>
<ul>
<li><strong>Blending Distance Function:</strong><img src="/2022/10/02/Games101_10_12_Geometry/BlendingDF.png" alt="BlendingDF"><ul>
<li><strong>目的：</strong>通过混合得到A、B运动的中间状态；<ul>
<li>上半部分，blend之后中间1/3是灰的，而理想的结果是<strong>左边1/2是黑色，右边1/2是白色</strong></li>
<li>下半部分，对<strong>SDF</strong>进行混合，再将blend后的结果恢复成shape（找到SDF等于0的情况的所有点），就可得到中间状态的物体；<img src="/2022/10/02/Games101_10_12_Geometry/BlendingSDF.png" alt="BlendingSDF"></li>
</ul>
</li>
</ul>
</li>
<li><em>See <a href="https://iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm">https://iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm</a></em></li>
</ul>
<h3 id="b-4-Level-Set-Methods（水平集）"><a href="#b-4-Level-Set-Methods（水平集）" class="headerlink" title="b.4). Level Set Methods（水平集）"></a>b.4). Level Set Methods（水平集）</h3><ul>
<li><p>封闭方程（DF）很难描述复杂的形状</p>
</li>
<li><p><strong>备选方案：</strong>存储近似函数值的网格（Level Set Methods）<img src="/2022/10/02/Games101_10_12_Geometry/LSM.png" alt="LSM"></p>
<ul>
<li>通过找到插值为0的位置确定表面；</li>
<li><font color="red">提供对形状更明确的控制（如纹理）?</font>
</li>
</ul>
</li>
<li><p><strong>应用：</strong></p>
<ul>
<li><p><strong>Level Sets from Medical Data (CT, MRI, etc. 三维LSM)</strong><img src="/2022/10/02/Games101_10_12_Geometry/LSMin3D.png" alt="LSMin3D"></p>
</li>
<li><p><strong>物理模拟：</strong>如水平集得到各点到液体边界的距离（距离函数混合水滴）<img src="/2022/10/02/Games101_10_12_Geometry/LSMsimulation.png" alt="LSMsimulation"></p>
<ul>
<li><em>See <a href="http://physbam.stanford.edu">http://physbam.stanford.edu</a></em></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="b-5-Fractals-分形"><a href="#b-5-Fractals-分形" class="headerlink" title="b.5). Fractals(分形)"></a>b.5). Fractals(分形)</h3><p><img src="/2022/10/02/Games101_10_12_Geometry/Fractals.png" alt="Fractals"></p>
<h2 id="c-几何的显式表示（“Explicit”-Representations-of-Geometry）"><a href="#c-几何的显式表示（“Explicit”-Representations-of-Geometry）" class="headerlink" title="c). 几何的显式表示（“Explicit” Representations of Geometry）"></a>c). 几何的显式表示（“Explicit” Representations of Geometry）</h2><ul>
<li><p><strong>简介：</strong> <strong>直接给出</strong>所有的点 或者 <strong>通过参数映射（via parameter mapping）</strong></p>
<ul>
<li><strong>参数映射：</strong>给出uv，以及uv到三维空间的映射关系，遍历所有的uv就可找到三维空间所有的点；<img src="/2022/10/02/Games101_10_12_Geometry/Explicit_via_param_mapping.png" alt="Explicit_via_param_mapping"></li>
</ul>
</li>
<li><p><strong>采样简单</strong><img src="/2022/10/02/Games101_10_12_Geometry/Explicit_G.png" alt="Explicit_G"></p>
</li>
</ul>
<ul>
<li><p><strong>不方便</strong>判断点是否在几何体内（Inside/Outside Tests Hard）<img src="/2022/10/02/Games101_10_12_Geometry/Explicit_B.png" alt="Explicit_B"></p>
</li>
<li><p><strong>隐式、显式各有优缺点，需要根据需求选择最优的表达方式</strong></p>
</li>
</ul>
<h3 id="c-1-Point-Cloud"><a href="#c-1-Point-Cloud" class="headerlink" title="c.1). Point Cloud"></a>c.1). Point Cloud</h3><p><img src="/2022/10/02/Games101_10_12_Geometry/PointCloud.png" alt="PointCloud"></p>
<h3 id="c-2-Polygon-Mesh"><a href="#c-2-Polygon-Mesh" class="headerlink" title="c.2). Polygon Mesh"></a>c.2). Polygon Mesh</h3><p><img src="/2022/10/02/Games101_10_12_Geometry/PolygonMesh.png" alt="PolygonMesh"></p>
<ul>
<li>常用的PolygonMesh文件，Wavefront Object File (<strong>.obj</strong>)<ul>
<li>v：顶点位置；vt：纹理位置；vn：normal；f：face，顶点索引/纹理索引/法线索引</li>
<li><img src="/2022/10/02/Games101_10_12_Geometry/PolygonMesh_Obj.png" alt="PolygonMesh_Obj"></li>
</ul>
</li>
</ul>
<h3 id="c-3-Bezier-Curve（贝塞尔曲线）"><a href="#c-3-Bezier-Curve（贝塞尔曲线）" class="headerlink" title="c.3). Bézier Curve（贝塞尔曲线）"></a>c.3). Bézier Curve（贝塞尔曲线）</h3><ul>
<li>通过点$p_0$ 、$p_1$，且在这两点切线为$t0$、$t1$（切线前带系数，对于三次贝塞尔曲线系数为3）<img src="/2022/10/02/Games101_10_12_Geometry/Bezier_DT.png" alt="Bezier_DT"></li>
</ul>
<h4 id="c-3-1-计算贝塞尔曲线-德卡斯特里奥算法-De-Casteljau’s-Algorithm"><a href="#c-3-1-计算贝塞尔曲线-德卡斯特里奥算法-De-Casteljau’s-Algorithm" class="headerlink" title="c.3.1). 计算贝塞尔曲线(德卡斯特里奥算法, De Casteljau’s Algorithm)"></a>c.3.1). 计算贝塞尔曲线(德卡斯特里奥算法, De Casteljau’s Algorithm)</h4><ul>
<li><strong>二次贝塞尔曲线</strong></li>
</ul>
<p><img src="/2022/10/02/Games101_10_12_Geometry/德卡斯特里奥算法.png" alt="德卡斯特里奥算法"></p>
<ul>
<li><p><strong>三次贝塞尔曲线（Cubic Bezier Curve）</strong><img src="/2022/10/02/Games101_10_12_Geometry/CubicBezierCurve.png" alt="CubicBezierCurve"></p>
</li>
<li><p>Anim：<img src="/2022/10/02/Games101_10_12_Geometry/Bezier2.gif" alt="Bezier2"></p>
<p><img src="/2022/10/02/Games101_10_12_Geometry/Bezier3.gif" alt="Bezier3"></p>
</li>
</ul>
<h4 id="c-3-2-代数形式"><a href="#c-3-2-代数形式" class="headerlink" title="c.3.2). 代数形式"></a>c.3.2). 代数形式</h4><p><img src="/2022/10/02/Games101_10_12_Geometry/Bezier_Algebraic.png" alt="Bezier_Algebraic"></p>
<ul>
<li>推出<strong>Bernstein polynomial（伯恩斯坦多项式）</strong>：</li>
</ul>
<script type="math/tex; mode=display">
B_{i}^{n}(t)=C_n^i · t^{i}(1-t)^{n-i}</script><ul>
<li><img src="/2022/10/02/Games101_10_12_Geometry/Bernstein.png" alt="Bernstein"></li>
<li><img src="/2022/10/02/Games101_10_12_Geometry/Bernstein2.png" alt="Bernstein2"></li>
</ul>
<h4 id="C-3-3-性质"><a href="#C-3-3-性质" class="headerlink" title="C.3.3). 性质"></a>C.3.3). 性质</h4><p><img src="/2022/10/02/Games101_10_12_Geometry/Properties_Bezier.png" alt="Properties_Bezier"></p>
<ul>
<li>即（对于三次贝塞尔曲线）：<ul>
<li>$b_0$ 是起点，$b_3$是终点；</li>
<li>切线为$\mathbf{b}^{\prime}(0)=3\left(\mathbf{b}_{1}-\mathbf{b}_{0}\right) ; \quad \mathbf{b}^{\prime}(1)=3\left(\mathbf{b}_{3}-\mathbf{b}_{2}\right)$ （切线前带系数，对于三次贝塞尔曲线系数为3，通过求导可得）</li>
<li>仿射不变性（对于贝塞尔曲线做仿射变换，只需要对控制点进行变换）</li>
<li>凸包性质；</li>
</ul>
</li>
</ul>
<h4 id="c-3-4-Piecewise-Bezier-Curves（分段贝塞尔曲线）"><a href="#c-3-4-Piecewise-Bezier-Curves（分段贝塞尔曲线）" class="headerlink" title="c.3.4). Piecewise Bézier Curves（分段贝塞尔曲线）"></a>c.3.4). Piecewise Bézier Curves（分段贝塞尔曲线）</h4><ul>
<li>使用原因：解决高阶贝塞尔曲线控制点过多的问题；</li>
<li>分段贝塞尔曲线，常是<strong>分段立方贝塞尔（Piecewise cubic Bézier）</strong>，即每一个曲线存在4个控制点；<img src="/2022/10/02/Games101_10_12_Geometry/Piecewise_cubic_Bezier.png" alt="Piecewise_cubic_Bezier"></li>
</ul>
<h5 id="c-3-4-1-连续性"><a href="#c-3-4-1-连续性" class="headerlink" title="c.3.4.1). 连续性"></a>c.3.4.1). 连续性</h5><p><img src="/2022/10/02/Games101_10_12_Geometry/Continuity.png" alt="Continuity"></p>
<ul>
<li><p>C<sup>0</sup> 连续（C表示Continuity），几何连续：$a_n=b_0$ ；</p>
<ul>
<li>首尾相接，夹角任意；<img src="/2022/10/02/Games101_10_12_Geometry/C0.png" alt="C0"></li>
</ul>
</li>
<li><p>C<sup>1</sup> 连续，参数连续：$a_n=b_0={1\over2}(a_{n-1} + b_1)$ ；</p>
<ul>
<li>切线相等，即一阶导数连续；<img src="/2022/10/02/Games101_10_12_Geometry/C1.png" alt="C1"></li>
</ul>
</li>
</ul>
<h4 id="3-5-Other-types-of-splines-待深入"><a href="#3-5-Other-types-of-splines-待深入" class="headerlink" title="3.5). Other types of splines(待深入)"></a>3.5). Other types of splines(待深入)</h4><p><img src="/2022/10/02/Games101_10_12_Geometry/Spline.png" alt="Spline"></p>
<p><img src="/2022/10/02/Games101_10_12_Geometry/B_splines.png" alt="B_splines"></p>
<ul>
<li>In this course <ul>
<li>We do not cover B-splines and NURBS</li>
<li>We also do not cover operations on curves (e.g. increasing/decreasing orders, etc.)</li>
<li>To learn more / deeper, you are welcome to refer to Prof. Shi-Min Hu’s course: <a href="https://www.bilibili.com/video/av66548502?from=search&amp;seid=65256805876131485">https://www.bilibili.com/video/av66548502?from=search&amp;seid=65256805876131485</a></li>
</ul>
</li>
</ul>
<h4 id="3-6-Bezier-Surface"><a href="#3-6-Bezier-Surface" class="headerlink" title="3.6). Bezier Surface"></a>3.6). Bezier Surface</h4><p><img src="/2022/10/02/Games101_10_12_Geometry/BezierSurface.png" alt="BezierSurface"></p>
<p><img src="/2022/10/02/Games101_10_12_Geometry/BezierSurface_vis.png" alt="BezierSurface_vis"></p>
<ul>
<li>Animation: Steven Wittens, Making Things with Maths, <a href="http://acko.net">http://acko.net</a></li>
</ul>
<h5 id="3-6-1-Evaluating-Bezier-Surfaces"><a href="#3-6-1-Evaluating-Bezier-Surfaces" class="headerlink" title="3.6.1). Evaluating Bézier Surfaces"></a>3.6.1). Evaluating Bézier Surfaces</h5><p><img src="/2022/10/02/Games101_10_12_Geometry/Eva_BezierSurface.png" alt="Eva_BezierSurface"></p>
<p><img src="/2022/10/02/Games101_10_12_Geometry/BezierSurface_method1.png" alt="BezierSurface_method1"></p>
<p><img src="/2022/10/02/Games101_10_12_Geometry/BezierSurface_method2.png" alt="BezierSurface_method2"></p>
<p><img src="/2022/10/02/Games101_10_12_Geometry/MeshOperations.png" alt="MeshOperations"></p>
<h1 id="Lecture-13-Geometry"><a href="#Lecture-13-Geometry" class="headerlink" title="Lecture 13 Geometry"></a>Lecture 13 Geometry</h1><h2 id="a-Subdivision"><a href="#a-Subdivision" class="headerlink" title="a). Subdivision"></a>a). Subdivision</h2><p><img src="/2022/10/02/Games101_10_12_Geometry/Subdivision.png" alt="Subdivision"></p>
<ul>
<li>以下是几种常用的细分方法:</li>
</ul>
<h3 id="a-1-Loop-Subdivision-Loop是人名"><a href="#a-1-Loop-Subdivision-Loop是人名" class="headerlink" title="a.1). Loop Subdivision(Loop是人名)"></a>a.1). Loop Subdivision(Loop是人名)</h3><ul>
<li><strong>细分对象：<font color="red">三角面</font></strong><ul>
<li>首先，创造更多的三角面；</li>
<li>第二，改变他们的位置；<img src="/2022/10/02/Games101_10_12_Geometry/LoopSub.png" alt="LoopSub"></li>
</ul>
</li>
</ul>
<ul>
<li><strong>具体做法：</strong><ul>
<li>将每个三角形细分为四个；<img src="/2022/10/02/Games101_10_12_Geometry/SplitTriangle.png" alt="SplitTriangle"></li>
<li>根据权重分配新的顶点位置；<ul>
<li>区分新/老顶点，做不同变换；</li>
</ul>
</li>
<li>对于<strong>新顶点</strong>：<ul>
<li>$P_{new} = {3\over8}(A+B)+{1\over8}(C+D)$<img src="/2022/10/02/Games101_10_12_Geometry/LoopSub_NewVert.png" alt="LoopSub_NewVert"></li>
</ul>
</li>
<li>对于<strong>老顶点</strong>：<ul>
<li>$n:$ 顶点的度（图论，与该顶点关联的边的数目，该处即为<strong>与该顶点连接的边的数量</strong>）</li>
<li>$u:$ $3/16$（如果$n=3$），$3/(8n)$ （其他情况）</li>
<li>$P_{new} = (1-nu)original_position + u·neighbor_position_sum$</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Loop Subdivision Results：</strong><img src="/2022/10/02/Games101_10_12_Geometry/LoopSub_Result.png" alt="LoopSub_Result"></p>
</li>
<li><p><strong>缺点：Loop只能处理三角面</strong>；</p>
</li>
</ul>
<h3 id="a-2-Catmull-Clark-Subdivision"><a href="#a-2-Catmull-Clark-Subdivision" class="headerlink" title="a.2). Catmull-Clark Subdivision"></a>a.2). Catmull-Clark Subdivision</h3><p><img src="/2022/10/02/Games101_10_12_Geometry/Catmull_Clark_Sub.png" alt="Catmull_Clark_Sub"></p>
<ul>
<li><p><strong>概念：</strong></p>
<ul>
<li>奇异点（Extraorinary vertex）：度不为4的点；</li>
</ul>
</li>
<li><p><strong>具体过程：</strong></p>
<ul>
<li><p><strong>第一次细分：</strong></p>
<ol>
<li>每条边取中点，每个面也取其中一点；<img src="/2022/10/02/Games101_10_12_Geometry/Catmull_Clark_Sub_01.png" alt="Catmull_Clark_Sub_01"></li>
</ol>
<ul>
<li>第一次细分后，<strong>引入（n个，n=非四边形数目）奇异点，非四边形面消失</strong>。之后，奇异点不在增加，因此，之后细分只针对四边面；<img src="/2022/10/02/Games101_10_12_Geometry/Catmull_Clark_Sub_02.png" alt="Catmull_Clark_Sub_02"></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Catmull-Clark Vertex Update Rules (Quad Mesh)</strong></p>
<p><img src="/2022/10/02/Games101_10_12_Geometry/Catmull_Clark_Sub_UpdateRules.png" alt="Catmull_Clark_Sub_UpdateRules"></p>
<ul>
<li><strong>Face point:</strong> </li>
</ul>
<p>$$<br>f=</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Games101</category>
      </categories>
      <tags>
        <tag>Games101</tag>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>Games101_17_18 Materials</title>
    <url>/2022/10/03/Games101_17_18_Materials/</url>
    <content><![CDATA[<h1 id="Lecture-17-Materials-and-Appearances"><a href="#Lecture-17-Materials-and-Appearances" class="headerlink" title="Lecture 17 Materials and Appearances"></a>Lecture 17 Materials and Appearances</h1><p><strong>Material == BRDF</strong></p>
<h2 id="a-Diffuse-Lambertian-Material"><a href="#a-Diffuse-Lambertian-Material" class="headerlink" title="a). Diffuse / Lambertian Material"></a>a). Diffuse / Lambertian Material</h2><p><img src="/2022/10/03/Games101_17_18_Materials/Diffuse_Lambertian_Mat.png" alt="Diffuse_Lambertian_Mat"></p>
<ul>
<li><p>对于此类材质，当假定各方向9入射的光线radiance相同，反射的光同样是Uniform的。因为能量守恒（假定不发光，不吸收），使得进入的 <strong><em>Irradiance<sub>入</sub></em></strong> 和出去的 <strong><em>Irradiance<sub>出 </sub></em></strong>相同；</p>
<p><img src="/2022/10/03/Games101_17_18_Materials/Diffuse_Lambertian_Mat02.png" alt="Diffuse_Lambertian_Mat02"></p>
<ul>
<li><p><a href="https://www.bilibili.com/video/BV1Bt41187ZF/?spm_id_from=333.337.search-card.all.click&amp;vd_source=627aabb12e63b6a55ebc4e4799bb0408"><em>二重积分</em></a></p>
<table frame="void">
    <tr>
    <td><center><img src="/2022/10/03/Games101_17_18_Materials/半球积分.png" alt="半球积分" height="250"></center></td>
    <td><center><img src="/2022/10/03/Games101_17_18_Materials/半球积分2.jpg" alt="半球积分2" height="250"></center></td>
    </tr>
</table>

</li>
</ul>
</li>
</ul>
<h2 id="b-Glossy-material"><a href="#b-Glossy-material" class="headerlink" title="b). Glossy material"></a>b). Glossy material</h2><p><img src="/2022/10/03/Games101_17_18_Materials/Glossy_Mat.png" alt="Glossy_Mat"></p>
<h2 id="c-Ideal-reflective-refractive-material-BSDF"><a href="#c-Ideal-reflective-refractive-material-BSDF" class="headerlink" title="c). Ideal reflective / refractive material(BSDF)"></a>c). Ideal reflective / refractive material(BSDF)</h2><p><img src="/2022/10/03/Games101_17_18_Materials/Reflective_Refractive_Mat.png" alt="Reflective_Refractive_Mat"></p>
<ul>
<li><p>计算镜面反射方向</p>
<p><img src="/2022/10/03/Games101_17_18_Materials/Perfect_Specular_Reflection.png" alt="Perfect_Specular_Reflection"></p>
<ul>
<li>几何</li>
<li>方位角</li>
</ul>
</li>
</ul>
<h3 id="c-1-Specular-Refraction"><a href="#c-1-Specular-Refraction" class="headerlink" title="c.1). Specular Refraction"></a>c.1). Specular Refraction</h3><p><img src="/2022/10/03/Games101_17_18_Materials/Specular Refraction.png" alt="Specular Refraction"></p>
<ul>
<li><p>现象：色散、Caustic等</p>
</li>
<li><p><strong>Snell’s Law</strong></p>
<p><img src="/2022/10/03/Games101_17_18_Materials/Snell Law.png" alt="Snell Law"></p>
<ul>
<li><p>可推出只有当光密到光疏介质时，才有可能发生折射；（${n_i\over n_t}&gt;1$）</p>
<p><img src="/2022/10/03/Games101_17_18_Materials/Snell Law_02.png" alt="Snell Law_02"></p>
</li>
</ul>
</li>
<li><p>折射属于BT(Transmit)DF;</p>
<ul>
<li><strong>BTDF + BRDF = BSDF</strong> </li>
</ul>
</li>
</ul>
<h3 id="c-2-Fresnel-Reflection-菲涅尔"><a href="#c-2-Fresnel-Reflection-菲涅尔" class="headerlink" title="c.2). Fresnel Reflection(菲涅尔)"></a>c.2). Fresnel Reflection(菲涅尔)</h3><ul>
<li>反应了特定方向的入射光的反射和折射的比例；</li>
</ul>
<table frame="void">
    <tr>
    <td><center><img src="/2022/10/03/Games101_17_18_Materials/绝缘体_Fresnel.png" alt="绝缘体_Fresnel" height="250"></center></td>
    <td><center><img src="/2022/10/03/Games101_17_18_Materials/导体(金属)_Fresnel.png" alt="导体(金属)_Fresnel" height="250"></center></td>
    </tr>
</table>

<ul>
<li>左图是绝缘体的菲涅尔项，右图是导体（金属）的菲涅尔项</li>
</ul>
<p><img src="/2022/10/03/Games101_17_18_Materials/FresnelTerm.png" alt="FresnelTerm"></p>
<h2 id="d-Microfacet-Material-微表面材质"><a href="#d-Microfacet-Material-微表面材质" class="headerlink" title="d). Microfacet Material(微表面材质)"></a>d). Microfacet Material(微表面材质)</h2><p> <img src="/2022/10/03/Games101_17_18_Materials/MicrofacetTheory.png" alt="MicrofacetTheory"></p>
<ul>
<li><p><strong>关键：</strong> 微表面的<strong><font color="red">法线分布</font></strong></p>
<p><img src="/2022/10/03/Games101_17_18_Materials/NormalDistribution.png" alt="NormalDistribution"></p>
</li>
</ul>
<h3 id="d-1-Microfacet-BRDF"><a href="#d-1-Microfacet-BRDF" class="headerlink" title="d.1). Microfacet BRDF"></a>d.1). Microfacet BRDF</h3><p><img src="/2022/10/03/Games101_17_18_Materials/MicrofacetBRDF.png" alt="MicrofacetBRDF"></p>
<ul>
<li>菲涅尔项；</li>
<li>Shadowing-masking term<ul>
<li>考虑微表面之间的遮挡和阴影；</li>
<li>当光线几乎平行与表面入射时(Grazing angle)，微表面之间遮挡变多</li>
</ul>
</li>
<li>Disterbution of normals</li>
</ul>
<h2 id="e-Isotropic-Anisotropic-Materials-BRDFs"><a href="#e-Isotropic-Anisotropic-Materials-BRDFs" class="headerlink" title="e). Isotropic / Anisotropic Materials (BRDFs)"></a>e). Isotropic / Anisotropic Materials (BRDFs)</h2><p><img src="/2022/10/03/Games101_17_18_Materials/Isotropic_Anisotropic_Mat.png" alt="Isotropic_Anisotropic_Mat"></p>
<ul>
<li>Key:  <strong><font color="red">directionality</font></strong> of underlying surface</li>
</ul>
<h3 id="e-1-Anisotropic-BRDFs"><a href="#e-1-Anisotropic-BRDFs" class="headerlink" title="e.1). Anisotropic BRDFs"></a>e.1). Anisotropic BRDFs</h3><p><img src="/2022/10/03/Games101_17_18_Materials/Anisotropic_Mat_BRDF.png" alt="Anisotropic_Mat_BRDF"></p>
<ul>
<li>如尼龙、天鹅绒等</li>
</ul>
<h2 id="f-Properties-of-BRDFs-BRDF的性质"><a href="#f-Properties-of-BRDFs-BRDF的性质" class="headerlink" title="f). Properties of BRDFs(BRDF的性质)"></a>f). Properties of BRDFs(BRDF的性质)</h2><ul>
<li><p>非负性</p>
<script type="math/tex; mode=display">
f_{r}\left(\omega_{i} \rightarrow \omega_{r}\right) \geq 0</script></li>
<li><p>线性性质</p>
<ul>
<li>如 高光、漫反射、环境光等的BRDF分开计算最后再求和，和用整体的BRDF和整体的光线一起计算结果相等</li>
</ul>
<p><img src="/2022/10/03/Games101_17_18_Materials/BRDF_Linearity.png" alt="BRDF_Linearity"></p>
</li>
<li><p>可逆性</p>
<p><img src="/2022/10/03/Games101_17_18_Materials/BRDF_Reciprocity_principle.png" alt="BRDF_Reciprocity_principle"></p>
</li>
<li><p>能量守恒</p>
</li>
<li><p><img src="/2022/10/03/Games101_17_18_Materials/BRDF_Is_vs_ani.png" alt="BRDF_Is_vs_ani"></p>
<ul>
<li>各向同性时，BRDF可转为三维(两个俯仰角，及方位角之差)</li>
</ul>
</li>
</ul>
<h1 id="Lecture-18-Advanced-Topics-in-Rendering"><a href="#Lecture-18-Advanced-Topics-in-Rendering" class="headerlink" title="Lecture 18 Advanced Topics in Rendering"></a>Lecture 18 Advanced Topics in Rendering</h1><h2 id="a-Advanced-Light-Transport"><a href="#a-Advanced-Light-Transport" class="headerlink" title="a). Advanced Light Transport"></a>a). Advanced Light Transport</h2><h3 id="a-1-分类"><a href="#a-1-分类" class="headerlink" title="a.1). 分类"></a>a.1). 分类</h3><p><img src="/2022/10/03/Games101_17_18_Materials/Advanced Light Transport_00.png" alt="Advanced Light Transport_00"></p>
<ul>
<li><strong>Unbiased（无偏）：</strong> 无论采样多少次，其数学期望和正确的值相同；</li>
<li>否则，则为<strong>biased（有偏）</strong><ul>
<li>在某种情况下（如采样数增大），其数学期望逐渐向正确的值收敛，则称为<strong>consistent</strong>（一致的） </li>
</ul>
</li>
</ul>
<h3 id="a-2-Bidirectional-Path-Tracing-BDPT"><a href="#a-2-Bidirectional-Path-Tracing-BDPT" class="headerlink" title="a.2). Bidirectional Path Tracing(BDPT)"></a>a.2). Bidirectional Path Tracing(BDPT)</h3><p><img src="/2022/10/03/Games101_17_18_Materials/BDPT.png" alt="BDPT"></p>
<ul>
<li><p>当使用PT，摄影机出发的光线的第一次Bounce大部分是Diffuse时，其不容易得到光线强的方向的贡献，此时BDPT效率更高（<em>语言待优化</em>）</p>
<p><img src="/2022/10/03/Games101_17_18_Materials/BDPT02.png" alt="BDPT02"></p>
</li>
</ul>
<h3 id="a-3-Metropolis-Light-Transport-MLT"><a href="#a-3-Metropolis-Light-Transport-MLT" class="headerlink" title="a.3). Metropolis Light Transport(MLT)"></a>a.3). Metropolis Light Transport(MLT)</h3><p><img src="/2022/10/03/Games101_17_18_Materials/MLT_00.png" alt="MLT_00"></p>
<ul>
<li><p>通过<em>马尔科夫链</em> 在已有样本周围形成新样本，其得到的PDF的形状与被积函数 $f(x)$ 形状一致（此时）方差最小；</p>
</li>
<li><p><strong>优点：</strong>适合复杂、困难的光线传播</p>
<ul>
<li>如：图一和图二SDS(Specular-Diffuse-Specular)</li>
</ul>
<p><img src="/2022/10/03/Games101_17_18_Materials/MLT_01.png" alt="MLT_01"></p>
</li>
<li><p><strong>缺点：</strong>难以估计何时收敛，不知道采样到什么程度才可以没噪声，造成Dirty；</p>
<p><img src="/2022/10/03/Games101_17_18_Materials/MLT_02.png" alt="MLT_02"></p>
</li>
</ul>
<h3 id="a-4-Photon-Mapping-光子映射"><a href="#a-4-Photon-Mapping-光子映射" class="headerlink" title="a.4). Photon Mapping(光子映射)"></a>a.4). Photon Mapping(光子映射)</h3><p> <img src="/2022/10/03/Games101_17_18_Materials/PhotonMapping.png" alt="PhotonMapping"></p>
<p><img src="/2022/10/03/Games101_17_18_Materials/PhotonMapping01.png" alt="PhotonMapping01"></p>
<p><img src="/2022/10/03/Games101_17_18_Materials/PhotonMapping02.png" alt="PhotonMapping02"></p>
<ul>
<li><p><strong>做法之一：</strong></p>
<ol>
<li><p>光源发射光子，弹射数次后最终停留在<strong>Diffuse</strong>表面</p>
</li>
<li><p>摄影机发射光子，弹射数次后最终停留在<strong>Diffuse</strong>表面</p>
</li>
<li>局部密度估值（光子密度越大，该点越亮）；<ul>
<li>可使用KD-Tree等加速结构</li>
</ul>
</li>
</ol>
</li>
<li><p>biased会导致模糊</p>
</li>
</ul>
<p><img src="/2022/10/03/Games101_17_18_Materials/PM_biased.png" alt="PM_biased"></p>
<h3 id="a-5-Vertex-Connection-Merging-VCM"><a href="#a-5-Vertex-Connection-Merging-VCM" class="headerlink" title="a.5). Vertex Connection Merging(VCM)"></a>a.5). Vertex Connection Merging(VCM)</h3><p><img src="/2022/10/03/Games101_17_18_Materials/VCM00.png" alt="VCM00"></p>
<ul>
<li>使用BDPT后，对于临近的端点使用Photon Mapping</li>
<li><strong><em>电影常用</em></strong></li>
</ul>
<h3 id="a-6-Instant-Radiosity-实时辐射度"><a href="#a-6-Instant-Radiosity-实时辐射度" class="headerlink" title="a.6). Instant Radiosity(实时辐射度)"></a>a.6). Instant Radiosity(实时辐射度)</h3><p><img src="/2022/10/03/Games101_17_18_Materials/IR00.png" alt="IR00"></p>
<p><img src="/2022/10/03/Games101_17_18_Materials/IR01.png" alt="IR01"></p>
<ul>
<li><strong>出现亮点原因：</strong><ul>
<li>计算直接光照时，换元成了dA，而此处换元依赖于，面积A和立体角w的计算，其中分母是距离的平方，如果距离很接近，那么就会除以一个极小值，使得结果变过大</li>
</ul>
</li>
</ul>
<h2 id="b-Advanced-Appearance-Modeling"><a href="#b-Advanced-Appearance-Modeling" class="headerlink" title="b). Advanced Appearance Modeling"></a>b). Advanced Appearance Modeling</h2><h3 id="b-1-分类"><a href="#b-1-分类" class="headerlink" title="b.1). 分类"></a>b.1). 分类</h3><p><img src="/2022/10/03/Games101_17_18_Materials/Advanced Appearance Modeling.png" alt="Advanced Appearance Modeling"></p>
<h3 id="b-2-Non-surface-models"><a href="#b-2-Non-surface-models" class="headerlink" title="b.2). Non-surface models"></a>b.2). Non-surface models</h3><h4 id="b-2-1-Participation-media"><a href="#b-2-1-Participation-media" class="headerlink" title="b.2.1). Participation media"></a>b.2.1). Participation media</h4><ul>
<li><p>光在传播过程中，有穿过一个Participation medium，那么它会被<strong>吸收、散射</strong></p>
<p><img src="/2022/10/03/Games101_17_18_Materials/ParticipatingMedia00.png" alt="ParticipatingMedia00"></p>
</li>
</ul>
<p><img src="/2022/10/03/Games101_17_18_Materials/ParticipatingMedia01.png" alt="ParticipatingMedia01"></p>
<ul>
<li><p><strong>Rendering</strong></p>
<p><img src="/2022/10/03/Games101_17_18_Materials/ParticipatingMedia_Rendering.png" alt="ParticipatingMedia_Rendering"></p>
</li>
</ul>
<h4 id="b-2-2-Hair-Fur-Appearance"><a href="#b-2-2-Hair-Fur-Appearance" class="headerlink" title="b.2.2). Hair/Fur Appearance"></a>b.2.2). Hair/Fur Appearance</h4><ul>
<li><p><strong>Kajiya_Kay_Model</strong></p>
<p><img src="/2022/10/03/Games101_17_18_Materials/Kajiya_Kay_Model.png" alt="Kajiya_Kay_Model"></p>
</li>
<li><p><strong>Marschner Model</strong></p>
<p><img src="/2022/10/03/Games101_17_18_Materials/Marschner Model.png" alt="Marschner Model"></p>
<ul>
<li><p>认为毛发表面类似玻璃柱，其中分为Cuticle（表皮）、Cortex（皮质，吸收光）</p>
<p><img src="/2022/10/03/Games101_17_18_Materials/Marschner Model01.png" alt="Marschner Model01"></p>
<ul>
<li>光经过毛发被分为3项，R、TT、TRT</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Double Cylinder Model</strong></p>
<ul>
<li><p>考虑了髓质（Medulla，散射光线）</p>
<p><img src="/2022/10/03/Games101_17_18_Materials/Double_Cylinder_Model.png" alt="Double_Cylinder_Model"></p>
<p><img src="/2022/10/03/Games101_17_18_Materials/Double_Cylinder_Model_02.png" alt="Double_Cylinder_Model_02"></p>
</li>
<li><p>光经过毛发被分为5项，R、TT、TRT、TTs、TRTs</p>
<p><img src="/2022/10/03/Games101_17_18_Materials/Double_Cylinder_Model_03.png" alt="Double_Cylinder_Model_03"></p>
</li>
</ul>
</li>
</ul>
<h4 id="b-2-3-Granular-Material（颗粒材质）"><a href="#b-2-3-Granular-Material（颗粒材质）" class="headerlink" title="b.2.3). Granular Material（颗粒材质）"></a>b.2.3). Granular Material（颗粒材质）</h4><p><img src="/2022/10/03/Games101_17_18_Materials/Granular Material.png" alt="Granular Material"></p>
<h3 id="b-3-Surface-models"><a href="#b-3-Surface-models" class="headerlink" title="b.3). Surface models"></a>b.3). Surface models</h3><h4 id="b-3-1-Translucent-半透明-Material"><a href="#b-3-1-Translucent-半透明-Material" class="headerlink" title="b.3.1). Translucent(半透明) Material"></a>b.3.1). Translucent(半透明) Material</h4><ul>
<li><p><strong>概念：</strong>Translucent实际上和半透明有一定区分，它还涉及到吸收、散射（SSS）等现象。Translucent只是表示光从表面一个地方进入，再从表面一个地方射出（如玉石、人的皮肤、水母等）；</p>
</li>
<li><p><strong><font color="red">Subsurface Scattering</font></strong></p>
<p><img src="/2022/10/03/Games101_17_18_Materials/SSS.png" alt="SSS"></p>
<ul>
<li><p><strong>BSSRDF：</strong> 对BRDF的延伸，一点出射方向的贡献不止有该点，还有周围点的贡献（多了对面积的积分）</p>
<p><img src="/2022/10/03/Games101_17_18_Materials/BSSRDF.png" alt="BSSRDF"></p>
</li>
</ul>
</li>
<li><p><strong>Dipole Approximation</strong>（模拟次表面散射的一种方法）</p>
<ul>
<li><p>材质下加入一个光源，材质上也加入一个虚拟光源</p>
<p><img src="/2022/10/03/Games101_17_18_Materials/Dipole Approximation.png" alt="Dipole Approximation"></p>
</li>
</ul>
</li>
</ul>
<h4 id="b-3-2-Cloth"><a href="#b-3-2-Cloth" class="headerlink" title="b.3.2). Cloth"></a>b.3.2). Cloth</h4><p><img src="/2022/10/03/Games101_17_18_Materials/Cloth.png" alt="Cloth"></p>
<ul>
<li><strong>Rendering</strong><ul>
<li>BRDF<img src="/2022/10/03/Games101_17_18_Materials/Cloth_BRDF.png" alt="Cloth_BRDF"></li>
<li>分块，每一块都是Participating Media<img src="/2022/10/03/Games101_17_18_Materials/Cloth_ParticipatingMedia.png" alt="Cloth_ParticipatingMedia"></li>
</ul>
</li>
</ul>
<h4 id="b-3-3-Detailed-Appearance-Motivation"><a href="#b-3-3-Detailed-Appearance-Motivation" class="headerlink" title="b.3.3). Detailed Appearance: Motivation"></a>b.3.3). Detailed Appearance: Motivation</h4><p><img src="/2022/10/03/Games101_17_18_Materials/Detailed Appearance.png" alt="Detailed Appearance"></p>
<p><img src="/2022/10/03/Games101_17_18_Materials/Detailed Appearance_Dn.png" alt="Detailed Appearance_Dn"></p>
<ul>
<li><p>$D(h)$ 过于简单，无法模拟细节</p>
<p><img src="/2022/10/03/Games101_17_18_Materials/Detailed Appearance_Dn02.png" alt="Detailed Appearance_Dn02"></p>
</li>
<li><p>Result</p>
<p><img src="/2022/10/03/Games101_17_18_Materials/Detailed Appearance_Result.png" alt="Detailed Appearance_Result"></p>
</li>
<li><p><img src="/2022/10/03/Games101_17_18_Materials/Detailed Appearance_p_NDFs.png" alt="Detailed Appearance_p_NDFs"></p>
</li>
</ul>
<h3 id="b-4-Procedural-Appearance"><a href="#b-4-Procedural-Appearance" class="headerlink" title="b.4). Procedural Appearance"></a>b.4). Procedural Appearance</h3><p><img src="/2022/10/03/Games101_17_18_Materials/Procedural Appearance.png" alt="Procedural Appearance"></p>
]]></content>
      <categories>
        <category>Games101</category>
      </categories>
      <tags>
        <tag>Games101</tag>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>Games101_21_22 Animation</title>
    <url>/2022/10/03/Games101_21_22_Animation/</url>
    <content><![CDATA[<h1 id="Lecture-21-Animation"><a href="#Lecture-21-Animation" class="headerlink" title="Lecture 21 Animation"></a>Lecture 21 Animation</h1><h2 id="a-History"><a href="#a-History" class="headerlink" title="a). History"></a>a). History</h2><h2 id="b-Keyframe"><a href="#b-Keyframe" class="headerlink" title="b). Keyframe"></a>b). Keyframe</h2><h2 id="c-Physical-Simualtion"><a href="#c-Physical-Simualtion" class="headerlink" title="c). Physical Simualtion"></a>c). Physical Simualtion</h2><p><img src="/2022/10/03/Games101_21_22_Animation/PhysicalBasedAnimation.png" alt="PhysicalBasedAnimation"></p>
<h3 id="c-1-Mass-Spring-System"><a href="#c-1-Mass-Spring-System" class="headerlink" title="c.1). Mass Spring System"></a>c.1). Mass Spring System</h3><p><img src="/2022/10/03/Games101_21_22_Animation/MassSpringSystem_eg00.png" alt="MassSpringSystem_eg00"></p>
<ul>
<li><p><strong>Idealized spring</strong></p>
<p><img src="/2022/10/03/Games101_21_22_Animation/IdealizedSpring.png" alt="IdealizedSpring"></p>
<ul>
<li>但永远不会停止，因此加入摩擦力</li>
</ul>
</li>
</ul>
<hr>
<p><img src="/2022/10/03/Games101_21_22_Animation/DampSpring.png" alt="DampSpring"></p>
<ul>
<li><p>中间项为<strong>相对速度在向量$ab$方向的投影</strong>，因为（处于原长状态时）如果a点不动，b点绕a点做圆周运动，那$f_b=0$；</p>
<ul>
<li><p>但是无法表现剪切力（如对角线拉布，布基本形状不变）、弯曲力（out-of-plane，抗拒被像纸一样完全折叠为两个三角形）等</p>
<p><img src="/2022/10/03/Games101_21_22_Animation/MassSpringSystem_01.png" alt="MassSpringSystem_01"></p>
</li>
</ul>
</li>
<li><p>加入两条对角线，以及skip connection</p>
<p><img src="/2022/10/03/Games101_21_22_Animation/MassSpringSystem_03.png" alt="MassSpringSystem_03"></p>
<ul>
<li>红色较弱，仅其辅助作用；蓝色较强，其主要作用；</li>
</ul>
</li>
<li><p><strong>其他方式：</strong>FEM (Finite Element Method, 有限元) Instead of Springs，考虑力传导</p>
</li>
</ul>
<hr>
<h3 id="c-2-Particle-System"><a href="#c-2-Particle-System" class="headerlink" title="c.2). Particle System"></a>c.2). Particle System</h3><p><img src="/2022/10/03/Games101_21_22_Animation/ParticleSystemForces.png" alt="ParticleSystemForces"></p>
<ul>
<li>粒子系统不仅可描述微小粒子，还可以描述一些群落；<ul>
<li><img src="/2022/10/03/Games101_21_22_Animation/SimulatedFlocking.png" alt="SimulatedFlocking"></li>
<li><img src="/2022/10/03/Games101_21_22_Animation/SimulatedCrowds.png" alt="SimulatedCrowds"></li>
</ul>
</li>
</ul>
<h2 id="d-Forward-Kinematics-FK"><a href="#d-Forward-Kinematics-FK" class="headerlink" title="d). Forward Kinematics(FK)"></a>d). Forward Kinematics(FK)</h2><p><img src="/2022/10/03/Games101_21_22_Animation/FK.png" alt="FK"></p>
<ul>
<li><p>关节（Joint）分类：</p>
<p><img src="/2022/10/03/Games101_21_22_Animation/JointTypes.png" alt="JointTypes"></p>
</li>
</ul>
<h2 id="e-Inverse-Kinematics-IK"><a href="#e-Inverse-Kinematics-IK" class="headerlink" title="e). Inverse Kinematics(IK)"></a>e). Inverse Kinematics(IK)</h2><p><img src="/2022/10/03/Games101_21_22_Animation/IK_eg.png" alt="IK_eg"></p>
<p><img src="/2022/10/03/Games101_21_22_Animation/IK00.png" alt="IK00"></p>
<ul>
<li>解决多个解的方法：梯度下降</li>
</ul>
<h2 id="f-Rigging"><a href="#f-Rigging" class="headerlink" title="f). Rigging"></a>f). Rigging</h2><p><img src="/2022/10/03/Games101_21_22_Animation/Rigging.png" alt="Rigging"></p>
<ul>
<li><p><strong>Blend shapes:</strong> 混合控制点或骨骼位置</p>
<p><img src="/2022/10/03/Games101_21_22_Animation/Blend Shapes.png" alt="Blend Shapes"></p>
</li>
</ul>
<h2 id="g-Motion-Capture-Facial-Motion-Capture"><a href="#g-Motion-Capture-Facial-Motion-Capture" class="headerlink" title="g). Motion Capture / Facial Motion Capture"></a>g). Motion Capture / Facial Motion Capture</h2><hr>
<h1 id="Lecture-22"><a href="#Lecture-22" class="headerlink" title="Lecture 22"></a>Lecture 22</h1><h2 id="a-Single-Particle-Simulation"><a href="#a-Single-Particle-Simulation" class="headerlink" title="a). Single Particle Simulation"></a>a). Single Particle Simulation</h2><p><img src="/2022/10/03/Games101_21_22_Animation/VelocityVectorField.png" alt="VelocityVectorField"></p>
<ul>
<li><p><strong>Velocity vector field:</strong> 给定位置，可以得出改点速度。和磁场、电场类似；</p>
</li>
<li><p><strong>Oridinary Differential Equation(ODE, 常微分方程)</strong></p>
<p><img src="/2022/10/03/Games101_21_22_Animation/Oridinary Differential Equation.png" alt="Oridinary Differential Equation"></p>
<ul>
<li>已知解得 t 时刻，粒子的位置和速度，需求得下一时刻的粒子位置；<ul>
<li>方法1：<strong>显式欧拉法（Explicit Euler method）</strong>，用差分代替微分，但会引起<strong>误差</strong>，且<strong>稳定性差</strong>；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="a-1-Euler’s-Method"><a href="#a-1-Euler’s-Method" class="headerlink" title="a.1). Euler’s Method"></a>a.1). Euler’s Method</h3><p><img src="/2022/10/03/Games101_21_22_Animation/Euler’s Method.png" alt="Euler’s Method"></p>
<ul>
<li><p><strong>缺点：</strong></p>
<ol>
<li><p>存在误差，可通过减小步长（$\Delta t$）来减少误差；</p>
<p><img src="/2022/10/03/Games101_21_22_Animation/Euler’s Method_Errors01.png" alt="Euler’s Method_Errors01"></p>
</li>
<li><p>稳定性差，如速度场为同心圆时，不管步长多小都会<strong>逐渐偏移（diverge）</strong></p>
<p><img src="/2022/10/03/Games101_21_22_Animation/Euler’s Method_Errors02.png" alt="Euler’s Method_Errors02"></p>
</li>
</ol>
</li>
</ul>
<h3 id="a-2-Combating-Instability"><a href="#a-2-Combating-Instability" class="headerlink" title="a.2). Combating Instability"></a>a.2). Combating Instability</h3><p><img src="/2022/10/03/Games101_21_22_Animation/Combating Instability.png" alt="Combating Instability"></p>
<h4 id="a-2-1-Midpoint-Method"><a href="#a-2-1-Midpoint-Method" class="headerlink" title="a.2.1). Midpoint Method"></a>a.2.1). Midpoint Method</h4><p><img src="/2022/10/03/Games101_21_22_Animation/Midpoint Method.png" alt="Midpoint Method"></p>
<ul>
<li>计算下一时刻位置后取中点，得到中点速度，在计算下一时刻位置时，使用中点速度</li>
</ul>
<p><img src="/2022/10/03/Games101_21_22_Animation/Midpoint Method02.png" alt="Midpoint Method02"></p>
<h4 id="a-2-2-Adaptive-Step-Size"><a href="#a-2-2-Adaptive-Step-Size" class="headerlink" title="a.2.2). Adaptive Step Size"></a>a.2.2). Adaptive Step Size</h4><p><img src="/2022/10/03/Games101_21_22_Animation/AdaptiveStepSize.png" alt="AdaptiveStepSize"></p>
<h4 id="a-2-3-Implicit-Euler-Method"><a href="#a-2-3-Implicit-Euler-Method" class="headerlink" title="a.2.3). Implicit Euler Method"></a>a.2.3). Implicit Euler Method</h4><p><img src="/2022/10/03/Games101_21_22_Animation/Implicit Euler Method.png" alt="Implicit Euler Method"></p>
<ul>
<li>使用下一时刻的速度和加速度，并求解</li>
</ul>
<p><img src="/2022/10/03/Games101_21_22_Animation/Quzntize_stability.png" alt="Quzntize_stability">、</p>
<ul>
<li><p><strong>龙格库塔</strong></p>
<p><img src="/2022/10/03/Games101_21_22_Animation/龙格库塔.png" alt="龙格库塔"></p>
</li>
</ul>
<h4 id="a-2-4-Position-Based-Verlet-Integration"><a href="#a-2-4-Position-Based-Verlet-Integration" class="headerlink" title="a.2.4). Position-Based / Verlet Integration"></a>a.2.4). Position-Based / Verlet Integration</h4><ul>
<li>非基于物理<ul>
<li>时间快</li>
</ul>
</li>
</ul>
<p><img src="/2022/10/03/Games101_21_22_Animation/Position-Based.png" alt="Position-Based"></p>
<hr>
<h2 id="b-Rigid-Body-Simulation"><a href="#b-Rigid-Body-Simulation" class="headerlink" title="b). Rigid Body Simulation"></a>b). Rigid Body Simulation</h2><p><img src="/2022/10/03/Games101_21_22_Animation/RigidBodySimulation.png" alt="RigidBodySimulation"></p>
<ul>
<li>与单粒子类似</li>
</ul>
<h2 id="c-Fluid-Simulation"><a href="#c-Fluid-Simulation" class="headerlink" title="c). Fluid Simulation"></a>c). Fluid Simulation</h2><h4 id="c-1-A-Simple-Position-Based-Method"><a href="#c-1-A-Simple-Position-Based-Method" class="headerlink" title="c.1). A Simple Position-Based Method"></a>c.1). A Simple Position-Based Method</h4><p><img src="/2022/10/03/Games101_21_22_Animation/FS_Position-Based.png" alt="FS_Position-Based"></p>
<h3 id="c-2-Eulerian-vs-Lagrangian"><a href="#c-2-Eulerian-vs-Lagrangian" class="headerlink" title="c.2). Eulerian vs. Lagrangian"></a>c.2). Eulerian vs. Lagrangian</h3><p><img src="/2022/10/03/Games101_21_22_Animation/Eulerian vs. Lagrangian.png" alt="Eulerian vs. Lagrangian"></p>
<ul>
<li><p>拉格朗日（质点法）：考虑单个粒子的运动</p>
</li>
<li><p>欧拉（网格法）：考虑不同位置的网格</p>
</li>
<li><p>Material Point Method (MPM ，混合上两种方法)</p>
<p><img src="/2022/10/03/Games101_21_22_Animation/MPM.png" alt="MPM"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Games101</category>
      </categories>
      <tags>
        <tag>Games101</tag>
        <tag>图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>Games202-3 Real-time Environment Mapping</title>
    <url>/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/</url>
    <content><![CDATA[<p><a href="https:/docs.unrealengine.com/en-US/BuildingWorlds/LightingAndShadows/MeshDistanceFields/index.html">Mesh Distance Fields</a>，<a href="https:/cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf">Real Shading in Unreal Engine 4</a></p>
<h1 id="a-Shading-from-Environment-Lighting-IBL"><a href="#a-Shading-from-Environment-Lighting-IBL" class="headerlink" title="a). Shading from Environment Lighting(IBL)"></a>a). Shading from Environment Lighting(IBL)</h1><p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/EnvironmentLight01a.png" alt="EnvironmentLight01a"></p>
<ul>
<li>通过环境贴图着色的方式，又被命名为 <strong>Image-Based Lighting (IBL)</strong></li>
</ul>
<h2 id="a-1-How"><a href="#a-1-How" class="headerlink" title="a.1). How"></a>a.1). How</h2><p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/EnvironmentLight01b.png" alt="EnvironmentLight01b"></p>
<ul>
<li>对于IBL，可以看做是上半球（可以联想下UE中的HDRI）的光照和BRDF的积分；</li>
</ul>
<ul>
<li><p><strong>Observation：</strong></p>
<p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/IBL_BRDF.png" alt="IBL_BRDF"></p>
<ul>
<li><p>对于Glossy，其BRDF支持集很小（Lobe范围小）；</p>
</li>
<li><p>对于Diffuse，其BRDF非常平滑；</p>
</li>
<li><p>联想到上节课渲染方程不等式成立的条件（拆出乘积积分的那个）</p>
<p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/IBL_BRDF02.png" alt="IBL_BRDF02"></p>
<ul>
<li><p>这里$\Omega_{G}$ 指积分域上，$g(x)$有值的区域。</p>
<ul>
<li><p>如$g(x)$ 为BRDF，$\Omega_{G}$ 即为原点向Lobe各点出发，与积分半球相交的区域集合</p>
<p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/IBL_BRDF02b.png" alt="IBL_BRDF02b"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="We-can-safely-take-the-lighting-term-out"><a href="#We-can-safely-take-the-lighting-term-out" class="headerlink" title="We can safely take the lighting term out!"></a>We can safely take the lighting term out!</h3><p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/IBL_BRDF03.png" alt="IBL_BRDF03"></p>
<p>我们把渲染方程分为了两部分积分，分别是：</p>
<ul>
<li>在$\Omega_{fr}$(即Lobe对应的半球区域)，对<strong>光照Radiance积分</strong></li>
<li>在半球内对BRDF积分；</li>
</ul>
<h2 id="a-2-Lighting（对Radiance积分）"><a href="#a-2-Lighting（对Radiance积分）" class="headerlink" title="a.2). Lighting（对Radiance积分）"></a>a.2). Lighting（对Radiance积分）</h2><ul>
<li><p><strong>Lighting：</strong> </p>
<script type="math/tex; mode=display">
\frac{\int_{\Omega_{f_{r}}} L_{i}\left(p, \omega_{i}\right) \mathrm{d} \omega_{i}}{\int_{\Omega_{f_{r}}} \mathrm{~d} \omega_{i}}</script><ul>
<li><p>即在$\Omega_{fr}$(即Lobe对应的半球区域)，对光照Radiance积分，再归一化（normalize，分母用于归一化）；</p>
</li>
<li><p>类比于PCF，就是对Environment Map做滤波；</p>
<p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/IBL_Prefiltering.png" alt="IBL_Prefiltering"></p>
<ul>
<li><strong>滤波方法：Mipmap</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/IBL_Prefiltering02.png" alt="IBL_Prefiltering02"></p>
<ul>
<li><p>在Shading中，需要获得Lighting项的值，只需要求得<strong>Environment Map对应Mipmap层</strong>，<strong>Lobe中点(镜面反射方向)方向</strong>的结果</p>
<ul>
<li>和百人计划图形2.5中，做Relief Mapping时在Unity用到的texCUBElod()，对Mipmap采样联系上了；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fixed3 Reflection = ACESToneMapping(texCUBElod(_CubeMap, float4(worldRef, (255-_Gloss)*8/255)).rgb, 1) * SpecularTint * _EnvIntensity;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="a-3-对BRDF积分（Split-Sum）"><a href="#a-3-对BRDF积分（Split-Sum）" class="headerlink" title="a.3). 对BRDF积分（Split Sum）"></a>a.3). 对BRDF积分（Split Sum）</h2><p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/SplitSum_2.png" alt="SplitSum_2"></p>
<script type="math/tex; mode=display">
\int_{\Omega^+}f_r(p,w_i,w_o)cos\theta_i d\omega_i</script><h3 id="假设使用微表面理论的BRDF"><a href="#假设使用微表面理论的BRDF" class="headerlink" title="假设使用微表面理论的BRDF"></a>假设使用<strong>微表面理论的BRDF</strong></h3><p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/MicrofacetBRDF.png" alt="MicrofacetBRDF"></p>
<ul>
<li><strong>做法：</strong> <strong>预计算</strong>考虑进所有变量（roughness、color等）的可能值的积分；</li>
<li>但是，维度过高，存储成本过高，因此需要降维；</li>
</ul>
<ul>
<li><p><strong>降维过程：</strong></p>
<ol>
<li><p>对应微表面BRDF，只考虑Fresnel term($F(i,h)$)和distribution of normals($D(h)$)</p>
</li>
<li><p>Fresnel term采用<strong>the Schlick’s approximation</strong></p>
<p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/SplitSum_2b.png" alt="SplitSum_2b"></p>
<ul>
<li>至此，积分降维为三维<ul>
<li>$R_0$ ：零度菲涅尔值</li>
<li>$\alpha$ ：可表示为roughness，$\alpha$ 越大，越粗糙；</li>
<li>$\theta(\theta_h)$ ：在实时渲染中，我们认为<strong>出射角</strong>、<strong>入射角</strong>以及<strong>入射角/出射角与半程向量的夹角</strong>，这三者是相同性质的（不是说值近似相等，而是<strong>指作为积分的元素效果相同</strong>）</li>
</ul>
</li>
</ul>
</li>
<li><p>在对BRDF的积分式中，通过Schlick’s approximation，将$R_0$拆出，即写成下列式子</p>
<p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/SplitSum_3.png" alt="SplitSum_3"></p>
<ul>
<li>积分现在被降维为二维（$R_0$被拆出，$f_r$中的菲涅尔项被分母抵消）<ul>
<li>$\alpha$ </li>
<li>$\theta$ </li>
</ul>
</li>
</ul>
</li>
<li><p>至此，我们对积分的两项分别进行预计算，储存在表格或者图片中（R、G通道分别两项积分结果）通过LUT查询即可</p>
<p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/SplitSum_4.png" alt="SplitSum_4"></p>
<ul>
<li>而$R_0$ 则可通过BaseColor（Metallic Workflow）、Specular（Specular Workflow）贴图或软件内置（一般默认为4%）即可获得；（看百人计划美术 2.7 Metallic与Speculer流程）</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>名字由来：</strong> Split sum</p>
<p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/SplitSum_0.png" alt="SplitSum_0"></p>
</li>
</ul>
<h3 id="假设使用Lambert的BRDF"><a href="#假设使用Lambert的BRDF" class="headerlink" title="假设使用Lambert的BRDF"></a>假设使用Lambert的BRDF</h3><script type="math/tex; mode=display">
\int_{\Omega^+}f_r(p,w_i,w_o)cos\theta_i d\omega_i</script><ul>
<li>$f_r = {1\over \pi}$</li>
<li>$\int_{\Omega^+}cos\theta_i d\omega_i = \pi$ （看Games101 Lecture 17-18 Materials二重积分）</li>
<li>所以正好BRDF积分为1</li>
</ul>
<hr>
<h1 id="b-Shadow-from-Environment-Light"><a href="#b-Shadow-from-Environment-Light" class="headerlink" title="b). Shadow from Environment Light"></a>b). Shadow from Environment Light</h1><ul>
<li><p>在实时渲染中，没有完美的解决方案；</p>
<p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/IBL_Shadow.png" alt="IBL_Shadow"></p>
<ul>
<li>难以用实时渲染方程（那个不等式）来近似：<ul>
<li>Support大，为整个半球</li>
<li>带有Gloosy项，不够smooth</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>工业界方法：</strong></p>
<ul>
<li>只计算最亮的灯光（如UE中HDRI带一个Direction Light）</li>
</ul>
</li>
<li>Related research <ul>
<li>Imperfect shadow maps</li>
<li>Light cuts</li>
<li>RTRT (Real-Time Ray Tracing, might be the ultimate solution)</li>
<li><strong>Precomputed radiance transfer(PRT)</strong></li>
</ul>
</li>
</ul>
<h1 id="c-Spherical-Harmonics-SH-球面谐波函数"><a href="#c-Spherical-Harmonics-SH-球面谐波函数" class="headerlink" title="c). Spherical Harmonics(SH, 球面谐波函数)"></a>c). Spherical Harmonics(SH, 球面谐波函数)</h1><h2 id="c-1-前置知识"><a href="#c-1-前置知识" class="headerlink" title="c.1). 前置知识"></a>c.1). 前置知识</h2><h3 id="Fourier-Transform"><a href="#Fourier-Transform" class="headerlink" title="Fourier Transform"></a>Fourier Transform</h3><p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/FourierTransform.png" alt="FourierTransform"></p>
<ul>
<li><p>这里是偶函数，所以 $sin$ 项系数都为0</p>
<p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/FourierTransform_Freq.png" alt="FourierTransform_Freq"></p>
</li>
</ul>
<h3 id="Convolution-Theorem"><a href="#Convolution-Theorem" class="headerlink" title="Convolution Theorem"></a>Convolution Theorem</h3><p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/Convolution.png" alt="Convolution"></p>
<ul>
<li><strong>时域卷积等于频域乘积</strong></li>
</ul>
<h3 id="A-general-understanding"><a href="#A-general-understanding" class="headerlink" title="A general understanding"></a>A general understanding</h3><p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/A general understanding_Basic.png" alt="A general understanding_Basic"></p>
<ul>
<li><p><strong>product intergral:</strong> 相乘后积分，对应离散的情况就是相乘后相加。如：</p>
<ul>
<li><p>$n$维向量$\bold{a} = (x_1, x_2,…,x_n)$ 和 $\bold{b} = (y_1, y_2,…,y_n)$ 进行product intergral，即点乘</p>
<p>$\bold{a} \cdot \bold{b} = x_1y_1+x_2y_2+…+x_ny_n$</p>
</li>
</ul>
</li>
<li><p>我们认为，<strong>函数相乘后积分（product intergral），就是滤波（卷积）</strong></p>
</li>
<li>积分结果的频率，取决于频率最低的项（$f(x),g(x)$）</li>
</ul>
<h3 id="Basis-Functions（基函数）"><a href="#Basis-Functions（基函数）" class="headerlink" title="Basis Functions（基函数）"></a>Basis Functions（基函数）</h3><p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/BasisFunc.png" alt="BasisFunc"></p>
<ul>
<li>$c_i$ 为系数</li>
<li>如傅里叶变换中，各项就为正交基；</li>
<li>或者多项式和泰勒展开等</li>
</ul>
<h2 id="c-2-简介"><a href="#c-2-简介" class="headerlink" title="c.2). 简介"></a>c.2). 简介</h2><h3 id="What？"><a href="#What？" class="headerlink" title="What？"></a>What？</h3><ul>
<li><p><strong>球谐函数</strong> 是<strong>一系列</strong> <strong>二维球面函数的正交基函数</strong></p>
<ul>
<li><strong>球谐函数具有正交、归一、完备性</strong></li>
</ul>
<p>如</p>
<script type="math/tex; mode=display">
f(\omega)=\sum_{i} c_{i} \cdot B_{i}(\omega)</script><ul>
<li><p>$f(\omega)$ 为球面函数，$\omega$ 为向量</p>
</li>
<li><p>$c_i$ 为系数</p>
</li>
<li><p>$B_{i}(\omega)$ 则为球谐函数</p>
<p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/SH_01a.png" alt="SH_01a"></p>
<ul>
<li><strong>说明：</strong><ol>
<li>每一行（$l=n$），频率相同</li>
<li>对于$l=n$行（第$n$阶），函数数量为$2l+1$</li>
<li>每一阶各SH都有编号，即$m$ 从$-l$ 到 $l$；</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="How？"><a href="#How？" class="headerlink" title="How？"></a>How？</h3><ul>
<li><p>每一阶的SH函数，由<strong>勒让德多项式</strong>求得；</p>
</li>
<li><p>如何求得$c_i$ </p>
<ul>
<li><p>投影（Projection）</p>
<p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/SH_01b.png" alt="SH_01b"></p>
<ul>
<li>类似于傅里叶展开中，函数和各个正交基相乘求系数</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="c-3-性质"><a href="#c-3-性质" class="headerlink" title="c.3). 性质"></a>c.3). 性质</h2><p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/SH_BasisFunc.png" alt="SH_BasisFunc"></p>
<ul>
<li>正交性；</li>
<li>投影性；</li>
<li>旋转方便（旋转$f(x)$，相当于旋转基函数$B(i)$）<ul>
<li>SH中，旋转后的基函数，可通过同阶的基函数线性组合得到；</li>
</ul>
</li>
</ul>
<h1 id="d-Shading-from-Environment-Lighting-SH-Diffuse项"><a href="#d-Shading-from-Environment-Lighting-SH-Diffuse项" class="headerlink" title="d). Shading from Environment Lighting(SH, Diffuse项)"></a>d). Shading from Environment Lighting(SH, Diffuse项)</h1><h2 id="d-1-简介"><a href="#d-1-简介" class="headerlink" title="d.1). 简介"></a>d.1). 简介</h2><p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/EnvironmentLight01b.png" alt="EnvironmentLight01b"></p>
<p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/SH_Shading.png" alt="SH_Shading"></p>
<ul>
<li>如果不通过IBL方式，计算shading，<strong>那可以通过SH展开$L_i(p,\omega_i)$ ，即展开Environment Map（</strong>Environment Map可以写成二维函数）</li>
</ul>
<h2 id="d-2-分析Diffuse项的BRDF"><a href="#d-2-分析Diffuse项的BRDF" class="headerlink" title="d.2). 分析Diffuse项的BRDF"></a>d.2). 分析Diffuse项的BRDF</h2><p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/SH_Shading02.png" alt="SH_Shading02"></p>
<ul>
<li>$A_l$ 就是基函数的系数；</li>
<li>由图可见，通过SH分析Diffuse项的BRDF后，可得出结论<ul>
<li>当$l\geq3$ (即第四阶开始)，其 $A_l$ 接近0，说明Diffuse项的BRDF频率低，由SH前三阶表示即可；</li>
</ul>
</li>
</ul>
<blockquote>
<p>积分结果的频率，取决于频率最低的项（$f(x),g(x)$）</p>
</blockquote>
<ul>
<li><strong>Diffuse BRDF acts like a low-pass filter</strong></li>
<li>因此，对于Environment Map的展开，只需要SH前三阶即可</li>
</ul>
<h2 id="d-3-SH展开Environment-Map"><a href="#d-3-SH展开Environment-Map" class="headerlink" title="d.3). SH展开Environment Map"></a>d.3). SH展开Environment Map</h2><p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/SH_Shading03.png" alt="SH_Shading03"></p>
<p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/SH_Shading04.png" alt="SH_Shading04"></p>
<ul>
<li>通过求得各球谐函数的结果后，再通过结果逆变换得到Shading结果<ul>
<li>通过ShadingPoint法线，再经过一系列计算（？）得到shading</li>
</ul>
</li>
</ul>
<h1 id="e-Precomputed-Radiance-Transfer"><a href="#e-Precomputed-Radiance-Transfer" class="headerlink" title="e). Precomputed Radiance Transfer"></a>e). Precomputed Radiance Transfer</h1><p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/PRT_01a.png" alt="PRT_01a"></p>
<ul>
<li>对于渲染方程，如果我们把它每一项都进行Brute-force（蛮力）计算<ul>
<li>$L_i$ : 二维，方位角$\omega$和俯仰角$\theta$</li>
<li>$V(i)$ : 二维，方位角和俯仰角</li>
<li>$\rho(\mathbf{i}, \mathbf{o})$ : 四维，入射角和出射角的方位角和俯仰角</li>
</ul>
</li>
<li>存储压力过于大；</li>
</ul>
<h2 id="e-1-PRT"><a href="#e-1-PRT" class="headerlink" title="e.1). PRT"></a>e.1). PRT</h2><ul>
<li><strong>前提：</strong> 假设场景中除了Lighting，其他都不变；</li>
</ul>
<p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/PRT_01b.png" alt="PRT_01b"></p>
<ul>
<li>将RE分为两项，<ul>
<li>Lighting变化；</li>
<li>light transport不变；<ul>
<li>$V(i): $ 二维，$\omega,\theta$，可烘焙为图像，如CubeMap（场景摆放固定）</li>
<li>$\rho(\mathbf{i}, \mathbf{o}): $ <strong>BRDF</strong><ul>
<li><strong>Diffuse Case:</strong> 常数</li>
<li><strong>Gloosy Case:</strong> 四维，$\omega_{i},\theta_i, \omega_o,\theta_o$，入射和出射的方位角和俯仰角（相机固定，入射角固定）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="e-2-Diffuse-Case"><a href="#e-2-Diffuse-Case" class="headerlink" title="e.2). Diffuse Case"></a>e.2). Diffuse Case</h2><p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/PRT_DiffuseCase01.png" alt="PRT_DiffuseCase01"></p>
<ul>
<li><p>此处（图形学中，大部分情况都是），积分和求和位置可变；</p>
</li>
<li><p>经过预计算后，求得Shading结果只需要<strong>在SH空间中，对向量进行点乘即可</strong>；</p>
<p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/PRT_02b.png" alt="PRT_02b"></p>
</li>
</ul>
<p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/PRT_02.png" alt="PRT_02"></p>
<hr>
<p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/PRT_03.png" alt="PRT_03"></p>
<h3 id="e-2-1-计算"><a href="#e-2-1-计算" class="headerlink" title="e.2.1). 计算"></a>e.2.1). 计算</h3><p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/PRT_DiffuseCase02.png" alt="PRT_DiffuseCase02"></p>
<p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/PRT_DiffuseCase03.png" alt="PRT_DiffuseCase03"></p>
<ul>
<li><strong>注意：</strong> 此处两次求和复杂度仍然是$O(n)$，因为SH基函数具有正交性；</li>
</ul>
<ul>
<li><p><strong>Runtime is independent of transport complexity</strong></p>
<p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/PRT_LightTrans.png" alt="PRT_LightTrans"></p>
</li>
</ul>
<ul>
<li><p><strong>计算Light Transport简易理解：</strong> 积分形式和渲染方程相似，$B_i(\bold{i})$ 类似于$L_i(\bold{i})$ ，可看成是将球谐函数作为光照进行Shading得到Light Transport结果</p>
<p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/PRT_LightTrans02.png" alt="PRT_LightTrans02"></p>
</li>
</ul>
<h2 id="e-3-Glossy-Case"><a href="#e-3-Glossy-Case" class="headerlink" title="e.3). Glossy Case"></a>e.3). Glossy Case</h2><p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/PRT_GlossyCase.png" alt="PRT_GlossyCase"></p>
<ul>
<li>此时，BRDF是关于入射和出射的方位角和俯仰角的四维函数；</li>
<li><strong>做法：</strong> 对 $\bold{o}$ 也进行SH展开；（对于Gloosy不止展开到第三阶）<ul>
<li>light coefficient与Diffuse Case相同，为SH空间的一维向量；</li>
<li>transport matrix则是关于  $\bold{o}$ 和 $\bold{i}$ 四维函数（入射和出射的方位角和俯仰角），为SH空间的二维矩阵；</li>
<li>reflected radiance coefficient则是关于 $\bold{o}$ 的二维函数（出射角的方位角和俯仰角），通过SH逆变换，即可得出相应视角（ $\bold{o}$ ）下的Gloosy radiance；<ul>
<li><font color="red">具体怎么变换的？待实现</font>



</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="e-4-总结和限制"><a href="#e-4-总结和限制" class="headerlink" title="e.4). 总结和限制"></a>e.4). 总结和限制</h2><p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/PRT_Summary.png" alt="PRT_Summary"></p>
<p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/PRT_Limitations.png" alt="PRT_Limitations"></p>
<hr>
<h1 id="f-Wavelet-小波"><a href="#f-Wavelet-小波" class="headerlink" title="f). Wavelet(小波)"></a>f). Wavelet(小波)</h1><p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/Wavelet01.png" alt="Wavelet01"></p>
<ul>
<li><p>定义在二维平面上的一系列基函数</p>
</li>
<li><p><strong>A non-linear approximation:</strong> 二维函数经过小波变换后，大部分系数接近0，这时可采用只记录系数大于一定值的项来近似原函数；</p>
<p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/Wavelet02.png" alt="Wavelet02"></p>
<ul>
<li>对于Environment Map，小波变换无法变换球面函数，因此展开为Cubemap后进行小波变换；</li>
<li>每一个矩形经过小波变换后，把<strong>高频信息</strong>放在<strong>右上、右下、左下</strong>子块，剩下的<strong>低频信息</strong>放在<strong>左上</strong>，继续做小波变换；</li>
</ul>
</li>
<li><p><strong>其他应用：</strong>JPG格式图片压缩， 使用类似与小波变换的DCT（Discrete cosine transform，离散余弦变换）、JPEG2000</p>
</li>
<li><p><strong>效果对比：</strong></p>
<p><img src="/2023/02/01/Games202_03_Real-time%20Environment%20Mapping/Wavelet03.png" alt="Wavelet03"></p>
</li>
<li><p><strong>缺点：</strong> </p>
<ul>
<li>旋转不方便（不同于SH基函数的旋转简易型，小波旋转需要从Wavelet展开，旋转后再做小波变换）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Games202</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>Games202</tag>
      </tags>
  </entry>
  <entry>
    <title>Games202-1 Recap of CG Basics</title>
    <url>/2023/02/01/Games202_01_Recap%20of%20CG%20Basics/</url>
    <content><![CDATA[<h1 id="a-Graphics-Pipeline"><a href="#a-Graphics-Pipeline" class="headerlink" title="a). Graphics Pipeline"></a>a). Graphics Pipeline</h1><p><img src="/2023/02/01/Games202_01_Recap%20of%20CG%20Basics/GraphicsPipeline.png" alt="GraphicsPipeline"></p>
<h1 id="b-OpenGL"><a href="#b-OpenGL" class="headerlink" title="b). OpenGL"></a>b). OpenGL</h1><p><img src="/2023/02/01/Games202_01_Recap%20of%20CG%20Basics/OpenGL01a.png" alt="OpenGL01a"></p>
<h2 id="A-Place-objects-models"><a href="#A-Place-objects-models" class="headerlink" title="A. Place objects/models"></a>A. Place objects/models</h2><ul>
<li>Model specification(模型信息)</li>
<li>Model transformation</li>
</ul>
<p><img src="/2023/02/01/Games202_01_Recap%20of%20CG%20Basics/OpenGL_A.png" alt="OpenGL_A"></p>
<h2 id="B-Set-up-an-easel-画架"><a href="#B-Set-up-an-easel-画架" class="headerlink" title="B. Set up an easel(画架)"></a>B. Set up an easel(画架)</h2><ul>
<li>View transformation</li>
<li>Create /use a <strong><font color="red">framebuffer</font></strong></li>
</ul>
<p><img src="/2023/02/01/Games202_01_Recap%20of%20CG%20Basics/OpenGL_B.png" alt="OpenGL_B"></p>
<h2 id="C-Attach-a-canvas-to-the-easel"><a href="#C-Attach-a-canvas-to-the-easel" class="headerlink" title="C. Attach a canvas to the easel"></a>C. Attach a canvas to the easel</h2><p>指定Pass到framebuffer，就和Unity中FS的SV_TARGET一样。</p>
<p><strong>E. you can also paint multiple pictures using the same easel</strong></p>
<ul>
<li><p>一个Rendering <strong>Pass</strong>，使用<strong>一个framebuffer</strong>，渲染一个或多个texture（shading, depth, etc.）作为输出</p>
</li>
<li><p>即一个framebuffer可以绑定多个纹理（MRT）</p>
</li>
<li><p><strong>Multiple Render Target（MRT）</strong>是一种指可以使绘制程序在单帧中同时渲染多个Render Target</p>
</li>
</ul>
<h2 id="D-Paint-to-the-canvas"><a href="#D-Paint-to-the-canvas" class="headerlink" title="D. Paint to the canvas"></a>D. Paint to the canvas</h2><ul>
<li>This is when vertex / fragment shaders will be used</li>
</ul>
<ul>
<li><strong>For each vertex in parallel</strong>     <ul>
<li>OpenGL calls user-specified vertex shader: Transform vertex (ModelView, Projection), other ops </li>
</ul>
</li>
<li>For each primitive, OpenGL rasterizes <ul>
<li>Generates a fragment for each pixel the fragment covers</li>
</ul>
</li>
</ul>
<ul>
<li>For each fragment in parallel <ul>
<li>OpenGL calls user-specified fragment shader: Shading and lighting calculations </li>
<li>OpenGL handles z-buffer depth test unless overwritten</li>
</ul>
</li>
</ul>
<h2 id="Summary-in-each-pass"><a href="#Summary-in-each-pass" class="headerlink" title="Summary: in each pass"></a>Summary: in each pass</h2><ul>
<li><p>Specify objects, camera, MVP, etc. </p>
</li>
<li><p>Specify framebuffer and input/output textures </p>
</li>
<li><p>Specify vertex / fragment shaders </p>
</li>
<li><p><strong>(When you have everything specified on the GPU)</strong> Render</p>
</li>
</ul>
<h1 id="c-Shading-Language-GLSL"><a href="#c-Shading-Language-GLSL" class="headerlink" title="c). Shading Language(GLSL)"></a>c). Shading Language(GLSL)</h1><h2 id="c-1-Initializing"><a href="#c-1-Initializing" class="headerlink" title="c.1). Initializing"></a>c.1). Initializing</h2><ul>
<li><p>Create shader(Vertex and Fragment) </p>
</li>
<li><p>Compile shader</p>
</li>
<li><p>Attach shader to program</p>
</li>
<li><p>Link program</p>
</li>
<li>Use program</li>
</ul>
<p><img src="/2023/02/01/Games202_01_Recap%20of%20CG%20Basics/Shader Initialization Code.png" alt="Shader Initialization Code"></p>
<p><img src="/2023/02/01/Games202_01_Recap%20of%20CG%20Basics/LinkingShaderProgram.png" alt="LinkingShaderProgram"></p>
<h2 id="c-2-Phong-Shader-in-Assignment-0"><a href="#c-2-Phong-Shader-in-Assignment-0" class="headerlink" title="c.2). Phong Shader in Assignment 0"></a>c.2). Phong Shader in Assignment 0</h2><ul>
<li><p><strong>Vertex Shader</strong></p>
<p><img src="/2023/02/01/Games202_01_Recap%20of%20CG%20Basics/VertexShader.png" alt="VertexShader"></p>
<ul>
<li>attribute: 顶点附带的属性，FS中不会出现</li>
<li>uniform: 全局变量，由CPU直接传递给GPU</li>
<li>varying: 需要插值的变量</li>
<li>highp: 高精度</li>
<li>gl_Position: 类似于Unity的SV_Position，裁剪空间中的顶点位置；</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>Fragment Shader</strong></p>
<p><img src="/2023/02/01/Games202_01_Recap%20of%20CG%20Basics/FragmentShader.png" alt="FragmentShader"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Games202</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>Games202</tag>
      </tags>
  </entry>
  <entry>
    <title>Games202-2 Real-Time Shadow</title>
    <url>/2023/02/01/Games202_02_Real-Time%20Shadow/</url>
    <content><![CDATA[<h1 id="a-Shadow-Mapping"><a href="#a-Shadow-Mapping" class="headerlink" title="a). Shadow Mapping"></a>a). Shadow Mapping</h1><ul>
<li>A <strong>2-Pass</strong> Algorithm<ol>
<li>Light pass: Generate the SM(Shadow Map)</li>
<li>Camera pass: uses the SM</li>
</ol>
</li>
<li>An image-space algorithm<ul>
<li>Pro(优点): no knowledge of scene’s geometry is required</li>
<li>Con(缺点): causing <strong>self occlusion(自遮挡)</strong> and <strong>aliasing(走样)</strong> issues</li>
</ul>
</li>
</ul>
<h2 id="Pass-1-Render-from-Light"><a href="#Pass-1-Render-from-Light" class="headerlink" title="Pass 1: Render from Light"></a>Pass 1: Render from Light</h2><ul>
<li>输出一张<strong>光源视角</strong>的<strong>深度图（Depth Buffer）</strong></li>
</ul>
<p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/SM_Pass01.png" alt="SM_Pass01"></p>
<h2 id="Pass-2-Render-from-Eye-Camera"><a href="#Pass-2-Render-from-Eye-Camera" class="headerlink" title="Pass 2: Render from Eye(Camera)"></a>Pass 2: Render from Eye(Camera)</h2><p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/SM_Pass02.png" alt="SM_Pass02"></p>
<ul>
<li><p>将光源视角对应的深度转换到View Space, 与Camera视角的深度进行深度比较；</p>
<ul>
<li>如$Depth_{cam} &gt; Depth_{light}$ ，那说明该点<strong>在阴影中</strong>（相机可见，光源不可见）</li>
<li>如$Depth_{cam} &lt; Depth_{light}$ ，那说明该点在<strong>不在阴影中</strong>（相机可见，光源可见）</li>
</ul>
</li>
<li><p><strong>用于比较的深度值：</strong></p>
<ul>
<li><p>经过透视投影中的Squeez矩阵后（具体看Games101 Math笔记），z会被推向远平面</p>
<p>$M_{\text {persp } \rightarrow \text { ortho }}=\left(\begin{array}{cccc}<br>n &amp; 0 &amp; 0 &amp; 0 \\<br>0 &amp; n &amp; 0 &amp; 0 \\<br>0 &amp; 0 &amp; n+f &amp; -nf \\<br>0 &amp; 0 &amp; 1 &amp; 0<br>\end{array}\right)$</p>
</li>
<li><p>用于比较的$Depth$ 可以是经过MVP中的深度值（即Depth Buffer中的深度值）；</p>
</li>
<li>也可以是该点在同一空间（如模型空间）中，该点到相机/光源的线性距离；</li>
</ul>
</li>
</ul>
<p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/SM_vs.png" alt="SM_vs"></p>
<hr>
<h2 id="a-1-Issues-in-Shadow-Mapping"><a href="#a-1-Issues-in-Shadow-Mapping" class="headerlink" title="a.1). Issues in Shadow Mapping"></a>a.1). Issues in Shadow Mapping</h2><h3 id="a-1-1-Self-occlusion-自遮挡"><a href="#a-1-1-Self-occlusion-自遮挡" class="headerlink" title="a.1.1). Self occlusion(自遮挡)"></a>a.1.1). Self occlusion(自遮挡)</h3><p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/SelfOcclusion.png" alt="SelfOcclusion"></p>
<ul>
<li><strong>Self occlusion：</strong> 阴影自遮挡，造成阴影毛刺的现象；</li>
<li><strong>原因：</strong> 如上图，<ul>
<li>Shadow Map分辨率有限，一个像素内记录的深度值相同。如图中红色和橙色斜线表示Shadow Map中深度相同的位置（$Depth_A = Depth_{A’}$）；</li>
<li>当计算平面中$B$点是否在阴影中时，$Depth_{light} = z1 = Depth_A$，而相机视角下的点$B$转换到光源视角下对应的深度为 $z2$ ，即$Depth_{cam} = z2 = Depth_B$</li>
<li>因此，$Depth_{cam} &gt; Depth_{light}$ ，说明该点<strong>在阴影中</strong>，因此造成Self occlusion</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>解决方法：</strong> 引入<strong>Bias</strong>；</p>
<p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/SelfOcclusion_Bias.png" alt="SelfOcclusion_Bias" style="zoom:50%;"></p>
<ul>
<li>认为对于$B$点，如$Depth_{cam} &gt; Depth_{light}$，但$Depth_{light}$ 处于橙色中，那该点仍然不在阴影中；</li>
<li>即：<ul>
<li>$Depth_{cam} &gt; Depth_{light}+bias$，才使得该点<strong>在阴影中</strong>；</li>
<li>$Depth_{cam} &lt; Depth_{light}+bias$，该点<strong>不在阴影中</strong>；</li>
</ul>
</li>
<li>易得，当光源方向垂直于平面时，所需的Bias最小，因此可引入光源与平面法线的夹角 $cos\alpha$ ，来调整Bias大小；</li>
</ul>
</li>
</ul>
<ul>
<li>引入bias会造成的问题：Detached shadow(不接触阴影，Peter Panning)</li>
</ul>
<h3 id="a-1-2-Detached-shadow"><a href="#a-1-2-Detached-shadow" class="headerlink" title="a.1.2). Detached shadow"></a>a.1.2). Detached shadow</h3><p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/Detached shadow.png" alt="Detached shadow"></p>
<ul>
<li><p><strong>解决方法：</strong></p>
<ul>
<li><p>Second-depth shadow mapping</p>
<p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/Second-depthShadowMapping.png" alt="Second-depthShadowMapping"></p>
</li>
<li><p>工业界实际没什么人用，只是学术界提出的解决方案</p>
</li>
</ul>
</li>
</ul>
<h3 id="a-1-3-Aliasing"><a href="#a-1-3-Aliasing" class="headerlink" title="a.1.3). Aliasing"></a>a.1.3). Aliasing</h3><p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/Aliasing.png" alt="Aliasing"></p>
<h1 id="b-Math"><a href="#b-Math" class="headerlink" title="b). Math"></a>b). Math</h1><h2 id="b-1-Approximation-in-RTR"><a href="#b-1-Approximation-in-RTR" class="headerlink" title="b.1). Approximation in RTR"></a>b.1). Approximation in RTR</h2><ul>
<li><p>RTR中常用的不等式；</p>
<p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/Approximation in RTR.png" alt="Approximation in RTR"></p>
<ul>
<li>该不等式“准确”的条件：<ol>
<li><strong>Support（支撑集，积分的范围）足够小时；</strong></li>
<li><strong>$g(x)$ 足够光滑（指频率低，起伏小）</strong></li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="b-2-渲染方程的不等式"><a href="#b-2-渲染方程的不等式" class="headerlink" title="b.2). 渲染方程的不等式"></a>b.2). 渲染方程的不等式</h2><p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/ApproximationinRTR_ShadowMap.png" alt="ApproximationinRTR_ShadowMap"></p>
<ul>
<li>$V(p,\omega_i)$为Visibility，阴影因子；</li>
<li>单独拆出Visibility，即<strong>先做shading，后做Visibility，最后相乘</strong></li>
</ul>
<h2 id="b-3-in-Shadow-Mapping"><a href="#b-3-in-Shadow-Mapping" class="headerlink" title="b.3). in Shadow Mapping"></a>b.3). in Shadow Mapping</h2><p>什么情况下，Shadow Mapping（先着色，后计算阴影）是准确的；</p>
<h3 id="Small-support"><a href="#Small-support" class="headerlink" title="Small support"></a>Small support</h3><p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/ShadowMappingApproximation.png" alt="ShadowMappingApproximation"></p>
<ul>
<li>在计算阴影中，支撑集小，意味着光源小；</li>
<li>因此，对于<strong>点光源</strong>和<strong>方向光源</strong>，做Shadow Mapping硬阴影结果是准确的；</li>
</ul>
<h3 id="Smooth-integrand"><a href="#Smooth-integrand" class="headerlink" title="Smooth integrand"></a>Smooth integrand</h3><p>对于不等式处理后的渲染方程，$g(x)$ 代表光照。</p>
<ul>
<li>当<strong>$g(x)$ 足够光滑（指频率低，起伏小）</strong>，不等式为准确的；</li>
<li>$L_i$ 光滑，对应光源为<strong>面光源</strong>；</li>
<li>BRDF，即$f_r$ 光滑，对应<strong>Diffuse项</strong>；</li>
<li>即对于光源为面光源的Diffuse项，不等式处理后的渲染方程是准确的；</li>
</ul>
<h1 id="c-PCSS-Percentage-Closer-Soft-Shadow"><a href="#c-PCSS-Percentage-Closer-Soft-Shadow" class="headerlink" title="c). PCSS(Percentage-Closer Soft Shadow)"></a>c). PCSS(Percentage-Closer Soft Shadow)</h1><p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/PCSS.png" alt="PCSS"></p>
<h2 id="c-1-PCF-Percentage-Closer-Filtering"><a href="#c-1-PCF-Percentage-Closer-Filtering" class="headerlink" title="c.1). PCF(Percentage Closer Filtering)"></a>c.1). PCF(Percentage Closer Filtering)</h2><ul>
<li>PCF用于抗锯齿，而不用于软阴影（用于软阴影的叫PCSS，两者实质是一个东西，但应用不同叫法不同）</li>
<li>在<strong>生成Shadow Map后，阴影比较时（即对阴影比较的结果）</strong>，进行Filtering<ul>
<li>面光源生成Shadow Map：以面光源的中心点(放置相机)生成shadow map</li>
</ul>
</li>
</ul>
<p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/PCF.png" alt="PCF"></p>
<ul>
<li><p><strong>做法：</strong> 不止对着色点与其在Shadow Map中的对应点进行深度比较，而是<strong>着色点深度</strong>与其<strong>在Shadow Map中对应点及其周围点深度</strong>进行比较，最后<strong>对各个Visibility的结果取平均值</strong>（或加权平均）</p>
<ul>
<li><strong>eg1</strong>. $P$点在Cam视角下深度为$Depth_p$，转换到光源视角下深度为$Depth_{p’}$，$Depth_{p’}$ 与其在Shadow Map中对应点周围3x3（<strong>Filter size</strong>）像素进行比较，得到结果<script type="math/tex; mode=display">
\begin{array}{l}
1,0,1 \\
1,0,1 \\
1,1,0
\end{array}</script>取平均得到Visibility为 0.667</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Filter size</strong><ul>
<li>Small -&gt; sharper</li>
<li>Large -&gt; softer</li>
<li>为选取合适的Filter size，产生了PCSS</li>
</ul>
</li>
</ul>
<h2 id="c-2-PCSS-Percentage-Closer-Soft-Shadow"><a href="#c-2-PCSS-Percentage-Closer-Soft-Shadow" class="headerlink" title="c.2). PCSS(Percentage-Closer Soft Shadow)"></a>c.2). PCSS(Percentage-Closer Soft Shadow)</h2><h3 id="c-2-1-什么是PCSS？"><a href="#c-2-1-什么是PCSS？" class="headerlink" title="c.2.1). 什么是PCSS？"></a>c.2.1). 什么是PCSS？</h3><ul>
<li><strong>关键：</strong> 自适应Filter size</li>
</ul>
<p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/PCSS01.png" alt="PCSS01"></p>
<ul>
<li>观察可得：<ul>
<li>钢笔（Blocker）与接收平面（Receiver）的距离越小（笔尖），阴影越硬</li>
<li>钢笔（Blocker）与接收平面（Receiver）的距离越大（笔尖），阴影越软</li>
</ul>
</li>
<li>即阴影的软硬程度，一部分取决于Blocker和Receiver的距离</li>
</ul>
<hr>
<p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/PCSS_Key.png" alt="PCSS_Key"></p>
<ul>
<li><p>阴影的软硬取决于</p>
<ul>
<li>$w_{Light}$ （光源的宽度）</li>
<li>$d_{Blocker}$ 与 $d_{BtoR}$ 的比值；</li>
</ul>
</li>
<li><p><strong>Blocker定义：</strong></p>
<p>Shading point变换到Light视角，对应深度为$Depth_{scene}$ 。<strong>查询区域内</strong>，深度值$z &lt; Depth_{scene}$ 的texel即为Blocker；</p>
</li>
<li><p>$d_{Blocker}$ 为 <strong>Average blocker distance</strong></p>
<ul>
<li><p><strong>Average blocker distance：</strong> Shadow Map一定范围内的Blocker的深度平均值</p>
</li>
<li><p>类似eg1</p>
<blockquote>
<p><strong>eg1</strong>. $P$点在Cam视角下深度为$Depth_p$，转换到光源视角下深度为$Depth_{p’}$，$Depth_{p’}$ 与其在Shadow Map中对应点周围3x3（<strong>Filter size</strong>）像素进行比较，得到结果</p>
<script type="math/tex; mode=display">
\begin{array}{l}
1,0,1 \\
1,0,1 \\
1,1,0
\end{array}</script><p>取平均得到Visibility为 0.667</p>
</blockquote>
<p>其中，Visibility为0的点，即 处于阴影中，$Depth_{cam} &gt; Depth_{light}+bias$ 的点即为Blocker，对Blocker在Shadow Map中的深度值取平均值，即得到Average blocker distance</p>
</li>
</ul>
</li>
</ul>
<h3 id="c-2-2-做法"><a href="#c-2-2-做法" class="headerlink" title="c.2.2). 做法"></a>c.2.2). 做法</h3><p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/PCSS_How.png" alt="PCSS_How"></p>
<p>首先将shading point点$x$投应到shadow map上,找到其对应的像素点$P$。PCSS算法的实现流程如下：</p>
<p>第一步：Blocker search，即获取<strong>某个区域</strong>的平均遮挡物深度（在点p附近取一个范围(这个范围是自己定义或动态计算的),将范围内各像素的最小深度与x的实际深度比较,从而判断哪些像素是遮挡物，把所有遮挡物的深度记下来取个平均值作为blocker distance。）</p>
<p>第二步：Penumbra estimation，使用平均遮挡物深度计算滤波核尺寸（用取得的遮挡物深度距离来算在PCF中filtering的范围。）</p>
<script type="math/tex; mode=display">
w_{\text {Penumbra }}=\left(d_{\text {Receiver }}-d_{\text {Blocker }}\right) \cdot w_{\text {Light }} / d_{\text {Blocker }}</script><p>第三步：Percentage Closer Filtering，对应该滤波核尺寸应用PCF算法。</p>
<ul>
<li>如何动态计算Blocker search的<strong>“某个范围”</strong><ul>
<li><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/PCSS_Region.png" alt="PCSS_Region"></li>
<li>Light越远，Region越小；Light越近，Region越大；（好像和图不太对应，如非要对应，就类似与Shadow Map位置不变，Light距离变大/小）</li>
</ul>
</li>
</ul>
<h4 id="那么PCSS中那些步骤会导致速度变慢？"><a href="#那么PCSS中那些步骤会导致速度变慢？" class="headerlink" title="那么PCSS中那些步骤会导致速度变慢？"></a>那么PCSS中那些步骤会导致速度变慢？</h4><ul>
<li><p>第一步：Blocker search，需要多次采样查询深度信息并比较，计算Blocker的平均深度$d_{Blocker}$</p>
</li>
<li><p>第三步：PCF，阴影越软→滤波核尺寸越大→采样查询次数变多→速度变慢</p>
<ul>
<li>由此可见，主要是多次采样并比较的方法使得速度变慢；</li>
</ul>
</li>
<li><p><strong>加速方法：</strong></p>
<ul>
<li>随机采样，后降噪；</li>
</ul>
<blockquote>
<p>如果觉得区域过大不想对每一个texels都进行比较,就可以通过随机采样其中的texels，而不是全部采样，会得到一个近似的结果,近似的结果就可能会导致出现噪声。工业的处理的方式就是先稀疏采样得到一个有噪声的visibility的图,接着再在图像空间进行降噪。</p>
</blockquote>
<ul>
<li><strong>Variance Soft Shadow Mapping(VSSM)</strong></li>
</ul>
</li>
</ul>
<hr>
<h3 id="c-2-3-Math"><a href="#c-2-3-Math" class="headerlink" title="c.2.3). Math"></a>c.2.3). Math</h3><p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/PCF_02.png" alt="PCF_02"></p>
<script type="math/tex; mode=display">
V(x)=\sum_{q \in \mathcal{N}(p)} w(p, q) \cdot \chi^{+}\left[D_{\mathrm{SM}}(q)-D_{\text {scene }}(x)\right]</script><ul>
<li>其中$\chi^{+}$ 类似于$step()$ 函数<ul>
<li>$D_{\mathrm{SM}}(q)-D_{\text {scene }}(x) \geq 0$， 即$Depth_{ShadowMap} \geq Depth_{cam}$，$\chi^{+}\left[D_{\mathrm{SM}}(q)-D_{\text {scene }}(x)\right] = 1$</li>
<li>$D_{\mathrm{SM}}(q)-D_{\text {scene }}(x) &lt; 0$， 即$Depth_{ShadowMap} &lt; Depth_{cam}$，$\chi^{+}\left[D_{\mathrm{SM}}(q)-D_{\text {scene }}(x)\right] = 0$</li>
</ul>
</li>
</ul>
<hr>
<h1 id="d-Variance-Soft-Shadow-Mapping-VSSM"><a href="#d-Variance-Soft-Shadow-Mapping-VSSM" class="headerlink" title="d). Variance Soft Shadow Mapping(VSSM)"></a>d). Variance Soft Shadow Mapping(VSSM)</h1><ul>
<li><strong>vs PCSS: </strong> Fast blocker search(step 1) and filtering(step 3)</li>
<li><strong>关键思想：</strong> 只用知道有多少（百分比）的 texels 在着色点前面；</li>
</ul>
<h2 id="d-1-Solve-step3-PCF"><a href="#d-1-Solve-step3-PCF" class="headerlink" title="d.1). Solve step3(PCF)"></a>d.1). Solve step3(PCF)</h2><p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/VSSM_01.png" alt="VSSM_01"></p>
<ul>
<li><p>通过<strong>正态分布（Normal distribution）</strong>，求得着色点的深度在采样点中大概的排位，即可得到<strong>近似</strong>的结果；</p>
<ul>
<li><p>需要定义一个正态分布，需要得知其<strong>均值（mean）</strong>和<strong>方差（variance）</strong></p>
</li>
<li><p><strong>Mean:</strong></p>
<ol>
<li>Hardware MIPMAPing (快，但不一定准确);</li>
<li>Summed Area Tables (SAT, 积分表);</li>
</ol>
</li>
<li><strong>Variance:</strong><ul>
<li>$Var(X) = E(X^2)-E^2(X)$ ，方差等于平方的均值（均方值）减去均值的平方；</li>
<li>只需要在Depth Buffer的空余通道中多存储一个$depth^2$；</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>通过求正态分布$P(x&gt;Depth_{cam}) (Depth_{cam}为着色点转换到光源视角的深度)$ 的面积，即求CDF（<strong>累积分布函数</strong> ）即可求得<em>Visibility</em></p>
<p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/VSSM_CDF.png" alt="VSSM_CDF"></p>
<ul>
<li>CDF(x) 求解：<ol>
<li>查表；</li>
<li>切比雪夫不等式；</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>切比雪夫不等式</strong>（并不需要知道具体的分布情况，而是通过不等式直接得出，如使用切比雪夫就不用正态分布，只需要求得<strong>均值</strong>和<strong>方差</strong>即可，但是也需要分布情况较为简单）</p>
<p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/VSSM_Chebychev.png" alt="VSSM_Chebychev"></p>
<ul>
<li>通过近似值约等出Visibility的结果，即红色面积；<ul>
<li>（准确的条件：）$t\geq mean$ （但一般不管这个，就理解成约等就行）</li>
</ul>
</li>
<li>至此解决了Step3</li>
</ul>
</li>
</ul>
<h2 id="d-2-Solve-step1"><a href="#d-2-Solve-step1" class="headerlink" title="d.2). Solve step1"></a>d.2). Solve step1</h2><p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/VSSM_step01.png" alt="VSSM_step01"></p>
<p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/VSSM_step01b.png" alt="VSSM_step01b"></p>
<ul>
<li><p>Shading point转换到光源下，</p>
</li>
<li><p><strong>关键式：</strong></p>
<script type="math/tex; mode=display">
\frac{N_{1}}{N} z_{\text {unocc }}+\frac{N_{2}}{N} z_{o c c}=z_{\text {Avg }}</script><ul>
<li>$\frac{N_{1}}{N} = P(x&gt;t)$ ，通过切比雪夫不等式求出；</li>
<li>$\frac{N_{2}}{N} = 1-P(x&gt;t)$</li>
<li>$z_{Avg}$：SM中，采样范围深度均值</li>
<li>$z_{unocc}$：近似等于$t$</li>
<li><strong>最终</strong>，由关键式得出$ z_{o c c}$</li>
</ul>
</li>
</ul>
<h2 id="d-3-Summed-Area-Tables-SAT-积分表"><a href="#d-3-Summed-Area-Tables-SAT-积分表" class="headerlink" title="d.3). Summed Area Tables (SAT, 积分表)"></a>d.3). Summed Area Tables (SAT, 积分表)</h2><p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/SAT_1D.png" alt="SAT_1D"></p>
<ul>
<li>SAT为数据结构，使用前缀和算法</li>
</ul>
<p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/SAT_2D.png" alt="SAT_2D"></p>
<ul>
<li>2D的SAT：每一个点记录左上角区域的和；<ul>
<li>先计算一行的一维SAT；</li>
<li>再对计算后的SAT进行列方向的累加，求出二维的SAT；</li>
</ul>
</li>
<li>求蓝色区域和只需要查询四次SAT即可；</li>
<li>SAT的并行性：<ul>
<li>由于先进行行方向SAT计算，后进行列方向SAT计算，具有一定的并行性；</li>
</ul>
</li>
</ul>
<h2 id="d-4-缺陷"><a href="#d-4-缺陷" class="headerlink" title="d.4). 缺陷"></a>d.4). 缺陷</h2><p>由于使用了切比雪夫不等式或正态分布，隐含了<strong>Shadow Map中对应范围的深度分布要较为简单或接近正态分布</strong></p>
<p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/VSSM_Con.png" alt="VSSM_Con"></p>
<ul>
<li>如上右图，分布主要集中在三个值，过于离散，造成VSSM不准确；</li>
</ul>
<p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/VSSM_Con2.png" alt="VSSM_Con2"></p>
<ul>
<li><p><strong>Light leaking（漏光）</strong></p>
<p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/VSSM_LightLeaking.png" alt="VSSM_LightLeaking"></p>
</li>
</ul>
<h1 id="e-Moment-Shadow-Mapping-MSM"><a href="#e-Moment-Shadow-Mapping-MSM" class="headerlink" title="e). Moment Shadow Mapping(MSM)"></a>e). Moment Shadow Mapping(MSM)</h1><ul>
<li><p>VSSM不够准确，需要用更高的<strong>矩（Moment）</strong>来描述PCF（Use <strong>higher order moments</strong> to represent a distribution）</p>
</li>
<li><p><strong>矩（Moments）：</strong></p>
<ul>
<li><p>Quite a few variations on the definition</p>
</li>
<li><p>We use the simplest:</p>
<p>$x,x^2,x^3,x^4,…$</p>
</li>
<li><p>VSSM中，我们用到了二阶矩（$depth^2$）</p>
</li>
<li>有点类似于展开（比如泰勒展开）；</li>
</ul>
</li>
</ul>
<p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/MSM_Moments.png" alt="MSM_Moments"></p>
<p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/MSM_ProAndCons.png" alt="MSM_ProAndCons"></p>
<h1 id="f-Distance-Field-Soft-Shadow-SDF-有向距离场"><a href="#f-Distance-Field-Soft-Shadow-SDF-有向距离场" class="headerlink" title="f). Distance Field Soft Shadow(SDF, 有向距离场)"></a>f). Distance Field Soft Shadow(SDF, 有向距离场)</h1><h2 id="f-1-Distance-functions"><a href="#f-1-Distance-functions" class="headerlink" title="f.1). Distance functions"></a>f.1). Distance functions</h2><ul>
<li><p><strong>定义：</strong> 对于空间中任意一点，其值为<strong>到物体的最近距离</strong>。并且可定义其在内部符号（Signed）为负，在外符号为正，即为有向距离场（Signed Distance Functions, SDF）;</p>
<p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/DF.png" alt="DF"></p>
</li>
</ul>
<ul>
<li><p><strong>An Example:</strong> Blending (linear interp.) a moving boundary</p>
<p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/SDF_01.png" alt="SDF_01"></p>
<p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/SDF_02.png" alt="SDF_02"></p>
</li>
<li><p><strong>背后理论：</strong> 最优传输（Optimal Transport）</p>
</li>
<li><p><strong>SDF性质：</strong></p>
<ul>
<li>对于刚体，SDF不需要实时计算；<ul>
<li>$n$个刚体运动，对于一个点$P$ ，就有$SDF_1(P), SDF_2(P)……SDF_n(P)$，那该点最后的SDF值即为$min(SDF_1(P), SDF_2(P)……SDF_n(P))$</li>
</ul>
</li>
<li>对于形变的物体，SDF需要实时计算；</li>
</ul>
</li>
<li><p><strong>用途：</strong></p>
<ul>
<li>Ray marching</li>
<li>软阴影</li>
</ul>
</li>
</ul>
<p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/DistanceField.png" alt="DistanceField"></p>
<ul>
<li><strong><font color="red">WARNING：不要看到图形就认为SDF是存储一张图形，SDF是三维存储，对于空间中每一个点都有其SDF值</font></strong></li>
</ul>
<h3 id="f-1-1-Ray-marching"><a href="#f-1-1-Ray-marching" class="headerlink" title="f.1.1). Ray marching"></a>f.1.1). Ray marching</h3><p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/RayMarching.png" alt="RayMarching"></p>
<ul>
<li><p><strong>作用：</strong>Ray marching(sphere tracing)用来<strong>在SDF中射线与物体求交</strong></p>
</li>
<li><p><strong>关键思想：</strong></p>
<p><strong>SDF中一点的值，即是该点与周围物体不相交的“安全距离”</strong>。如对于点$P$，在周围半径为$SDF(P)$ 的距离内，不与物体相交；</p>
<ul>
<li>因此，以图为例，求SDF中射线与物体相交只需要依次步进$SDF(P)$ , $SDF(A)$ , $SDF(P)$，只需要终点的$SDF(Last)$ 小于一定值，即该点为交点（或一定次数步进后仍没交点，说明该点无交点）</li>
</ul>
</li>
</ul>
<h3 id="f-1-2-Soft-Shadow"><a href="#f-1-2-Soft-Shadow" class="headerlink" title="f.1.2). Soft Shadow"></a>f.1.2). Soft Shadow</h3><p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/SDF_SS.png" alt="SDF_SS"></p>
<ul>
<li><p><strong>作用：</strong> 使用SDF来近似表现遮挡百分比（<em>Visibility</em>）</p>
</li>
<li><p><strong>关键思想：</strong></p>
<p><strong>SDF中一点的值，即是该点实现不被某一物体遮挡“安全角度”</strong></p>
<ul>
<li>如着色点$P$看向面光源$AB$，通过得到射向面光源中点的Ray marching来得到”安全角度”。通过安全角度在总角度中的占比，来近似<em>Visibility</em></li>
<li><strong>Smaller “safe” angle &lt;-&gt; less visibility</strong></li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>安全角度：</strong></p>
<p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/SDF_SS02.png" alt="SDF_SS02"></p>
<ul>
<li><strong>缺点：</strong> 在shader中涉及反三角函数，开销大；</li>
</ul>
<p><img src="/2023/02/01/Games202_02_Real-Time%20Shadow/SDF_SafeAngle.png" alt="SDF_SafeAngle"></p>
<ul>
<li>因此用<script type="math/tex; mode=display">
\min \left\{\frac{k \cdot \operatorname{SDF}(p)}{|p-o|}, 1.0\right\}</script>来替代，并用 <strong>$k$ 控制阴影的软硬程度</strong>；</li>
</ul>
</li>
</ul>
<h2 id="f-2-Pros-and-Cons"><a href="#f-2-Pros-and-Cons" class="headerlink" title="f.2). Pros and Cons"></a>f.2). Pros and Cons</h2><ul>
<li><strong>Pros</strong><ul>
<li>快（使用角度，不考虑生成）</li>
<li>高质量</li>
</ul>
</li>
<li><strong>Cons</strong><ul>
<li>需要预计算</li>
<li>需要额外存储（不仅仅是图形，而是需要<strong>三维空间存储</strong>）</li>
<li>对于形变物体需要大量实时计算</li>
<li>……</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Games202</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>Games202</tag>
      </tags>
  </entry>
  <entry>
    <title>Games202-4 Real-time Global Illumination(in 3D)</title>
    <url>/2023/02/02/Games202_04_Real-time%20Global%20Illumination/</url>
    <content><![CDATA[<h1 id="Real-time-Global-Illumination-in-3D"><a href="#Real-time-Global-Illumination-in-3D" class="headerlink" title="Real-time Global Illumination(in 3D)"></a>Real-time Global Illumination(in 3D)</h1><h1 id="a-Introduction"><a href="#a-Introduction" class="headerlink" title="a). Introduction"></a>a). Introduction</h1><ul>
<li>In RTR, people seek simple and fast solutions to <strong>one bounce indirect illumination</strong></li>
</ul>
<p><img src="/2023/02/02/Games202_04_Real-time%20Global%20Illumination/GI00b.png" alt="GI00b"></p>
<ul>
<li><p><strong>Primary LIght Source（真正的光源，太阳）</strong></p>
</li>
<li><p><strong>Secondary Light Source(次级光源，Q点)</strong></p>
<p><img src="/2023/02/02/Games202_04_Real-time%20Global%20Illumination/GI00a.png" alt="GI00a"></p>
</li>
</ul>
<ul>
<li><strong>观察（要得到$p$点的间接光照我们需要做什么）：</strong><ol>
<li>得到<strong>Secondary light source</strong>（哪些点被光源照射到）<ul>
<li><strong>方法：</strong> Shadow Mapping</li>
</ul>
</li>
<li>得到各个<strong>Secondary light source对 $p$点 Radiance的贡献</strong><ul>
<li><strong>方法：</strong> 解渲染方程</li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li>以下是实时渲染中常用的在3D空间中（意为渲染效果不取决于相机位置/屏幕空间）的GI方法（<strong>主要针对one bounce indirect illumination</strong>）：<ul>
<li>Reflective Shadow Maps (RSM)</li>
<li>Light Propagation Volumes (LPV)</li>
<li>Voxel Global Illumination (VXGI)</li>
</ul>
</li>
</ul>
<hr>
<h1 id="b-Reflective-Shadow-Maps-RSM"><a href="#b-Reflective-Shadow-Maps-RSM" class="headerlink" title="b). Reflective Shadow Maps (RSM)"></a>b). Reflective Shadow Maps (RSM)</h1><p><img src="/2023/02/02/Games202_04_Real-time%20Global%20Illumination/GI00a.png" alt="GI00a"></p>
<ul>
<li>得到<strong>Secondary light source</strong>（哪些点被光源照射到）<ul>
<li>Shadow map中每一个Texel都是一个作为Secondary light sourc的面片（Surface patch）<ul>
<li>Shadow map做阴影中是光源视角的$Depth$，和相机视角的比较；这里是光源视角的$Depth$和 点$p$ 视角比较</li>
</ul>
</li>
</ul>
</li>
<li>得到各个<strong>Secondary light source对 $p$点 Radiance的贡献</strong><ul>
<li>但是，对于不同的 点$p$ 次级光源入射方向是不一定的。即，即使观察角度固定，同一个Shadow map中的Surface patch，对不同的 $p$ 贡献不同；</li>
</ul>
</li>
</ul>
<ul>
<li><strong>假设：</strong><ul>
<li><strong>次级光源均为Diffuse</strong>（观察角度固定，同一个次级光源对不同 点$p$ 的贡献相同）</li>
<li>Therefore, outgoing radiance is uniform toward all directions</li>
</ul>
</li>
</ul>
<h2 id="b-1-得到各个Secondary-light-source对-p-点-Radiance的贡献"><a href="#b-1-得到各个Secondary-light-source对-p-点-Radiance的贡献" class="headerlink" title="b.1). 得到各个Secondary light source对 $p$点 Radiance的贡献"></a>b.1). 得到各个Secondary light source对 $p$点 Radiance的贡献</h2><p><img src="/2023/02/02/Games202_04_Real-time%20Global%20Illumination/RSM_01a.png" alt="RSM_01a"></p>
<script type="math/tex; mode=display">
\begin{aligned}
L_{o}\left(\mathrm{p}, \omega_{o}\right) & =\int_{\Omega_{\mathrm{patch}}} L_{i}\left(\mathrm{p}, \omega_{i}\right) V\left(\mathrm{p}, \omega_{i}\right) f_{r}\left(\mathrm{p}, \omega_{i}, \omega_{o}\right) \cos \theta_{i} \mathrm{~d} \omega_{i} \\
& =\int_{A_{\mathrm{patch}}} L_{i}(\mathrm{q} \rightarrow \mathrm{p}) V\left(\mathrm{p}, \omega_{i}\right) f_{r}\left(\mathrm{p}, \mathrm{q} \rightarrow \mathrm{p}, \omega_{o}\right) \frac{\cos \theta_{p} \cos \theta_{q}}{\|q-p\|^{2}} \mathrm{~d} A
\end{aligned}</script><ul>
<li><p>对于每个diffuse reflective patch(点$q$)</p>
<ul>
<li><p><strong>点$q$</strong> 的BRDF: $f_{rq} = \rho/\pi$ </p>
</li>
<li><p>$L_i(q\rightarrow p) = f_{rq} \cdot \frac{\Phi}{d A}$ ( $\Phi$ 是光源的辐射通量，将该式带入渲染方程，${d A}$ 被消除)</p>
</li>
<li><script type="math/tex; mode=display">
E_{q}(x,n)=\Phi_{q}\frac{\mathrm{max}\{0,\langle n_{q}|x-x_{q}\rangle\}\mathrm{max}\{0,\langle n|x_{q}-x\rangle\}}{||x-x_{q}||^{4}}.</script><ul>
<li>${||x-x_{q}||^{4}}$ 是因为分子上$x-x_{q}$是未归一化的向量；</li>
<li>$\Phi_p$ 为 $f_{rq} \cdot {\Phi}$</li>
<li>将$E_p(x,n)$ 乘上 点$p$ 的BRDF即可得出$L_o$</li>
<li>$V$：Visibility项就不算了</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>Not all pixels in the RSM can contribute</strong></p>
<p><img src="/2023/02/02/Games202_04_Real-time%20Global%20Illumination/RSM_04.png" alt="RSM_04"></p>
<ul>
<li><p>Visibility (难处理，不管了)</p>
</li>
<li><p>Orientation（方向，Reflector的反射方向只在法向半球上，法向半球的方向覆盖不到的Shading Point自然不受该Reflector的影响）</p>
</li>
<li><p>Distance（只有和Shading Point近的Reflector才做贡献）</p>
<ul>
<li><p><strong>假设：</strong> 世界坐标下，两点接近 $\rightarrow$ Shadow Map（世界空间转换到光源空间）中距离比较近，且深度相差不大；</p>
</li>
<li><p>进一步加速（类似于Step 1 and 3 in PCSS），在shading point转换到Shadow Map后对应点$(s,t)$ 的一定范围内，做随机采样</p>
<p><img src="/2023/02/02/Games202_04_Real-time%20Global%20Illumination/RSM_Distance.png" alt="RSM_Distance"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="b-2-光源视角下储存的信息（Shadow-Map）"><a href="#b-2-光源视角下储存的信息（Shadow-Map）" class="headerlink" title="b.2). 光源视角下储存的信息（Shadow Map）"></a>b.2). 光源视角下储存的信息（Shadow Map）</h2><p><img src="/2023/02/02/Games202_04_Real-time%20Global%20Illumination/RSM_Record.png" alt="RSM_Record"></p>
<ul>
<li>深度</li>
<li>世界坐标</li>
<li>法线</li>
<li>辐射通量（flux）</li>
<li>etc.</li>
</ul>
<h2 id="b-3-Pros-And-Cons"><a href="#b-3-Pros-And-Cons" class="headerlink" title="b.3). Pros And Cons"></a>b.3). Pros And Cons</h2><ul>
<li>Pros:<ul>
<li>好写（类似于Shadow Map）</li>
</ul>
</li>
<li>Cons:<ul>
<li>计算量随光源（Primary Light Source）数量增多线性增加</li>
<li>Visibility无法处理</li>
<li>很多假设：diffuse reflectors, depth as distance, etc.<ul>
<li>只能处理次级光源为Diffuse</li>
</ul>
</li>
<li>质量依赖于采样率</li>
</ul>
</li>
</ul>
<h1 id="c-Light-Propagation-Volumes-LPV"><a href="#c-Light-Propagation-Volumes-LPV" class="headerlink" title="c). Light Propagation Volumes(LPV)"></a>c). Light Propagation Volumes(LPV)</h1><ul>
<li>CryEngine3 里用到了，在孤岛危机里应用<ul>
<li>快而且质量好</li>
<li>同样也只能处理次级光源为Diffuse</li>
</ul>
</li>
</ul>
<p><img src="/2023/02/02/Games202_04_Real-time%20Global%20Illumination/LPV_CryEngine.png" alt="LPV_CryEngine"></p>
<ul>
<li><strong>Key idea:</strong> 光线直线传播中，Radiance大小不变；</li>
<li><strong>Key solution:</strong> 通过3D网格<strong>(体素，Voxel)</strong>，传播Secondary Light Source/dirctly illminated surfaces的Radiance到其他地方；</li>
</ul>
<ul>
<li><strong>Steps:</strong><ol>
<li><strong>生成</strong>场景中被直接光照照射到的<strong>Radiance point</strong>(即Secondary light source)；</li>
<li>将Radiance point<strong>注入到体素</strong>中；</li>
<li>Radiance在体素中<strong>传播</strong>；</li>
<li>传播稳定后（一般迭代4、5次），通过体素中储存的Radiance进行Shading；</li>
</ol>
</li>
</ul>
<h2 id="c-1-做法"><a href="#c-1-做法" class="headerlink" title="c.1). 做法"></a>c.1). 做法</h2><h3 id="Step-1-Generation"><a href="#Step-1-Generation" class="headerlink" title="Step 1: Generation"></a>Step 1: Generation</h3><ul>
<li>找到Secondary light source</li>
<li>使用Reflective Shadow Maps (RSM)；</li>
</ul>
<p><img src="/2023/02/02/Games202_04_Real-time%20Global%20Illumination/LPV_Step01.png" alt="LPV_Step01" style="zoom: 50%;"></p>
<h3 id="Step-2-Injection-注入"><a href="#Step-2-Injection-注入" class="headerlink" title="Step 2: Injection(注入)"></a>Step 2: Injection(注入)</h3><ul>
<li>预先划分好3D网格（体素）；</li>
<li>对于每一个体素，找到其内部的Secondary light source；</li>
<li>将他们出射的Radiance大小和方向看做是球面函数，<strong>投影到2阶（4个）的球谐函数上</strong>；</li>
</ul>
<p><img src="/2023/02/02/Games202_04_Real-time%20Global%20Illumination/LPV_Step02.png" alt="LPV_Step02" style="zoom:33%;"></p>
<h3 id="Step-3-Propagation-传播"><a href="#Step-3-Propagation-传播" class="headerlink" title="Step 3: Propagation(传播)"></a>Step 3: Propagation(传播)</h3><p><img src="/2023/02/02/Games202_04_Real-time%20Global%20Illumination/LPV_Step03.png" alt="LPV_Step03" style="zoom:50%;"></p>
<ul>
<li>对于每一个Voxel，都会传播到相邻的6个面（3D，前后左右上下，不会斜向传播），也会接收6个面的Radiance；</li>
<li>接收6个面的Radiance并相加后，再次使用SH表示；</li>
<li>重复上述步骤，直至传播接近稳定（一般整体迭代4-5次）</li>
</ul>
<h3 id="Step4-Rendering"><a href="#Step4-Rendering" class="headerlink" title="Step4: Rendering"></a>Step4: Rendering</h3><ul>
<li>对于每一个着色点，找到他们所处的Voxel；</li>
<li>使用该Voxel中存储的Radiance<strong>（from all direction, 是一个SH表达的球面函数）</strong>，进行Shading；<ul>
<li>因为存储的是球面函数形式的Radiance，所以既可以做Diffuse也可以做Gloosy</li>
</ul>
</li>
</ul>
<p><img src="/2023/02/02/Games202_04_Real-time%20Global%20Illumination/LPV_Step04.png" alt="LPV_Step04" style="zoom:67%;"></p>
<ul>
<li><p><strong>造成的问题：</strong> 由于同一个Voxel中Radiance相同，对于薄的几何体可能造成<strong>Light leaking</strong></p>
<p><img src="/2023/02/02/Games202_04_Real-time%20Global%20Illumination/LPV_LightLeaking.png" alt="LPV_LightLeaking"></p>
</li>
</ul>
<h1 id="d-Voxel-Global-Illumination-VXGI"><a href="#d-Voxel-Global-Illumination-VXGI" class="headerlink" title="d). Voxel Global Illumination (VXGI)"></a>d). Voxel Global Illumination (VXGI)</h1><ul>
<li>与RSM两点主要的不同<ul>
<li>将被光源直接照射的像素变为<strong>带有层级的体素（hierarchical voxels）</strong>（即Secondary light source不再看成surface patch，而是hierarchical voxels）</li>
<li>光线传播方式：<ul>
<li>从摄像机开始传播，进行锥形传播（Cone tracing，比如光线在Gloosy表面弹射，出射方向为一个锥形），计算锥体相交的Voxel对该点的Radiance贡献；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="d-1-做法"><a href="#d-1-做法" class="headerlink" title="d.1). 做法"></a>d.1). 做法</h2><p><img src="/2023/02/02/Games202_04_Real-time%20Global%20Illumination/VXGI_00.png" alt="VXGI_00"></p>
<hr>
<h3 id="Pass-1-from-the-light"><a href="#Pass-1-from-the-light" class="headerlink" title="Pass 1: from the light"></a>Pass 1: from the light</h3><ul>
<li>储存每个点的入射Radiance，并储存到对应的Voxel中；</li>
<li>Voxel中存储Incident lighting和normal的分布，以便支持Gloosy等材质；<ul>
<li>存储Lobe分布的基础：Cone Trace</li>
</ul>
</li>
<li>根据这两个分布，即可得出 出射Radiance 的分布情况；</li>
</ul>
<p><img src="/2023/02/02/Games202_04_Real-time%20Global%20Illumination/VXGI_Pass01.png" alt="VXGI_Pass01"></p>
<h3 id="Pass-2-from-the-camera"><a href="#Pass-2-from-the-camera" class="headerlink" title="Pass 2: from the camera"></a>Pass 2: from the camera</h3><ul>
<li>对于Gloosy的表面，追踪1个朝向反射方向的圆锥；</li>
<li>根据圆锥的（grow）大小，查询相应层级；</li>
</ul>
<p><img src="/2023/02/02/Games202_04_Real-time%20Global%20Illumination/VXGI_Pass02.png" alt="VXGI_Pass02"></p>
<ul>
<li><p>对于Diffuse，追踪多个Cones</p>
<p><img src="/2023/02/02/Games202_04_Real-time%20Global%20Illumination/VXGI_Pass02_Diffuse.png" alt="VXGI_Pass02_Diffuse"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Games202</category>
      </categories>
      <tags>
        <tag>图形学</tag>
        <tag>Games202</tag>
      </tags>
  </entry>
</search>
